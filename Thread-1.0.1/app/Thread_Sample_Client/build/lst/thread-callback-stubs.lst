###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  14:43:38
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\thread-callback-stubs.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\thread-callback-stubs.c
#        -D APP_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D
#        PHY_EM3XX -D "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"thread-callback-stubs.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\lst\thread-callback-stubs.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\obj\thread-callback-stubs.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\thread-callback-stubs.c
      1          // This file is generated by Ember Desktop.  Please do not edit manually.
      2          //
      3          //
      4          
      5          #include PLATFORM_HEADER
      6          #include CONFIGURATION_HEADER
      7          #include EMBER_AF_API_EMBER_TYPES
      8          #include EMBER_AF_API_HAL
      9          #include EMBER_AF_API_SIM_EEPROM
     10          #include EMBER_AF_API_STACK
     11          #include EMBER_AF_API_TFTP_BOOTLOADER
     12          
     13          
     14          
     15          /** @brief A callback called in interrupt context whenever a button
     16           * changes its state.
     17           *
     18           * @appusage Must be implemented by the application.  This function should
     19           * contain the functionality to be executed in response to changes of state
     20           * in each of the buttons, or callbacks to the appropriate functionality.
     21           *
     22           * @param button  The button which has changed state, either BUTTON0 or BUTTON1
     23           * as defined in the appropriate BOARD_HEADER.
     24           *
     25           * @param state   The new state of the button referenced by the button parameter,
     26           * either ::BUTTON_PRESSED if the button has been pressed or ::BUTTON_RELEASED if
     27           * the button has been released.
     28           */

   \                                 In section .text, align 2, keep-with-next
     29          void halButtonIsr(uint8_t button, uint8_t state)
     30          {
     31          }
   \                     halButtonIsr: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     32          
     33          
     34          
     35          /** @brief Ok To Sleep
     36           *
     37           * This function is called by the Idle/Sleep plugin before sleeping.  It is
     38           * called with interrupts disabled.  The application should return true if the
     39           * device may sleep or false otherwise.
     40           *
     41           * @param durationMs The maximum duration in milliseconds that the device will
     42           * sleep.
     43           */

   \                                 In section .text, align 2, keep-with-next
     44          bool emberAfPluginIdleSleepOkToSleepCallback(uint32_t durationMs)
     45          {
     46            return true;
   \                     emberAfPluginIdleSleepOkToSleepCallback: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
     47          }
     48          
     49          
     50          /** @brief Wake Up
     51           *
     52           * This function is called by the Idle/Sleep plugin after sleeping.
     53           *
     54           * @param durationMs The duration in milliseconds that the device slept.
     55           */

   \                                 In section .text, align 2, keep-with-next
     56          void emberAfPluginIdleSleepWakeUpCallback(uint32_t durationMs)
     57          {
     58          }
   \                     emberAfPluginIdleSleepWakeUpCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     59          
     60          
     61          /** @brief Ok To Idle
     62           *
     63           * This function is called by the Idle/Sleep plugin before idling.  It is called
     64           * with interrupts disabled.  The application should return true if the device
     65           * may idle or false otherwise.
     66           *
     67           * @param durationMs The maximum duration in milliseconds that the device will
     68           * idle.
     69           */

   \                                 In section .text, align 2, keep-with-next
     70          bool emberAfPluginIdleSleepOkToIdleCallback(uint32_t durationMs)
     71          {
     72            return true;
   \                     emberAfPluginIdleSleepOkToIdleCallback: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
     73          }
     74          
     75          
     76          /** @brief Active
     77           *
     78           * This function is called by the Idle/Sleep plugin after idling.
     79           *
     80           * @param durationMs The duration in milliseconds that the device idled.
     81           */

   \                                 In section .text, align 2, keep-with-next
     82          void emberAfPluginIdleSleepActiveCallback(uint32_t durationMs)
     83          {
     84          }
   \                     emberAfPluginIdleSleepActiveCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     85          
     86          
     87          
     88          /** @brief Main
     89           *
     90           * This function is called immediately after the application starts executing
     91           * and can be used to perform initialization that should occur before any other
     92           * components are initialized.
     93           */

   \                                 In section .text, align 2, keep-with-next
     94          void emberAfMainCallback(MAIN_FUNCTION_PARAMETERS)
     95          {
     96          }
   \                     emberAfMainCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     97          
     98          
     99          /** @brief Tick
    100           *
    101           * This function is called in each iteration of the main application loop and
    102           * can be used to perform periodic functions.  The frequency with which this
    103           * function is called depends on how quickly the main loop runs.  If the
    104           * application blocks at any time during the main loop, this function will not
    105           * be called until execution resumes.  On SoC platforms, sleeping and idling
    106           * will block.  On Unix hosts, process yielding (e.g., via select) will block.
    107           */

   \                                 In section .text, align 2, keep-with-next
    108          void emberAfTickCallback(void)
    109          {
    110          }
   \                     emberAfTickCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    111          
    112          
    113          /** @brief Mark Application Buffers
    114           *
    115           * This function is called when the application must mark its buffers.  Buffers
    116           * that are not marked will be reclaimed by the stack.
    117           */

   \                                 In section .text, align 2, keep-with-next
    118          void emberAfMarkApplicationBuffersCallback(void)
    119          {
    120          }
   \                     emberAfMarkApplicationBuffersCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    121          
    122          
    123          
    124          /** @brief The Simulated EEPROM callback function, implemented by the
    125           * application.
    126           *
    127           * @param status  An ::EmberStatus error code indicating one of the conditions
    128           * described below.
    129           *
    130           * This callback will report an EmberStatus of
    131           * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN whenever a token is set and a page needs
    132           * to be erased.  If the main application loop does not periodically
    133           * call halSimEepromErasePage(), it is best to then erase a page in
    134           * response to ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN.
    135           *
    136           * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_ERASE_PAGE_RED
    137           * when the pages <i>must</i> be erased to prevent data loss.
    138           * halSimEepromErasePage() needs to be called until it returns 0 to indicate
    139           * there are no more pages that need to be erased.  Ignoring
    140           * this indication and not erasing the pages will cause dropping the new data
    141           * trying to be written.
    142           *
    143           * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_FULL when
    144           * the new data cannot be written due to unerased pages.  <b>Not erasing
    145           * pages regularly, not erasing in response to
    146           * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN, or not erasing in response to
    147           * ::EMBER_SIM_EEPROM_ERASE_PAGE_RED will cause
    148           * ::EMBER_SIM_EEPROM_FULL and the new data will be lost!.</b>  Any future
    149           * write attempts will be lost as well.
    150           *
    151           * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_REPAIRING
    152           * when the Simulated EEPROM needs to repair itself.  While there's nothing
    153           * for an app to do when the SimEE is going to repair itself (SimEE has to
    154           * be fully functional for the rest of the system to work), alert the
    155           * application to the fact that repairing is occuring.  There are debugging
    156           * scenarios where an app might want to know that repairing is happening;
    157           * such as monitoring frequency.
    158           * @note  Common situations will trigger an expected repair, such as using
    159           *        a new chip or changing token definitions.
    160           *
    161           * If the callback ever reports the status ::EMBER_ERR_FLASH_WRITE_INHIBITED or
    162           * ::EMBER_ERR_FLASH_VERIFY_FAILED, this indicates a catastrophic failure in
    163           * flash writing, meaning either the address being written is not empty or the
    164           * write itself has failed.  If ::EMBER_ERR_FLASH_WRITE_INHIBITED is
    165           * encountered, the function ::halInternalSimEeRepair(false) should be called
    166           * and the chip should then be reset to allow proper initialization to recover.
    167           * If ::EMBER_ERR_FLASH_VERIFY_FAILED is encountered the Simulated EEPROM (and
    168           * tokens) on the specific chip with this error should not be trusted anymore.
    169           *
    170           */

   \                                 In section .text, align 2, keep-with-next
    171          void halSimEepromCallback(EmberStatus status)
    172          {
   \                     halSimEepromCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    173            switch (status) {
   \   00000004   0x3843             SUBS     R0,R0,#+67
   \   00000006   0x.... 0x....      ADR.W    R5,?_0
   \   0000000A   0xD008             BEQ.N    ??halSimEepromCallback_0
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD909             BLS.N    ??halSimEepromCallback_1
   \   00000012   0x1E80             SUBS     R0,R0,#+2
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD90E             BLS.N    ??halSimEepromCallback_2
   \   00000018   0x1FC0             SUBS     R0,R0,#+7
   \   0000001A   0xD031             BEQ.N    ??halSimEepromCallback_3
   \   0000001C   0xE029             B.N      ??halSimEepromCallback_4
    174            case EMBER_SIM_EEPROM_ERASE_PAGE_GREEN:
    175              //SimEE is asking for one page to be erased.
    176          #ifdef EMBER_STACK_COBRA
    177              HalUARTRestrain();
    178          #endif
    179              halSimEepromErasePage();
   \                     ??halSimEepromCallback_0: (+1)
   \   0000001E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000022   0x.... 0x....      B.W      halSimEepromErasePage
    180              break;
    181            case EMBER_SIM_EEPROM_ERASE_PAGE_RED:
    182            case EMBER_SIM_EEPROM_FULL:
    183            { //SimEE says we're out of room!  Erase all pages now or data
    184              //currently being written will be dropped.
    185              bool erasedSome = false;
   \                     ??halSimEepromCallback_1: (+1)
   \   00000026   0x2600             MOVS     R6,#+0
   \   00000028   0xE000             B.N      ??halSimEepromCallback_5
    186          #ifdef EMBER_STACK_COBRA
    187              HalUARTRestrain();
    188          #endif
    189              while(halSimEepromErasePage()) { erasedSome = true; }
   \                     ??halSimEepromCallback_6: (+1)
   \   0000002A   0x2601             MOVS     R6,#+1
   \                     ??halSimEepromCallback_5: (+1)
   \   0000002C   0x.... 0x....      BL       halSimEepromErasePage
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD1FA             BNE.N    ??halSimEepromCallback_6
    190              if(erasedSome) {
   \   00000034   0xBB26             CBNZ.N   R6,??halSimEepromCallback_3
    191                break;
    192              }
    193              //If nothing got erased, then we have a situation where page
    194              //rotation is stuck because live tokens still exist in the
    195              //page we want to erase.  In this case we must do a repair to
    196              //get all live tokens into one virtual page. [BugzId:14392]
    197              //Fall into...
    198            }
    199            case EMBER_ERR_FLASH_WRITE_INHIBITED:
    200            case EMBER_ERR_FLASH_VERIFY_FAILED:
    201            { //Something went wrong while writing a token.  There is stale data and the
    202              //token the app expected to write did not get written.  Also there may
    203              //now be "stray" data written in the flash that could inhibit future token
    204              //writes.  To deal with stray/stale data, we must repair the Simulated
    205              //EEPROM.  Because the expected token write failed and will not be retried,
    206              //it is best to reset the chip and let normal boot sequences take over.
    207              //Since halInternalSimEeRepair() could potentially result in another write
    208              //failure, we use a simple semaphore to prevent recursion.
    209              static bool repairActive = false;
    210              if(!repairActive) {
   \                     ??halSimEepromCallback_2: (+1)
   \   00000036   0x....             LDR.N    R6,??DataTable1
   \   00000038   0x7830             LDRB     R0,[R6, #+0]
   \   0000003A   0xBB08             CBNZ.N   R0,??halSimEepromCallback_3
    211                repairActive = true;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x7030             STRB     R0,[R6, #+0]
    212                halInternalSimEeRepair(false);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       halInternalSimEeStartup
    213                switch (status) {
   \   00000046   0x2C45             CMP      R4,#+69
   \   00000048   0xD010             BEQ.N    ??halSimEepromCallback_7
   \   0000004A   0xD30B             BCC.N    ??halSimEepromCallback_8
   \   0000004C   0x2C47             CMP      R4,#+71
   \   0000004E   0xD001             BEQ.N    ??halSimEepromCallback_9
   \   00000050   0xD303             BCC.N    ??halSimEepromCallback_10
   \   00000052   0xE007             B.N      ??halSimEepromCallback_8
    214                case EMBER_SIM_EEPROM_FULL:
    215                  //Don't reboot - return to let SimEE code retry the token write
    216                  //[BugzId:14392]
    217                  break;
    218                case EMBER_ERR_FLASH_VERIFY_FAILED:
    219                  //[[WBB350FIXME -It would be nice to have a unified, ]]
    220                  //[[             platform independant reboot machanism]]
    221                  #if defined (XAP2B)
    222                    halInternalSysReset(CE_REBOOT_F_VERIFY);
    223                  #elif defined (CORTEXM3)
    224                    halInternalSysReset(RESET_FLASH_VERIFY);
   \                     ??halSimEepromCallback_9: (+1)
   \   00000054   0xF640 0x0001      MOVW     R0,#+2049
   \   00000058   0xE001             B.N      ??halSimEepromCallback_11
    225                  #else
    226                    assert(0);
    227                  #endif
    228                  break;
    229                case EMBER_ERR_FLASH_WRITE_INHIBITED:
    230                  #if defined (XAP2B)
    231                    halInternalSysReset(CE_REBOOT_F_INHIBIT);
    232                  #elif defined (CORTEXM3)
    233                    halInternalSysReset(RESET_FLASH_INHIBIT);
   \                     ??halSimEepromCallback_10: (+1)
   \   0000005A   0xF640 0x0002      MOVW     R0,#+2050
   \                     ??halSimEepromCallback_11: (+1)
   \   0000005E   0x.... 0x....      BL       halInternalSysReset
    234                  #else
    235                    assert(0);
    236                  #endif
    237                  break;
   \   00000062   0xE003             B.N      ??halSimEepromCallback_7
    238                default:
    239                  assert(0);
   \                     ??halSimEepromCallback_8: (+1)
   \   00000064   0x21EF             MOVS     R1,#+239
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       halInternalAssertFailed
    240                  break;
    241                }
    242                repairActive = false;
   \                     ??halSimEepromCallback_7: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7030             STRB     R0,[R6, #+0]
   \   00000070   0xBD70             POP      {R4-R6,PC}
    243              }
    244              break;
    245            }
    246            case EMBER_SIM_EEPROM_REPAIRING:
    247              // While there's nothing for an app to do when the SimEE is going to
    248              // repair itself (SimEE has to be fully functional for the rest of the
    249              // system to work), alert the application to the fact that repairing
    250              // is occuring.  There are debugging scenarios where an app might want
    251              // to know that repairing is happening; such as monitoring frequency.
    252              // NOTE:  Common situations will trigger an expected repair, such as
    253              //        using an erased chip or changing token definitions.
    254              break;
    255            default:
    256              // this condition indicates an unexpected problem.
    257              assert(0);
   \                     ??halSimEepromCallback_4: (+1)
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000078   0xF240 0x1101      MOVW     R1,#+257
   \   0000007C   0x.... 0x....      B.W      halInternalAssertFailed
    258              break;
    259            }
    260          }
   \                     ??halSimEepromCallback_3: (+1)
   \   00000080   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 1
   \                     ??repairActive:
   \   00000000                      DS8 1
    261          
    262          
    263          
    264          /** @brief A callback that allows the application to send a message in
    265            * response to a poll from a child.
    266            *
    267            * This function is called when a child polls,
    268            * provided that the pending message flag is set for that child
    269            * (see ::emberSetMessageFlag(). The message should be sent to the child
    270            * using ::emberSendUnicast() with the ::EMBER_APS_OPTION_POLL_RESPONSE option.
    271            *
    272            * If the application includes ::emberPollHanlder(), it must
    273            * define EMBER_APPLICATION_HAS_POLL_HANDLER in its CONFIGURATION_HEADER.
    274            *
    275            * @param childId           The ID of the child that is requesting data.
    276            *
    277            * @param transmitExpected  true if the child is expecting an application-
    278            *     supplied data message.  false otherwise.
    279            *
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          void emberPollHandler(EmberNodeId childId, bool transmitExpected)
    282          {
    283          }
   \                     emberPollHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    284          
    285          
    286          

   \                                 In section .text, align 2, keep-with-next
    287          void emberIpIncomingBeaconHandler(PacketHeader header)
    288          {
    289          }
   \                     emberIpIncomingBeaconHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    290          
    291          
    292          /** @brief Return call for emberBecomeCommissioner().  The status is
    293           * EMBER_SUCCESS if a petition was sent or EMBER_ERR_FATAL if some
    294           * temporary resource shortage prevented doing so.
    295           */

   \                                 In section .text, align 2, keep-with-next
    296          void emberBecomeCommissionerReturn(EmberStatus status)
    297          {
    298          }
   \                     emberBecomeCommissionerReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    299          
    300          
    301          /** @brief Provices the result of a call to emberChangeNodeType():
    302           * either EMBER_SUCCESS, or EMBER_INVALID_CALL.
    303           */

   \                                 In section .text, align 2, keep-with-next
    304          void emberChangeNodeTypeReturn(EmberStatus status)
    305          {
    306          }
   \                     emberChangeNodeTypeReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    307          
    308          
    309          /**
    310           * @brief Provides the result of a call to emberCommissionNetwork.
    311           *
    312           * Returns EMBER_SUCCESS if successful
    313           *         EMBER_BAD_ARGUMENT if any of the options are wrong
    314           *         EMBER_INVALID_CALL if the node is already on a network
    315           *
    316           * @param status Whether the call to emberCommissionNetwork was successful
    317           */

   \                                 In section .text, align 2, keep-with-next
    318          void emberCommissionNetworkReturn(EmberStatus status)
    319          {
    320          }
   \                     emberCommissionNetworkReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    321          
    322          
    323          /** @brief Reports on the current commissioner state.
    324           *
    325           * @param flags    A combination of zero or more of the following:
    326           * - EMBER_HAVE_COMMISSIONER       a commissioner is active in the network
    327           * - EMBER_AM_COMMISSIONER         this device is the active commissioner
    328           * - EMBER_JOINING_ENABLED         joining is enabled
    329           * - EMBER_JOINING_WITH_STEERING   steering data restricts which devices can join
    330           *                                 if not set, no restriction, any device can join
    331           *                                 (significant only when EMBER_JOINING_ENABLED is set)
    332           *
    333           * @param commissionerName    The name of the active commissioner, or
    334           *                            NULL if there is none or the name is not
    335           *                            known.
    336           *
    337           * @param commissionerNameLength    The length of commissonerName.
    338           */

   \                                 In section .text, align 2, keep-with-next
    339          void emberCommissionerStatusHandler(uint16_t flags,
    340                                              const uint8_t *commissionerName,
    341                                              uint8_t commissionerNameLength)
    342          {
    343          }
   \                     emberCommissionerStatusHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    344          
    345          
    346          /** @brief Provides the result of a call to ::emberConfigureGateway */

   \                                 In section .text, align 2, keep-with-next
    347          void emberConfigureGatewayReturn(EmberStatus status)
    348          {
    349          }
   \                     emberConfigureGatewayReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    350          
    351          
    352          /** @brief A callback invoked to inform the application of the
    353           * occurrence of an event defined by EmberCounterType, for example,
    354           * transmissions and receptions at different layers of the stack.
    355           *
    356           * The application must define EMBER_APPLICATION_HAS_COUNTER_HANDLER
    357           * in its CONFIGURATION_HEADER to use this.
    358           * This function may be called in ISR context, so processing should
    359           * be kept to a minimum.
    360           *
    361           * @param type       The type of the event.
    362           * @param increment  Specify the increase in the counter's tally.
    363           *
    364           */

   \                                 In section .text, align 2, keep-with-next
    365          void emberCounterHandler(EmberCounterType type, uint16_t increment)
    366          {
    367          }
   \                     emberCounterHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    368          
    369          
    370          /** @brief NCP handler called to process a custom message from the Host.
    371           *
    372           * @param message message received
    373           * @param messageLength length of message
    374           */

   \                                 In section .text, align 2, keep-with-next
    375          void emberCustomHostToNcpMessageHandler(const uint8_t *message,
    376                                                  uint8_t messageLength)
    377          {
    378          }
   \                     emberCustomHostToNcpMessageHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    379          
    380          
    381          /** @brief Host handler called to process a custom message from the NCP.
    382           *
    383           * @param message message received
    384           * @param messageLength length of message
    385           */

   \                                 In section .text, align 2, keep-with-next
    386          void emberCustomNcpToHostMessageHandler(const uint8_t *message,
    387                                                  uint8_t messageLength)
    388          {
    389          }
   \                     emberCustomNcpToHostMessageHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    390          
    391          
    392          /** @brief For a sleepy end device, report how long the chip went to deep sleep.
    393           * In a NCP + host setup, the stack reports this to the host app.
    394           */

   \                                 In section .text, align 2, keep-with-next
    395          void emberDeepSleepCallback(uint16_t sleepDuration)
    396          {
    397          }
   \                     emberDeepSleepCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    398          
    399          
    400          /** @brief Provides the result of a call to emberDeepSleep(). */

   \                                 In section .text, align 2, keep-with-next
    401          void emberDeepSleepReturn(EmberStatus status)
    402          {
    403          }
   \                     emberDeepSleepReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    404          
    405          
    406          /** @brief This method is called any time an event is scheduled from within an
    407           * ISR context. It can be used to determine when to stop a long running sleep
    408           * to see what application or stack events now need to be processed.
    409           * @param event The event that was scheduled by the ISR.
    410           */

   \                                 In section .text, align 2, keep-with-next
    411          void emberEventDelayUpdatedFromIsrHandler(Event *event)
    412          {
    413          }
   \                     emberEventDelayUpdatedFromIsrHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    414          
    415          
    416          /** @brief
    417           * This is called when the stack knows about a border router that has
    418           * an external route to a prefix.
    419           *
    420           * @param prefix            external route prefix
    421           * @param prefixLength      length of the prefix
    422           * @param available         whether this external route is available.
    423           */

   \                                 In section .text, align 2, keep-with-next
    424          void emberExternalRouteChange(const uint8_t *prefix,
    425                                        uint8_t prefixLength,
    426                                        bool available)
    427          {
    428          }
   \                     emberExternalRouteChange: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    429          
    430          
    431          /** @brief Provides the result of a call to emberFormNetwork(). */

   \                                 In section .text, align 2, keep-with-next
    432          void emberFormNetworkReturn(EmberStatus status)
    433          {
    434          }
   \                     emberFormNetworkReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    435          
    436          
    437          /** @brief Provides the result of a call to emberGetCcaThreshold(). */

   \                                 In section .text, align 2, keep-with-next
    438          void emberGetCcaThresholdReturn(int8_t threshold)
    439          {
    440          }
   \                     emberGetCcaThresholdReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    441          
    442          
    443          /** @brief
    444           * Gets the token information for tokenId = EMBER_CHANNEL_CAL_DATA_TOKEN
    445           *
    446           * @param lna          [msb: cal needed? | bit 0-5: lna tune value]
    447           * @param tempAtLna    [the temp (degC) when the LNA was calibrated]
    448           * #param modDac       [msb: cal needed? | bit 0-5: modulation DAC tune value]
    449           * @param tempAtModDac [the temp (degC) when the mod DAC was calibrated]
    450           */

   \                                 In section .text, align 2, keep-with-next
    451          void emberGetChannelCalDataTokenReturn(uint8_t lna,
    452                                                 int8_t tempAtLna,
    453                                                 uint8_t modDac,
    454                                                 int8_t tempAtModDac)
    455          {
    456          }
   \                     emberGetChannelCalDataTokenReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    457          
    458          
    459          /** @brief Provides the result of a call to emberGetCounter(). */

   \                                 In section .text, align 2, keep-with-next
    460          void emberGetCounterReturn(EmberCounterType type, uint16_t value)
    461          {
    462          }
   \                     emberGetCounterReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    463          
    464          
    465          /** @brief Provides the result of a call to ::emberGetDhcpClients */

   \                                 In section .text, align 2, keep-with-next
    466          void emberGetDhcpClientReturn(const EmberIpv6Address *address)
    467          {
    468          }
   \                     emberGetDhcpClientReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    469          
    470          
    471          /** @brief Provides the result of a call to emberGetNetworkDataTlv().
    472           *
    473           * @param type the type of TLV returned. This is the same value as
    474           * the value specified in the emberGetNetworkDataTlv() call.
    475           * @param index the instance number of the TLV. This is the same value as
    476           * the value specified in the emberGetNetworkDataTlv() call.
    477           * @param versionNumber the network data version
    478           * @param tlv the TLV corresponding to type or NULL.
    479           * @param tlvLength length of tlv
    480           */

   \                                 In section .text, align 2, keep-with-next
    481          void emberGetNetworkDataTlvReturn(uint8_t typeByte,
    482                                            uint8_t index,
    483                                            uint8_t versionNumber,
    484                                            const uint8_t *tlv,
    485                                            uint8_t tlvLength)
    486          {
    487          }
   \                     emberGetNetworkDataTlvReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    488          
    489          
    490          /** @brief Provides the result of a call to emberGetRadioPower() on the host. */

   \                                 In section .text, align 2, keep-with-next
    491          void emberGetRadioPowerReturn(int8_t power)
    492          {
    493          }
   \                     emberGetRadioPowerReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    494          
    495          
    496          /** @brief Provides the result of a call to emberGetRipEntry(). */

   \                                 In section .text, align 2, keep-with-next
    497          void emberGetRipEntryReturn(uint8_t index, const EmberRipEntry *entry)
    498          {
    499          }
   \                     emberGetRipEntryReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    500          
    501          
    502          /** @brief Provides the result of a call to ::emberGetRoutingLocator
    503           *
    504           * @param rloc The Routing Locator as a full IPv6 address.
    505           */

   \                                 In section .text, align 2, keep-with-next
    506          void emberGetRoutingLocatorReturn(const EmberIpv6Address *rloc)
    507          {
    508          }
   \                     emberGetRoutingLocatorReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    509          
    510          
    511          /** @brief Provides the result of a call to emberGetTxPowerMode() on the host.
    512           * @return the current tx power mode.
    513           */

   \                                 In section .text, align 2, keep-with-next
    514          void emberGetTxPowerModeReturn(uint16_t txPowerMode)
    515          {
    516          }
   \                     emberGetTxPowerModeReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    517          
    518          
    519          /** @brief Application handler to define "passthrough" packets.
    520           */

   \                                 In section .text, align 2, keep-with-next
    521          bool emberMacPassthroughFilterHandler(uint8_t *macHeader)
    522          {
    523            return false;
   \                     emberMacPassthroughFilterHandler: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    524          }
    525          
    526          
    527          /** @brief Application handler to intercept "passthrough" packets and
    528           * handle them at the application.
    529           */

   \                                 In section .text, align 2, keep-with-next
    530          void emberMacPassthroughMessageHandler(PacketHeader header)
    531          {
    532          }
   \                     emberMacPassthroughMessageHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    533          
    534          
    535          /** @brief A callback invoked when the leader data changes.
    536           *
    537           * @param leaderData the leader data
    538           */

   \                                 In section .text, align 2, keep-with-next
    539          void emberLeaderDataHandler(const uint8_t *leaderData)
    540          {
    541          }
   \                     emberLeaderDataHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    542          
    543          
    544          /** @brief  If implementing event-driven sleep on an NCP host, this method will
    545           * return the bitmask indicating the stack's current tasks. (see enum above)
    546           *
    547           *  The mask ::EMBER_HIGH_PRIORITY_TASKS defines which tasks are high
    548           *  priority.  Devices should not sleep if any high priority tasks are active.
    549           *  Active tasks that are not high priority are waiting for
    550           *  messages to arrive from other devices.  If there are active tasks,
    551           *  but no high priority ones, the device may sleep but should periodically
    552           *  wake up and call ::emberPollForData() in order to receive messages.  Parents
    553           *  will hold messages for ::EMBER_INDIRECT_TRANSMISSION_TIMEOUT milliseconds
    554           *  before discarding them.
    555           *
    556           * @return A bitmask of the stack's active tasks.
    557           */

   \                                 In section .text, align 2, keep-with-next
    558          void emberOkToNapReturn(uint8_t stateMask)
    559          {
    560          }
   \                     emberOkToNapReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    561          
    562          
    563          /** @brief Provides the result of a call to emberPollForData().
    564           * @param An EmberStatus value:
    565           * - ::EMBER_SUCCESS      - The poll message has been submitted for transmission
    566           * - ::EMBER_INVALID_CALL - The node is not a sleepy end device.
    567           * - ::EMBER_NOT_JOINED   - The node is not part of a network.
    568           *
    569           * @param Data pending flag: If true, it means the parent is about to send more
    570           *                           data, so the application should take note and poll
    571           *                           more frequently in case of a fragment or indirect
    572           *                           timeout.
    573           */

   \                                 In section .text, align 2, keep-with-next
    574          void emberPollForDataReturn(EmberStatus status, bool dataPending)
    575          {
    576          }
   \                     emberPollForDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    577          
    578          
    579          /** @brief  Notifies the application of a reset on the Ember chip
    580           * due to the indicated cause.
    581           */

   \                                 In section .text, align 2, keep-with-next
    582          void emberResetMicroHandler(EmberResetCause cause)
    583          {
    584          }
   \                     emberResetMicroHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    585          
    586          
    587          /** @brief
    588           * Provides the result of a call to emberResignGlobalAddress().
    589           */

   \                                 In section .text, align 2, keep-with-next
    590          void emberResignGlobalAddressReturn(EmberStatus status)
    591          {
    592          }
   \                     emberResignGlobalAddressReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    593          
    594          
    595          /** @brief Provides the result of a call to emberSendSteeringData(). */

   \                                 In section .text, align 2, keep-with-next
    596          void emberSendSteeringDataReturn(EmberStatus status)
    597          {
    598          }
   \                     emberSendSteeringDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    599          
    600          
    601          /** @brief Provides the result of a call to emberSetCcaThreshold(). */

   \                                 In section .text, align 2, keep-with-next
    602          void emberSetCcaThresholdReturn(EmberStatus status)
    603          {
    604          }
   \                     emberSetCcaThresholdReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    605          
    606          
    607          /** @brief Provides the result of a call to emberSetRadioPower() on the host. */

   \                                 In section .text, align 2, keep-with-next
    608          void emberSetRadioPowerReturn(EmberStatus status)
    609          {
    610          }
   \                     emberSetRadioPowerReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    611          
    612          
    613          /** @brief Provides the result of a call to emberSetSecurityParameters(). */

   \                                 In section .text, align 2, keep-with-next
    614          void emberSetSecurityParametersReturn(EmberStatus status)
    615          {
    616          }
   \                     emberSetSecurityParametersReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    617          
    618          
    619          /** @brief Provides the result of a call to emberSetTxPowerMode() on the host. */

   \                                 In section .text, align 2, keep-with-next
    620          void emberSetTxPowerModeReturn(EmberStatus status)
    621          {
    622          }
   \                     emberSetTxPowerModeReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    623          
    624          
    625          /** @brief Provides the result of a call to emberStackPollForData(). */

   \                                 In section .text, align 2, keep-with-next
    626          void emberStackPollForDataReturn(EmberStatus status)
    627          {
    628          }
   \                     emberStackPollForDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    629          
    630          
    631          /** @brief Callback to tell the host to start security commissioning
    632           *
    633           * @param address parent IP address, 16 bytes
    634           */

   \                                 In section .text, align 2, keep-with-next
    635          void emberStartHostJoinClientHandler(const uint8_t *parentAddress)
    636          {
    637          }
   \                     emberStartHostJoinClientHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    638          
    639          
    640          /** @brief
    641           * This can be stubbed out on the SoC and host app.  It is used by the
    642           * NCP to update security on the driver when it is instructed to switch
    643           * the network key by an over the air update.
    644           *
    645           */

   \                                 In section .text, align 2, keep-with-next
    646          void emberSwitchToNextNetworkKeyHandler(EmberStatus status)
    647          {
    648          }
   \                     emberSwitchToNextNetworkKeyHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    649          
    650          
    651          /** @brief Provides the result of a call to emberSwitchToNextNetworkKey(). */

   \                                 In section .text, align 2, keep-with-next
    652          void emberSwitchToNextNetworkKeyReturn(EmberStatus status)
    653          {
    654          }
   \                     emberSwitchToNextNetworkKeyReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    655          
    656          
    657          /**
    658           * @brief Provides the result of a call to emberState() on the host.
    659           *
    660           * @param parameters Current network parameters
    661           * @param localEui64 The EUI64 of the Ember chip
    662           * @param networkStatus The current status of the network
    663           */

   \                                 In section .text, align 2, keep-with-next
    664          void emberStateReturn(const EmberNetworkParameters *parameters,
    665                                const EmberEui64 *localEui64,
    666                                EmberNetworkStatus networkStatus)
    667          {
    668          }
   \                     emberStateReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    669          
    670          
    671          
    672          /** @brief The radio calibration callback function.
    673           *
    674           * The Voltage Controlled Oscillator (VCO) can drift with
    675           * temperature changes.  During every call to ::emberTick(), the stack will
    676           * check to see if the VCO has drifted.  If the VCO has drifted, the stack
    677           * will call ::emberRadioNeedsCalibratingHandler() to inform the application
    678           * that it should perform calibration of the current channel as soon as
    679           * possible.  Calibration can take up to 150ms.  The default callback function
    680           * implementation provided here performs calibration immediately.  If the
    681           * application wishes, it can define its own callback by defining
    682           * ::EMBER_APPLICATION_HAS_CUSTOM_RADIO_CALIBRATION_CALLBACK in its
    683           * CONFIGURATION_HEADER.  It can then failsafe any critical processes or
    684           * peripherals before calling ::emberCalibrateCurrentChannel().  The
    685           * application must call ::emberCalibrateCurrentChannel() in
    686           * response to this callback to maintain expected radio performance.
    687           */

   \                                 In section .text, align 2, keep-with-next
    688          void emberRadioNeedsCalibratingHandler(void)
    689          {
    690          }
   \                     emberRadioNeedsCalibratingHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    691          
    692          
    693          
    694          // Called when a connection is opened to serverPort.

   \                                 In section .text, align 2, keep-with-next
    695          void emberTcpAcceptHandler(uint16_t serverPort, uint8_t fd)
    696          {
    697          }
   \                     emberTcpAcceptHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    698          
    699          

   \                                 In section .text, align 2, keep-with-next
    700          void emberTcpReadHandler(uint8_t fd, uint8_t *buffer, uint16_t count)
    701          {
    702          }
   \                     emberTcpReadHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    703          
    704          

   \                                 In section .text, align 2, keep-with-next
    705          void emberTcpStatusHandler(uint8_t fd, uint8_t status)
    706          {
    707          }
   \                     emberTcpStatusHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    708          
    709          

   \                                 In section .text, align 2, keep-with-next
    710          void emberAddAddressDataReturn(uint16_t shortId)
    711          {
    712          }
   \                     emberAddAddressDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    713          
    714          

   \                                 In section .text, align 2, keep-with-next
    715          void emberAssertInfoReturn(const uint8_t *fileName, uint32_t lineNumber)
    716          {
    717          }
   \                     emberAssertInfoReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    718          
    719          

   \                                 In section .text, align 2, keep-with-next
    720          void emberClearAddressCacheReturn(void)
    721          {
    722          }
   \                     emberClearAddressCacheReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    723          
    724          

   \                                 In section .text, align 2, keep-with-next
    725          void emberConfigUartReturn(void)
    726          {
    727          }
   \                     emberConfigUartReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    728          
    729          

   \                                 In section .text, align 2, keep-with-next
    730          void emberEchoReturn(const uint8_t *data, uint8_t length)
    731          {
    732          }
   \                     emberEchoReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    733          
    734          

   \                                 In section .text, align 2, keep-with-next
    735          void emberGetMulticastEntryReturn(uint8_t lastSequence,
    736                                            uint8_t windowBitmask,
    737                                            uint8_t dwellQs,
    738                                            const uint8_t *seed)
    739          {
    740          }
   \                     emberGetMulticastEntryReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    741          
    742          

   \                                 In section .text, align 2, keep-with-next
    743          void emberGetNetworkKeyInfoReturn(EmberStatus status,
    744                                            uint32_t sequence,
    745                                            uint8_t state)
    746          {
    747          }
   \                     emberGetNetworkKeyInfoReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    748          
    749          

   \                                 In section .text, align 2, keep-with-next
    750          void emberGetNodeStatusReturn(EmberStatus status,
    751                                        uint8_t ripId,
    752                                        EmberNodeId nodeId,
    753                                        uint8_t parentRipId,
    754                                        EmberNodeId parentId,
    755                                        const uint8_t *networkFragmentIdentifier,
    756                                        uint32_t networkFrameCounter)
    757          {
    758          }
   \                     emberGetNodeStatusReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    759          
    760          

   \                                 In section .text, align 2, keep-with-next
    761          void emberLookupAddressDataReturn(uint16_t shortId)
    762          {
    763          }
   \                     emberLookupAddressDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    764          
    765          

   \                                 In section .text, align 2, keep-with-next
    766          void emberNcpUdpStormCompleteHandler(void)
    767          {
    768          }
   \                     emberNcpUdpStormCompleteHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    769          
    770          

   \                                 In section .text, align 2, keep-with-next
    771          void emberNcpUdpStormReturn(EmberStatus status)
    772          {
    773          }
   \                     emberNcpUdpStormReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    774          
    775          

   \                                 In section .text, align 2, keep-with-next
    776          void emberResetNcpAshReturn(void)
    777          {
    778          }
   \                     emberResetNcpAshReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    779          
    780          

   \                                 In section .text, align 2, keep-with-next
    781          void emberSendDoneReturn(void)
    782          {
    783          }
   \                     emberSendDoneReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    784          
    785          

   \                                 In section .text, align 2, keep-with-next
    786          void emberSetWakeupSequenceNumberReturn(void)
    787          {
    788          }
   \                     emberSetWakeupSequenceNumberReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    789          
    790          

   \                                 In section .text, align 2, keep-with-next
    791          void emberUartSpeedTestReturn(uint32_t totalBytesSent,
    792                                        uint32_t payloadBytesSent,
    793                                        uint32_t timeout)
    794          {
    795          }
   \                     emberUartSpeedTestReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    796          
    797          
    798          
    799          /** @brief Receive a multicast */

   \                                 In section .text, align 2, keep-with-next
    800          void emberUdpMulticastHandler(const uint8_t *destinationIpv6Address,
    801                                        const uint8_t *sourceIpv6Address,
    802                                        uint16_t localPort,
    803                                        uint16_t remotePort,
    804                                        uint8_t flags,
    805                                        const uint8_t *packet,
    806                                        uint16_t length)
    807          {
    808          }
   \                     emberUdpMulticastHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     ??repairActive

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x74 0x68          DC8 "thread-callback-stubs.c"
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x2D 0x63    
   \              0x61 0x6C    
   \              0x6C 0x62    
   \              0x61 0x63    
   \              0x6B 0x2D    
   \              0x73 0x74    
   \              0x75 0x62    
   \              0x73 0x2E    
   \              0x63 0x00    
    809          
    810          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   emberAddAddressDataReturn
       0   emberAfMainCallback
       0   emberAfMarkApplicationBuffersCallback
       0   emberAfPluginIdleSleepActiveCallback
       0   emberAfPluginIdleSleepOkToIdleCallback
       0   emberAfPluginIdleSleepOkToSleepCallback
       0   emberAfPluginIdleSleepWakeUpCallback
       0   emberAfTickCallback
       0   emberAssertInfoReturn
       0   emberBecomeCommissionerReturn
       0   emberChangeNodeTypeReturn
       0   emberClearAddressCacheReturn
       0   emberCommissionNetworkReturn
       0   emberCommissionerStatusHandler
       0   emberConfigUartReturn
       0   emberConfigureGatewayReturn
       0   emberCounterHandler
       0   emberCustomHostToNcpMessageHandler
       0   emberCustomNcpToHostMessageHandler
       0   emberDeepSleepCallback
       0   emberDeepSleepReturn
       0   emberEchoReturn
       0   emberEventDelayUpdatedFromIsrHandler
       0   emberExternalRouteChange
       0   emberFormNetworkReturn
       0   emberGetCcaThresholdReturn
       0   emberGetChannelCalDataTokenReturn
       0   emberGetCounterReturn
       0   emberGetDhcpClientReturn
       0   emberGetMulticastEntryReturn
       0   emberGetNetworkDataTlvReturn
       0   emberGetNetworkKeyInfoReturn
       0   emberGetNodeStatusReturn
       0   emberGetRadioPowerReturn
       0   emberGetRipEntryReturn
       0   emberGetRoutingLocatorReturn
       0   emberGetTxPowerModeReturn
       0   emberIpIncomingBeaconHandler
       0   emberLeaderDataHandler
       0   emberLookupAddressDataReturn
       0   emberMacPassthroughFilterHandler
       0   emberMacPassthroughMessageHandler
       0   emberNcpUdpStormCompleteHandler
       0   emberNcpUdpStormReturn
       0   emberOkToNapReturn
       0   emberPollForDataReturn
       0   emberPollHandler
       0   emberRadioNeedsCalibratingHandler
       0   emberResetMicroHandler
       0   emberResetNcpAshReturn
       0   emberResignGlobalAddressReturn
       0   emberSendDoneReturn
       0   emberSendSteeringDataReturn
       0   emberSetCcaThresholdReturn
       0   emberSetRadioPowerReturn
       0   emberSetSecurityParametersReturn
       0   emberSetTxPowerModeReturn
       0   emberSetWakeupSequenceNumberReturn
       0   emberStackPollForDataReturn
       0   emberStartHostJoinClientHandler
       0   emberStateReturn
       0   emberSwitchToNextNetworkKeyHandler
       0   emberSwitchToNextNetworkKeyReturn
       0   emberTcpAcceptHandler
       0   emberTcpReadHandler
       0   emberTcpStatusHandler
       0   emberUartSpeedTestReturn
       0   emberUdpMulticastHandler
       0   halButtonIsr
      16   halSimEepromCallback
         0   -> halInternalAssertFailed
        16   -> halInternalAssertFailed
        16   -> halInternalSimEeStartup
        16   -> halInternalSysReset
         0   -> halSimEepromErasePage
        16   -> halSimEepromErasePage


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      24  ?_0
       2  emberAddAddressDataReturn
       2  emberAfMainCallback
       2  emberAfMarkApplicationBuffersCallback
       2  emberAfPluginIdleSleepActiveCallback
       4  emberAfPluginIdleSleepOkToIdleCallback
       4  emberAfPluginIdleSleepOkToSleepCallback
       2  emberAfPluginIdleSleepWakeUpCallback
       2  emberAfTickCallback
       2  emberAssertInfoReturn
       2  emberBecomeCommissionerReturn
       2  emberChangeNodeTypeReturn
       2  emberClearAddressCacheReturn
       2  emberCommissionNetworkReturn
       2  emberCommissionerStatusHandler
       2  emberConfigUartReturn
       2  emberConfigureGatewayReturn
       2  emberCounterHandler
       2  emberCustomHostToNcpMessageHandler
       2  emberCustomNcpToHostMessageHandler
       2  emberDeepSleepCallback
       2  emberDeepSleepReturn
       2  emberEchoReturn
       2  emberEventDelayUpdatedFromIsrHandler
       2  emberExternalRouteChange
       2  emberFormNetworkReturn
       2  emberGetCcaThresholdReturn
       2  emberGetChannelCalDataTokenReturn
       2  emberGetCounterReturn
       2  emberGetDhcpClientReturn
       2  emberGetMulticastEntryReturn
       2  emberGetNetworkDataTlvReturn
       2  emberGetNetworkKeyInfoReturn
       2  emberGetNodeStatusReturn
       2  emberGetRadioPowerReturn
       2  emberGetRipEntryReturn
       2  emberGetRoutingLocatorReturn
       2  emberGetTxPowerModeReturn
       2  emberIpIncomingBeaconHandler
       2  emberLeaderDataHandler
       2  emberLookupAddressDataReturn
       4  emberMacPassthroughFilterHandler
       2  emberMacPassthroughMessageHandler
       2  emberNcpUdpStormCompleteHandler
       2  emberNcpUdpStormReturn
       2  emberOkToNapReturn
       2  emberPollForDataReturn
       2  emberPollHandler
       2  emberRadioNeedsCalibratingHandler
       2  emberResetMicroHandler
       2  emberResetNcpAshReturn
       2  emberResignGlobalAddressReturn
       2  emberSendDoneReturn
       2  emberSendSteeringDataReturn
       2  emberSetCcaThresholdReturn
       2  emberSetRadioPowerReturn
       2  emberSetSecurityParametersReturn
       2  emberSetTxPowerModeReturn
       2  emberSetWakeupSequenceNumberReturn
       2  emberStackPollForDataReturn
       2  emberStartHostJoinClientHandler
       2  emberStateReturn
       2  emberSwitchToNextNetworkKeyHandler
       2  emberSwitchToNextNetworkKeyReturn
       2  emberTcpAcceptHandler
       2  emberTcpReadHandler
       2  emberTcpStatusHandler
       2  emberUartSpeedTestReturn
       2  emberUdpMulticastHandler
       2  halButtonIsr
     130  halSimEepromCallback
       1  repairActive

 
   1 byte  in section .bss
 302 bytes in section .text
 
 302 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
