###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  14:43:26
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\command-interpreter2-util.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\command-interpreter2-util.c
#        -D APP_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D
#        PHY_EM3XX -D "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"command-interpreter2-util.c\"" -D BOARD_DEV0680ETM
#        -D "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\lst\command-interpreter2-util.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\obj\command-interpreter2-util.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\app\util\serial\command-interpreter2-util.c
      1          /**
      2           * File: command-interpreter2-util.c
      3           * Description: Common functionality for ASCII and Binary command interpreter2s
      4           *
      5           * Copyright 2013 by Silicon Laboratories. All rights reserved.             *80*
      6           */
      7          
      8          #include PLATFORM_HEADER
      9          
     10          #ifdef EZSP_HOST
     11            // Includes needed for ember related functions for the EZSP host
     12            #include "stack/include/error.h"
     13            #include "stack/include/ember-types.h"
     14            #include "app/util/ezsp/ezsp-protocol.h"
     15            #include "app/util/ezsp/ezsp.h"
     16            #include "app/util/ezsp/serial-interface.h"
     17            extern uint8_t emberEndpointCount;
     18          #else
     19            #include "stack/include/ember.h"
     20          #endif
     21          
     22          #include "hal/hal.h"
     23          #include "app/util/serial/serial.h"
     24          #include "app/util/serial/command-interpreter2.h"
     25          #include "app/util/serial/command-interpreter2-util.h"
     26          
     27          #if !defined APP_SERIAL
     28            extern uint8_t serialPort;
     29            #define APP_SERIAL serialPort
     30          #endif
     31          
     32          //------------------------------------------------------------------------------
     33          // Forward declarations.
     34          // static void callCommandAction(void);
     35          // static uint8_t charDowncase(uint8_t c);
     36          
     37          // Multiple interpreters.
     38          //
     39          // This is done so as to minimize the flash and RAM hit when only
     40          // using one interpreter.  Unix hosts always have space and often need
     41          // multiple interpreters.
     42          
     43          #if defined MULTIPLE_COMMAND_INTERPRETERS || defined UNIX_HOST || defined UNIX_HOST_SIM
     44          
     45          EmberCommandState emCommandState0;
     46          
     47          CurrentInterpreter emCurrentInterpreter =
     48            { &emCommandState0, emberCommandTable, emberCommandErrorHandler } ;
     49          
     50          bool emberRunCommandInterpreter(bool commandIsBinary,
     51                                             EmberCommandState *state,
     52                                             EmberCommandEntry *commandTable,
     53                                             EmberCommandErrorHandler *errorHandler,
     54                                             const uint8_t *input,
     55                                             uint16_t length)
     56          {
     57            // save the current state
     58            EmberCommandState *previousState = emCurrentInterpreter.state;
     59            EmberCommandEntry *previousCommandTable = emCurrentInterpreter.commandTable;
     60            EmberCommandErrorHandler *previousErrorHandler = emCurrentInterpreter.errorHandler;
     61          
     62            // push the state
     63            emCurrentInterpreter.state = state;
     64            emCurrentInterpreter.commandTable = commandTable;
     65            emCurrentInterpreter.errorHandler = errorHandler;
     66          
     67            bool result = (commandIsBinary
     68                              ? emberProcessBinaryCommand(input, length)
     69                              : emberProcessCommandString(input, length));
     70          
     71            // pop the state
     72            emCurrentInterpreter.state = previousState;
     73            emCurrentInterpreter.commandTable = previousCommandTable;
     74            emCurrentInterpreter.errorHandler = previousErrorHandler;
     75          
     76            return result;
     77          }
     78          
     79          void emberInitializeCommandState(EmberCommandState *state)
     80          {
     81            emCurrentInterpreter.state = state;
     82            emberCommandReaderInit();
     83            emCurrentInterpreter.state = &emCommandState0;
     84          }
     85          
     86          #ifdef RTOS
     87            #include "rtos/rtos.h"
     88            bool emberCommandInterpreterRtosInit(EmberCommandState *state,
     89                                                    EmberCommandEntry *commandTable,
     90                                                    EmberCommandErrorHandler *errorHandler)
     91            {
     92              if(rtosRegisterSharedGlobal((void**)&emCurrentInterpreter.state) != EMBER_SUCCESS) {
     93                return false;
     94              }
     95              if(rtosRegisterSharedGlobal((void**)&emCurrentInterpreter.commandTable) != EMBER_SUCCESS) {
     96                return false;
     97              }
     98              if(rtosRegisterSharedGlobal((void**)&emCurrentInterpreter.errorHandler) != EMBER_SUCCESS) {
     99                return false;
    100              }
    101              emberCommandInterpreterSetState(state, commandTable, errorHandler);
    102          
    103              return true;
    104            }
    105          
    106            void emberCommandInterpreterSetState(EmberCommandState *state,
    107                                                 EmberCommandEntry *commandTable,
    108                                                 EmberCommandErrorHandler *errorHandler)
    109            {
    110              emCurrentInterpreter.state = state;
    111              emCurrentInterpreter.commandTable = commandTable;
    112              emCurrentInterpreter.errorHandler = errorHandler;
    113            }
    114          #endif //RTOS
    115          
    116          #else
    117          

   \                                 In section .bss, align 4
    118          EmberCommandState emCommandState;
   \                     emCommandState:
   \   00000000                      DS8 132
    119          
    120          #endif
    121          
    122          //----------------------------------------------------------------
    123          // Initialize the state maachine.
    124          
    125          // Initialize the command interpreter.

   \                                 In section .text, align 2, keep-with-next
    126          void emCommandReaderInitStateVar(EmberCommandState *state)
    127          {
    128            state->state = CMD_AWAITING_ARGUMENT;
   \                     emCommandReaderInitStateVar: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    129            state->index = 0;
   \   00000004   0xF8A0 0x1076      STRH     R1,[R0, #+118]
    130            state->tokenIndices[0] = 0;
   \   00000008   0xF880 0x1065      STRB     R1,[R0, #+101]
    131            state->tokenCount = 0;
   \   0000000C   0xF880 0x1075      STRB     R1,[R0, #+117]
    132            state->error = EMBER_CMD_SUCCESS;
   \   00000010   0xF880 0x1078      STRB     R1,[R0, #+120]
    133            state->hexHighNibble = 0xFF;
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0xF880 0x1079      STRB     R1,[R0, #+121]
    134            state->argOffset = 0;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF880 0x107A      STRB     R1,[R0, #+122]
    135            state->currentCommand = NULL;
   \   00000020   0xF8C0 0x1080      STR      R1,[R0, #+128]
    136            state->defaultBase = 10;
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0xF880 0x107C      STRB     R1,[R0, #+124]
    137            state->previousCharacter = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF880 0x107B      STRB     R1,[R0, #+123]
    138          }
   \   00000030   0x4770             BX       LR               ;; return
    139          
    140          // Reinitialize for the next command line.

   \                                 In section .text, align 2, keep-with-next
    141          void emCommandReaderReinit(void)
    142          {
    143            emCommandState.state = CMD_AWAITING_ARGUMENT;
   \                     emCommandReaderReinit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    144            emCommandState.index = 0;
   \   00000006   0xF8A0 0x1076      STRH     R1,[R0, #+118]
    145            emCommandState.tokenIndices[0] = 0;
   \   0000000A   0xF880 0x1065      STRB     R1,[R0, #+101]
    146            emCommandState.tokenCount = 0;
   \   0000000E   0xF880 0x1075      STRB     R1,[R0, #+117]
    147            emCommandState.error = EMBER_CMD_SUCCESS;
   \   00000012   0xF880 0x1078      STRB     R1,[R0, #+120]
    148            emCommandState.hexHighNibble = 0xFF;
   \   00000016   0x21FF             MOVS     R1,#+255
   \   00000018   0xF880 0x1079      STRB     R1,[R0, #+121]
    149            emCommandState.argOffset = 0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x107A      STRB     R1,[R0, #+122]
    150            emCommandState.currentCommand = NULL;
   \   00000022   0xF8C0 0x1080      STR      R1,[R0, #+128]
    151            // Don't set previousCharacter; its value must be preserved from one
    152            // command to the next.
    153          }
   \   00000026   0x4770             BX       LR               ;; return
    154          

   \                                 In section .text, align 2, keep-with-next
    155          void emberCommandReaderInit(void)
    156          {
    157            emCommandState.defaultBase = 10;
   \                     emberCommandReaderInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11
   \   00000002   0x210A             MOVS     R1,#+10
   \   00000004   0xF880 0x107C      STRB     R1,[R0, #+124]
    158            emCommandState.previousCharacter = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF880 0x107B      STRB     R1,[R0, #+123]
    159            emCommandReaderReinit();
   \   0000000E   0x....             B.N      emCommandReaderReinit
    160          }
    161          
    162          // We provide a way of overriding the default base for numbers on the
    163          // command line for backwards compatibility.
    164          // This function is intentionally NOT documented in the .h file so it
    165          // isn't used anywhere it shouldn't be.

   \                                 In section .text, align 2, keep-with-next
    166          void emberCommandReaderSetDefaultBase(uint8_t base)
    167          {
    168            emCommandState.defaultBase = base;
   \                     emberCommandReaderSetDefaultBase: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11
   \   00000002   0xF881 0x007C      STRB     R0,[R1, #+124]
    169          }
   \   00000006   0x4770             BX       LR               ;; return
    170          
    171          //----------------------------------------------------------------
    172          // Retrieving arguments
    173          

   \                                 In section .text, align 2, keep-with-next
    174          uint8_t emberCommandArgumentCount(void)
    175          {
    176            return (emCommandState.tokenCount - emCommandState.argOffset);
   \                     emberCommandArgumentCount: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11
   \   00000002   0xF890 0x1075      LDRB     R1,[R0, #+117]
   \   00000006   0xF890 0x007A      LDRB     R0,[R0, #+122]
   \   0000000A   0x....             B.N      ?Subroutine0
    177          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x1A08             SUBS     R0,R1,R0
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    178          

   \                                 In section .text, align 2, keep-with-next
    179          uint8_t *emTokenPointer(int8_t tokenNum)
    180          {
    181            return emCommandState.buffer + emCommandState.tokenIndices[tokenNum];
   \                     emTokenPointer: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11
   \   00000002   0x1840             ADDS     R0,R0,R1
   \   00000004   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   00000008   0x1840             ADDS     R0,R0,R1
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \   0000000C   0x4770             BX       LR               ;; return
    182          }
    183          

   \                                 In section .text, align 2, keep-with-next
    184          uint8_t emTokenLength(uint8_t num)
    185          {
    186            return (emCommandState.tokenIndices[num + 1]
    187                    - emCommandState.tokenIndices[num]);
   \                     emTokenLength: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable11
   \   00000002   0x1840             ADDS     R0,R0,R1
   \   00000004   0xF890 0x1066      LDRB     R1,[R0, #+102]
   \   00000008   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   0000000C                      REQUIRE ?Subroutine0
   \   0000000C                      ;; // Fall through to label ?Subroutine0
    188          }
    189          

   \                                 In section .text, align 2, keep-with-next
    190          uint8_t emFirstByteOfArg(uint8_t argNum)
    191          {
   \                     emFirstByteOfArg: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    192            return *(emTokenPointer(argNum + emCommandState.argOffset));
   \   00000002   0x....             LDR.N    R1,??DataTable11
   \   00000004   0xF991 0x107A      LDRSB    R1,[R1, #+122]
   \   00000008   0x1808             ADDS     R0,R1,R0
   \   0000000A   0xB240             SXTB     R0,R0
   \   0000000C   0x.... 0x....      BL       emTokenPointer
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    193          }
    194          

   \                                 In section .text, align 2, keep-with-next
    195          uint32_t emStringToUnsignedInt(uint8_t argNum, bool swallowLeadingSign)
    196          {
   \                     emStringToUnsignedInt: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    197            uint8_t tokenNum = argNum + emCommandState.argOffset;
   \   00000004   0x.... 0x....      LDR.W    R9,??DataTable11
   \   00000008   0xF109 0x0678      ADD      R6,R9,#+120
   \   0000000C   0x4605             MOV      R5,R0
   \   0000000E   0x78B0             LDRB     R0,[R6, #+2]
   \   00000010   0x1947             ADDS     R7,R0,R5
   \   00000012   0x4688             MOV      R8,R1
    198            uint8_t *string = emTokenPointer(tokenNum);
   \   00000014   0xB278             SXTB     R0,R7
   \   00000016   0x.... 0x....      BL       emTokenPointer
   \   0000001A   0x4682             MOV      R10,R0
    199            uint8_t length = emTokenLength(tokenNum);
   \   0000001C   0xB2F8             UXTB     R0,R7
   \   0000001E   0x.... 0x....      BL       emTokenLength
    200            uint32_t result = 0;
    201            uint8_t base = emCommandState.defaultBase;
   \   00000022   0x7936             LDRB     R6,[R6, #+4]
   \   00000024   0x4607             MOV      R7,R0
   \   00000026   0x2400             MOVS     R4,#+0
    202            uint8_t i;
    203            assert(argNum < emberCommandArgumentCount());
   \   00000028   0x.... 0x....      BL       emberCommandArgumentCount
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD302             BCC.N    ??CrossCallReturnLabel_3
   \   00000030   0x21CB             MOVS     R1,#+203
   \   00000032   0x.... 0x....      BL       ?Subroutine1
    204            for (i = 0; i < length; i++) {
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000036   0x2500             MOVS     R5,#+0
   \   00000038   0xE007             B.N      ??emStringToUnsignedInt_0
    205              uint8_t next = string[i];
    206              if (swallowLeadingSign && i == 0 && next == '-') {
    207                // do nothing
    208              } else if ((next == 'x' || next == 'X')
    209                         && result == 0
    210                         && (i == 1 || i == 2)) {
   \                     ??emStringToUnsignedInt_1: (+1)
   \   0000003A   0xB9AC             CBNZ.N   R4,??emStringToUnsignedInt_2
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x2D02             CMPNE    R5,#+2
   \   00000042   0xD111             BNE.N    ??emStringToUnsignedInt_2
    211                base = 16;
   \   00000044   0x2610             MOVS     R6,#+16
    212              } else {
   \                     ??emStringToUnsignedInt_3: (+1)
   \   00000046   0x1C68             ADDS     R0,R5,#+1
   \   00000048   0xB2C5             UXTB     R5,R0
   \                     ??emStringToUnsignedInt_0: (+1)
   \   0000004A   0x42BD             CMP      R5,R7
   \   0000004C   0xDA18             BGE.N    ??emStringToUnsignedInt_4
   \   0000004E   0xF815 0x000A      LDRB     R0,[R5, R10]
   \   00000052   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000056   0xD003             BEQ.N    ??emStringToUnsignedInt_5
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xBF08             IT       EQ 
   \   0000005C   0x282D             CMPEQ    R0,#+45
   \   0000005E   0xD0F2             BEQ.N    ??emStringToUnsignedInt_3
   \                     ??emStringToUnsignedInt_5: (+1)
   \   00000060   0x2878             CMP      R0,#+120
   \   00000062   0xBF18             IT       NE 
   \   00000064   0x2858             CMPNE    R0,#+88
   \   00000066   0xD0E8             BEQ.N    ??emStringToUnsignedInt_1
    213                uint8_t value = emberHexToInt(next);
   \                     ??emStringToUnsignedInt_2: (+1)
   \   00000068   0x.... 0x....      BL       emberHexToInt
    214                if (value < base) {
   \   0000006C   0x42B0             CMP      R0,R6
   \   0000006E   0xBFB8             IT       LT 
   \   00000070   0xFB06 0x0404      MLALT    R4,R6,R4,R0
    215                  result = result * base + value;
   \   00000074   0xDBE7             BLT.N    ??emStringToUnsignedInt_3
    216                } else {
    217                  emCommandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
   \   00000076   0x2005             MOVS     R0,#+5
   \   00000078   0xF889 0x0078      STRB     R0,[R9, #+120]
    218                  return 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE000             B.N      ??emStringToUnsignedInt_6
    219                }
    220              }
    221            }
    222            return result;
   \                     ??emStringToUnsignedInt_4: (+1)
   \   00000080   0x4620             MOV      R0,R4
   \                     ??emStringToUnsignedInt_6: (+1)
   \   00000082   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    223          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,?_0
   \   00000004   0x.... 0x....      B.W      halInternalAssertFailed
    224          
    225          #define isBinary() (emCommandState.defaultBase == 0xFF)
    226          
    227          static uint32_t getBinaryUnsignedCommandArgument(uint8_t argNum)
    228          {
    229            uint8_t size = emTokenLength(argNum);
    230            uint8_t *place = emTokenPointer(argNum);
    231          
    232            if (size == 1) {
    233              return *place;
    234            } else if (size == 2) {
    235              return emberFetchHighLowInt16u(place);
    236            } else if (size == 4) {
    237              return emberFetchHighLowInt32u(place);
    238            } else {
    239              assert(false);
    240          #ifndef EMBER_STACK_COBRA
    241              return 0;
    242          #else
    243          #pragma diag_remark=Pe111
    244              return 0;
    245          #pragma diag_warning=Pe111
    246          #endif
    247            }
    248          }
    249          
    250          static int32_t getBinarySignedCommandArgument(uint8_t argNum)
    251          {
    252            uint8_t size = emTokenLength(argNum);
    253            uint8_t *place = emTokenPointer(argNum);
    254            int8_t result = *place;
    255          
    256            if (size == 1) {
    257              // first cast the unsigned to signed, then return
    258              return result;
    259            } else if (size == 2) {
    260              // first cast the unsigned to signed, then return
    261              int16_t result = emberFetchHighLowInt16u(place);
    262              return result;
    263            } else if (size == 4) {
    264              return emberFetchHighLowInt32u(place);
    265            } else {
    266              assert(false);
    267          #ifndef EMBER_STACK_COBRA
    268              return result;
    269          #else
    270          #pragma diag_remark=Pe111
    271              return result;
    272          #pragma diag_warning=Pe111
    273          #endif
    274            }
    275          }
    276          
    277          static uint8_t *getBinaryStringCommandArgument(int8_t argNum, uint8_t *length)
    278          {
    279            if (length != NULL) {
    280              *length = emTokenLength(argNum) - 1;
    281            }
    282          
    283            // the length is stored in the first byte, skip it
    284            return emTokenPointer(argNum) + 1;
    285          }
    286          

   \                                 In section .text, align 2, keep-with-next
    287          uint32_t emberUnsignedCommandArgument(uint8_t argNum)
    288          {
   \                     emberUnsignedCommandArgument: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    289            if (isBinary()) {
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000006   0xD11D             BNE.N    ??emberUnsignedCommandArgument_0
    290              return getBinaryUnsignedCommandArgument(argNum);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       emTokenLength
   \   0000000E   0x4605             MOV      R5,R0
   \   00000010   0xB260             SXTB     R0,R4
   \   00000012   0x.... 0x....      BL       emTokenPointer
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD101             BNE.N    ??emberUnsignedCommandArgument_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??emberUnsignedCommandArgument_1: (+1)
   \   0000001E   0x2D02             CMP      R5,#+2
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0xE8BD 0x4032      POPEQ    {R1,R4,R5,LR}
   \   00000026   0x.... 0x....      BEQ.W    emberFetchHighLowInt16u
   \   0000002A   0x2D04             CMP      R5,#+4
   \   0000002C   0xD105             BNE.N    ??emberUnsignedCommandArgument_2
   \   0000002E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000032   0x4601             MOV      R1,R0
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      B.W      emFetchInt32u
   \                     ??emberUnsignedCommandArgument_2: (+1)
   \   0000003A   0x21EF             MOVS     R1,#+239
   \   0000003C   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
    291            } else {
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}
    292              return emStringToUnsignedInt(argNum, false);
   \                     ??emberUnsignedCommandArgument_0: (+1)
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x....             B.N      emStringToUnsignedInt
    293            }
    294          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x....             LDR.N    R0,??DataTable11
   \   00000004   0xF890 0x007C      LDRB     R0,[R0, #+124]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0x4770             BX       LR
    295          

   \                                 In section .text, align 2, keep-with-next
    296          int32_t emberSignedCommandArgument(uint8_t argNum)
    297          {
   \                     emberSignedCommandArgument: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    298            if (isBinary()) {
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0xD11D             BNE.N    ??emberSignedCommandArgument_0
    299              return getBinarySignedCommandArgument(argNum);
   \   0000000A   0x.... 0x....      BL       emTokenLength
   \   0000000E   0x4605             MOV      R5,R0
   \   00000010   0xB260             SXTB     R0,R4
   \   00000012   0x.... 0x....      BL       emTokenPointer
   \   00000016   0xF990 0x4000      LDRSB    R4,[R0, #+0]
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD011             BEQ.N    ??CrossCallReturnLabel_1
   \   0000001E   0x2D02             CMP      R5,#+2
   \   00000020   0xD103             BNE.N    ??emberSignedCommandArgument_1
   \   00000022   0x.... 0x....      BL       emberFetchHighLowInt16u
   \   00000026   0xB204             SXTH     R4,R0
   \   00000028   0xE00B             B.N      ??CrossCallReturnLabel_1
   \                     ??emberSignedCommandArgument_1: (+1)
   \   0000002A   0x2D04             CMP      R5,#+4
   \   0000002C   0xD105             BNE.N    ??emberSignedCommandArgument_2
   \   0000002E   0x4601             MOV      R1,R0
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       emFetchInt32u
   \   00000036   0x4604             MOV      R4,R0
   \   00000038   0xE003             B.N      ??CrossCallReturnLabel_1
   \                     ??emberSignedCommandArgument_2: (+1)
   \   0000003A   0xF44F 0x7185      MOV      R1,#+266
   \   0000003E   0x.... 0x....      BL       ?Subroutine1
    300            } else {
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
    301              bool negative = (emFirstByteOfArg(argNum) == '-');
   \                     ??emberSignedCommandArgument_0: (+1)
   \   00000046   0x.... 0x....      BL       emFirstByteOfArg
   \   0000004A   0x282D             CMP      R0,#+45
   \   0000004C   0xBF0C             ITE      EQ 
   \   0000004E   0x2501             MOVEQ    R5,#+1
   \   00000050   0x2500             MOVNE    R5,#+0
    302              int32_t result = (int32_t) emStringToUnsignedInt(argNum, negative);
   \   00000052   0x4629             MOV      R1,R5
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       emStringToUnsignedInt
    303              return (negative ? -result : result);
   \   0000005A   0xB105             CBZ.N    R5,??emberSignedCommandArgument_3
   \   0000005C   0x4240             RSBS     R0,R0,#+0
   \                     ??emberSignedCommandArgument_3: (+1)
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    304            }
    305          }
    306          

   \                                 In section .text, align 2, keep-with-next
    307          uint8_t *emberStringCommandArgument(int8_t argNum, uint8_t *length)
    308          {
   \                     emberStringCommandArgument: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
    309            if (isBinary()) {
   \   00000006   0x....             LDR.N    R0,??DataTable11
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0xF890 0x107C      LDRB     R1,[R0, #+124]
   \   0000000E   0x29FF             CMP      R1,#+255
   \   00000010   0xD10A             BNE.N    ??emberStringCommandArgument_0
    310              return getBinaryStringCommandArgument(argNum, length);
   \   00000012   0xB124             CBZ.N    R4,??emberStringCommandArgument_1
   \   00000014   0xB2E8             UXTB     R0,R5
   \   00000016   0x.... 0x....      BL       emTokenLength
   \   0000001A   0x1E40             SUBS     R0,R0,#+1
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
   \                     ??emberStringCommandArgument_1: (+1)
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       emTokenPointer
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0xE017             B.N      ??emberStringCommandArgument_2
    311            } else {
    312              uint8_t tokenNum = argNum + emCommandState.argOffset;
   \                     ??emberStringCommandArgument_0: (+1)
   \   00000028   0xF890 0x007A      LDRB     R0,[R0, #+122]
   \   0000002C   0x1946             ADDS     R6,R0,R5
    313              uint8_t leadingQuote = (argNum < 0 ? 0 : 1);
   \   0000002E   0x43ED             MVNS     R5,R5
    314              uint8_t *string = emTokenPointer(tokenNum);
   \   00000030   0xB270             SXTB     R0,R6
   \   00000032   0x.... 0x....      BL       emTokenPointer
   \   00000036   0x4680             MOV      R8,R0
    315              uint8_t trailingNull = (string[0] == '"' ? 1 : 0);
   \   00000038   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000003C   0x2822             CMP      R0,#+34
   \   0000003E   0xBF0C             ITE      EQ 
   \   00000040   0x2701             MOVEQ    R7,#+1
   \   00000042   0x2700             MOVNE    R7,#+0
    316              if (length != NULL) {
   \   00000044   0xB134             CBZ.N    R4,??emberStringCommandArgument_3
    317                *length = emTokenLength(tokenNum) - leadingQuote - trailingNull;
   \   00000046   0xB2F0             UXTB     R0,R6
   \   00000048   0x.... 0x....      BL       emTokenLength
   \   0000004C   0xEBA0 0x70D5      SUB      R0,R0,R5, LSR #+31
   \   00000050   0x1BC0             SUBS     R0,R0,R7
   \   00000052   0x7020             STRB     R0,[R4, #+0]
    318              }
    319              return string + leadingQuote;
   \                     ??emberStringCommandArgument_3: (+1)
   \   00000054   0xEB08 0x70D5      ADD      R0,R8,R5, LSR #+31
   \                     ??emberStringCommandArgument_2: (+1)
   \   00000058   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    320            }
    321          }
    322          

   \                                 In section .text, align 2, keep-with-next
    323          const char *emberCommandName(void)
    324          {
    325            return emCommandState.currentCommand->name;
   \                     emberCommandName: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11
   \   00000002   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4770             BX       LR               ;; return
    326          }
    327          

   \                                 In section .text, align 2, keep-with-next
    328          uint8_t emberGetStringArgument(int8_t argNum,
    329                                       uint8_t *destination,
    330                                       uint8_t maxLength,
    331                                       bool leftPad)
    332          {
   \                     emberGetStringArgument: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    333            uint8_t padLength;
    334            uint8_t argLength;
    335            uint8_t *contents = emberStringCommandArgument(argNum, &argLength);
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x.... 0x....      BL       emberStringCommandArgument
   \   00000014   0x4680             MOV      R8,R0
    336            uint8_t trailingNull = (emFirstByteOfArg(argNum) == '"' ? 1 : 0);
   \   00000016   0xB2E8             UXTB     R0,R5
   \   00000018   0x.... 0x....      BL       emFirstByteOfArg
   \   0000001C   0x2822             CMP      R0,#+34
    337            // The argLength does not include the trailing null, but we want
    338            // to copy the null as well so we increment it within this function.
    339            argLength += trailingNull;
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0xBF0C             ITE      EQ 
   \   00000024   0x2501             MOVEQ    R5,#+1
   \   00000026   0x2500             MOVNE    R5,#+0
   \   00000028   0x1828             ADDS     R0,R5,R0
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    340          
    341            if (argLength > maxLength) {
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000032   0x4286             CMP      R6,R0
   \   00000034   0xBF98             IT       LS 
   \   00000036   0x4630             MOVLS    R0,R6
   \   00000038   0xF88D 0x0000      STRB     R0,[SP, #+0]
    342              argLength = maxLength;
    343            }
    344          
    345            padLength = leftPad ? maxLength - argLength : 0;
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xBF1A             ITTE     NE 
   \   00000040   0xF89D 0x0000      LDRBNE   R0,[SP, #+0]
   \   00000044   0x1A36             SUBNE    R6,R6,R0
   \   00000046   0x2600             MOVEQ    R6,#+0
    346            MEMSET(destination, 0, padLength);
   \   00000048   0xB2F6             UXTB     R6,R6
   \   0000004A   0x4632             MOV      R2,R6
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       halCommonMemSet
    347            MEMMOVE(destination + padLength, contents, argLength);
   \   00000054   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000058   0x4641             MOV      R1,R8
   \   0000005A   0x1930             ADDS     R0,R6,R4
   \   0000005C   0x.... 0x....      BL       halCommonMemMove
    348            return argLength -= trailingNull;
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0x1B40             SUBS     R0,R0,R5
   \   00000066   0xB2C0             UXTB     R0,R0
   \   00000068   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    349          }
    350          

   \                                 In section .text, align 2, keep-with-next
    351          void emberGetExtendedPanIdArgument(int8_t index, uint8_t *extendedPanId)
    352          {
   \                     emberGetExtendedPanIdArgument: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    353            uint8_t bigEndianExtendedPanId[EXTENDED_PAN_ID_SIZE];
    354            emberGetStringArgument(index, bigEndianExtendedPanId, EXTENDED_PAN_ID_SIZE, true);
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x2208             MOVS     R2,#+8
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x.... 0x....      BL       emberGetStringArgument
    355            emberReverseMemCopy(extendedPanId, bigEndianExtendedPanId, EXTENDED_PAN_ID_SIZE);
   \   0000000E   0x2208             MOVS     R2,#+8
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       emberReverseMemCopy
    356          }
   \   00000018   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    357          
    358          enum {
    359            EXPECTING_WORD,
    360            EXPECTING_PADDING,
    361            EXPECTING_DELIMITER
    362          };
    363          

   \                                 In section .text, align 2, keep-with-next
    364          static bool stringToIp(const uint8_t *string,
    365                                    uint8_t stringLength,
    366                                    uint8_t *target,
    367                                    bool address)
    368          {
   \                     stringToIp: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
    369            uint8_t i;
    370            uint8_t padIndex;
    371            uint8_t index = 0;
    372            bool padded = false;
    373            uint16_t word = 0;
    374            uint8_t wordChars = 0;
    375            uint8_t state = (string[0] == ':' ? EXPECTING_PADDING : EXPECTING_WORD);
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x283A             CMP      R0,#+58
   \   0000000C   0xBF0C             ITE      EQ 
   \   0000000E   0x2601             MOVEQ    R6,#+1
   \   00000010   0x2600             MOVNE    R6,#+0
    376            uint8_t ipLength = (address ? 16 : 8);
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xBF14             ITE      NE 
   \   00000016   0x2510             MOVNE    R5,#+16
   \   00000018   0x2508             MOVEQ    R5,#+8
   \   0000001A   0x46A1             MOV      R9,R4
   \   0000001C   0x46A2             MOV      R10,R4
   \   0000001E   0x46A0             MOV      R8,R4
    377          
    378            for (i = 0; i < stringLength; i++) {
   \   00000020   0x2700             MOVS     R7,#+0
   \   00000022   0xE01A             B.N      ??stringToIp_0
    379              uint8_t ch = string[i];
    380              bool isColon = (ch == ':');
    381              uint8_t value = emberHexToInt(ch);
    382              bool isLast = (i + 1 == stringLength);
    383              bool nextIsColon = (string[i+1] == ':');
    384              //fprintf(stderr,
    385              //        "i:%d state:%d ch:%c colon:%d nextIsColon:%d value:%d index:%d\n",
    386              //        i, state, ch, isColon, nextIsColon, value, index);
    387              if ((! isColon && value > 15)
    388                  || index == ipLength) {
    389                return false;
    390              }
    391          
    392              switch (state) {
    393          
    394              case EXPECTING_WORD:
    395                if (isColon) {
    396                  return false;
    397                } else {
    398                  if (wordChars == 4) {
    399                    return false;
    400                  }
    401                  word <<= 4;
    402                  word += value;
    403                  wordChars += 1;
    404                }
    405                if (isLast || nextIsColon) {
    406                  emberStoreHighLowInt16u(target + index, word);
    407                  index += 2;
    408                  state = EXPECTING_DELIMITER;
    409                }
    410                break;
    411          
    412              case EXPECTING_PADDING:
    413              case EXPECTING_DELIMITER: {
    414                if (! isColon
    415                    || isLast   // Trailing colon not allowed.
    416                    || (padded && nextIsColon)  // Only one padding allowed.
    417                    || (state == EXPECTING_PADDING && ! nextIsColon)) {
   \                     ??stringToIp_1: (+1)
   \   00000024   0xF082 0x0001      EOR      R0,R2,#0x1
   \   00000028   0xEA01 0x0209      AND      R2,R1,R9
   \   0000002C   0xEA00 0x000B      AND      R0,R0,R11
   \   00000030   0xF082 0x0201      EOR      R2,R2,#0x1
   \   00000034   0x4210             TST      R0,R2
   \   00000036   0xD06C             BEQ.N    ??stringToIp_2
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xBF08             IT       EQ 
   \   0000003C   0x2900             CMPEQ    R1,#+0
   \   0000003E   0xD068             BEQ.N    ??stringToIp_2
    418                  return false;
    419                } else if (nextIsColon) {
   \   00000040   0xB129             CBZ.N    R1,??stringToIp_3
    420                  i += 1;
   \   00000042   0x1C78             ADDS     R0,R7,#+1
   \   00000044   0xB2C7             UXTB     R7,R0
    421                  padded = true;
   \   00000046   0xF04F 0x0901      MOV      R9,#+1
    422                  padIndex = index;
   \   0000004A   0xF88D 0x4000      STRB     R4,[SP, #+0]
    423                }
    424                word = 0;
   \                     ??stringToIp_3: (+1)
   \   0000004E   0xF04F 0x0A00      MOV      R10,#+0
    425                wordChars = 0;
   \   00000052   0x46D0             MOV      R8,R10
    426                state = EXPECTING_WORD;
   \   00000054   0x2600             MOVS     R6,#+0
    427                break;
    428              }}
   \                     ??stringToIp_4: (+1)
   \   00000056   0x1C78             ADDS     R0,R7,#+1
   \   00000058   0xB2C7             UXTB     R7,R0
   \                     ??stringToIp_0: (+1)
   \   0000005A   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000005E   0x4287             CMP      R7,R0
   \   00000060   0xDA3C             BGE.N    ??stringToIp_5
   \   00000062   0x9802             LDR      R0,[SP, #+8]
   \   00000064   0x5C38             LDRB     R0,[R7, R0]
   \   00000066   0x283A             CMP      R0,#+58
   \   00000068   0xBF0C             ITE      EQ 
   \   0000006A   0xF04F 0x0B01      MOVEQ    R11,#+1
   \   0000006E   0xF04F 0x0B00      MOVNE    R11,#+0
   \   00000072   0x.... 0x....      BL       emberHexToInt
   \   00000076   0xF89D 0x200C      LDRB     R2,[SP, #+12]
   \   0000007A   0x1C79             ADDS     R1,R7,#+1
   \   0000007C   0x4291             CMP      R1,R2
   \   0000007E   0x9902             LDR      R1,[SP, #+8]
   \   00000080   0xBF0C             ITE      EQ 
   \   00000082   0x2201             MOVEQ    R2,#+1
   \   00000084   0x2200             MOVNE    R2,#+0
   \   00000086   0x1879             ADDS     R1,R7,R1
   \   00000088   0x7849             LDRB     R1,[R1, #+1]
   \   0000008A   0x293A             CMP      R1,#+58
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0x2101             MOVEQ    R1,#+1
   \   00000090   0x2100             MOVNE    R1,#+0
   \   00000092   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000096   0xD101             BNE.N    ??stringToIp_6
   \   00000098   0x2810             CMP      R0,#+16
   \   0000009A   0xDA3A             BGE.N    ??stringToIp_2
   \                     ??stringToIp_6: (+1)
   \   0000009C   0x42AC             CMP      R4,R5
   \   0000009E   0xD038             BEQ.N    ??stringToIp_2
   \   000000A0   0xB11E             CBZ.N    R6,??stringToIp_7
   \   000000A2   0x2E02             CMP      R6,#+2
   \   000000A4   0xD0BE             BEQ.N    ??stringToIp_1
   \   000000A6   0xD3BD             BCC.N    ??stringToIp_1
   \   000000A8   0xE7D5             B.N      ??stringToIp_4
   \                     ??stringToIp_7: (+1)
   \   000000AA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000AE   0xD130             BNE.N    ??stringToIp_2
   \   000000B0   0xF1B8 0x0F04      CMP      R8,#+4
   \   000000B4   0xD02D             BEQ.N    ??stringToIp_2
   \   000000B6   0xEB00 0x1A0A      ADD      R10,R0,R10, LSL #+4
   \   000000BA   0xF108 0x0001      ADD      R0,R8,#+1
   \   000000BE   0xFA5F 0xF880      UXTB     R8,R0
   \   000000C2   0xEA51 0x0002      ORRS     R0,R1,R2
   \   000000C6   0xD0C6             BEQ.N    ??stringToIp_4
   \   000000C8   0x9804             LDR      R0,[SP, #+16]
   \   000000CA   0xFA1F 0xF18A      UXTH     R1,R10
   \   000000CE   0x1820             ADDS     R0,R4,R0
   \   000000D0   0x.... 0x....      BL       emberStoreHighLowInt16u
   \   000000D4   0x1CA4             ADDS     R4,R4,#+2
   \   000000D6   0xB2E4             UXTB     R4,R4
   \   000000D8   0x2602             MOVS     R6,#+2
   \   000000DA   0xE7BC             B.N      ??stringToIp_4
    429            }
    430            if (padded) {
   \                     ??stringToIp_5: (+1)
   \   000000DC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000E0   0xD015             BEQ.N    ??stringToIp_8
    431              uint8_t padBytes = ipLength - index;
   \   000000E2   0x1B2D             SUBS     R5,R5,R4
   \   000000E4   0xB2ED             UXTB     R5,R5
    432              uint8_t suffixLength = index - padIndex;
    433              if (padBytes == 0) {
   \   000000E6   0xB1A5             CBZ.N    R5,??stringToIp_2
    434                return false;  // Nothing to pad.
    435              }
    436              MEMMOVE(target + padIndex + padBytes,
    437                      target + padIndex,
    438                      suffixLength);
   \   000000E8   0x9804             LDR      R0,[SP, #+16]
   \   000000EA   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000EE   0x180E             ADDS     R6,R1,R0
   \   000000F0   0x1A62             SUBS     R2,R4,R1
   \   000000F2   0xB2D2             UXTB     R2,R2
   \   000000F4   0x4631             MOV      R1,R6
   \   000000F6   0x19A8             ADDS     R0,R5,R6
   \   000000F8   0x.... 0x....      BL       halCommonMemMove
    439              MEMSET(target + padIndex, 0, padBytes);
   \   000000FC   0x462A             MOV      R2,R5
   \   000000FE   0x2100             MOVS     R1,#+0
   \   00000100   0x4630             MOV      R0,R6
   \   00000102   0x.... 0x....      BL       halCommonMemSet
    440            } else if (index != ipLength) {
    441              return false;
    442            }
    443            return true;
   \                     ??stringToIp_9: (+1)
   \   00000106   0x2001             MOVS     R0,#+1
   \                     ??stringToIp_10: (+1)
   \   00000108   0xB005             ADD      SP,SP,#+20
   \   0000010A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??stringToIp_8: (+1)
   \   0000010E   0x42AC             CMP      R4,R5
   \   00000110   0xD0F9             BEQ.N    ??stringToIp_9
   \                     ??stringToIp_2: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xE7F8             B.N      ??stringToIp_10
    444          }
    445          

   \                                 In section .text, align 2, keep-with-next
    446          bool emberStringToIpAddress(const uint8_t *string,
    447                                         uint8_t stringLength,
    448                                         uint8_t *target)
    449          {
    450            return stringToIp(string, stringLength, target, true); // address
   \                     emberStringToIpAddress: (+1)
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x....             B.N      stringToIp
    451          }
    452          

   \                                 In section .text, align 2, keep-with-next
    453          bool emberStringToIpPrefix(const uint8_t *string,
    454                                        uint8_t stringLength,
    455                                        uint8_t *target)
    456          {
    457            return stringToIp(string, stringLength, target, false); // prefix
   \                     emberStringToIpPrefix: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x....             B.N      stringToIp
    458          }
    459          

   \                                 In section .text, align 2, keep-with-next
    460          static bool getIpArgument(uint8_t index, uint8_t *target, bool address)
    461          {
   \                     getIpArgument: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    462            uint8_t destLength;
    463            const uint8_t *destText = emberStringCommandArgument(index, &destLength);
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0x.... 0x....      BL       emberStringCommandArgument
    464          
    465            if (!stringToIp(destText, destLength, target, address)) {
   \   0000000E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000012   0x462B             MOV      R3,R5
   \   00000014   0x4622             MOV      R2,R4
   \   00000016   0x.... 0x....      BL       stringToIp
   \   0000001A   0xB930             CBNZ.N   R0,??getIpArgument_0
    466              emberSerialPrintfLine(APP_SERIAL, "Bad IP format");
   \   0000001C   0x.... 0x....      ADR.W    R1,?_1
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       emberSerialPrintfLine
    467              return false;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
    468            }
    469          
    470            return true;
   \                     ??getIpArgument_0: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    471          }
    472          

   \                                 In section .text, align 2, keep-with-next
    473          bool emberGetIpArgument(uint8_t index, uint8_t *target)
    474          {
    475            return getIpArgument(index, target, true); // address
   \                     emberGetIpArgument: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x....             B.N      getIpArgument
    476          }
    477          

   \                                 In section .text, align 2, keep-with-next
    478          bool emberGetIpPrefixArgument(uint8_t index, uint8_t *target)
    479          {
    480            return getIpArgument(index, target, false); // prefix
   \                     emberGetIpPrefixArgument: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x....             B.N      getIpArgument
    481          }
    482          
    483          //----------------------------------------------------------------
    484          // Command lookup and processing
    485          
    486          // Returs true if entry is a nested command, and in this case
    487          // it populates the nestedCommand pointer.
    488          // Otherwise it returns false, and does nothing with nestedCommand
    489          //
    490          // Nested commands are implemented by setting the action
    491          // field to NULL

   \                                 In section .text, align 2, keep-with-next
    492          bool emberGetNestedCommand(const EmberCommandEntry *entry,
    493                                        const EmberCommandEntry ** nestedCommand)
    494          {
   \                     emberGetNestedCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    495            if ( entry -> action == NULL ) {
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0xB910             CBNZ.N   R0,??emberGetNestedCommand_0
    496              *nestedCommand = (const EmberCommandEntry*)entry->argumentTypes;
   \   00000008   0x600A             STR      R2,[R1, #+0]
    497              return true;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD02             POP      {R1,PC}
    498            } else {
    499              // setting argumentTypes to 'n' is a deprecated way of declaring nested
    500              // commands, and any instances of it must be updated to support the new
    501              // method
    502              assert(entry->argumentTypes[0] != 'n');
   \                     ??emberGetNestedCommand_0: (+1)
   \   0000000E   0x7810             LDRB     R0,[R2, #+0]
   \   00000010   0x286E             CMP      R0,#+110
   \   00000012   0xD103             BNE.N    ??CrossCallReturnLabel_0
   \   00000014   0xF44F 0x71FB      MOV      R1,#+502
   \   00000018   0x.... 0x....      BL       ?Subroutine1
    503          
    504              // anything else means it's not a nested command
    505              return false;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    506            }
    507          }
    508          

   \                                 In section .text, align 2, keep-with-next
    509          uint8_t emberHexToInt(uint8_t ch)
    510          {
    511            return ch - (ch >= 'a'
    512                         ? 'a' - 10
    513                         : (ch >= 'A'
    514                            ? 'A' - 10
    515                            : (ch <= '9'
    516                               ? '0'
    517                               : 0)));
   \                     emberHexToInt: (+1)
   \   00000000   0x2861             CMP      R0,#+97
   \   00000002   0xBFA8             IT       GE 
   \   00000004   0x2157             MOVGE    R1,#+87
   \   00000006   0xDA07             BGE.N    ??emberHexToInt_0
   \   00000008   0x2841             CMP      R0,#+65
   \   0000000A   0xBFA8             IT       GE 
   \   0000000C   0x2137             MOVGE    R1,#+55
   \   0000000E   0xDA03             BGE.N    ??emberHexToInt_0
   \   00000010   0x283A             CMP      R0,#+58
   \   00000012   0xBFB4             ITE      LT 
   \   00000014   0x2130             MOVLT    R1,#+48
   \   00000016   0x2100             MOVGE    R1,#+0
   \                     ??emberHexToInt_0: (+1)
   \   00000018   0x1A40             SUBS     R0,R0,R1
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x4770             BX       LR               ;; return
    518          }
    519          

   \                                 In section .text, align 2, keep-with-next
    520          bool emCompareCommandName(const uint8_t *command1,
    521                                       const uint8_t *command2,
    522                                       bool binaryCommand)
    523          {
   \                     emCompareCommandName: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    524            return (MEMCOMPARE(command1 + (binaryCommand ? 1 : 0),
    525                               command2,
    526                               emStrlen(command2))
    527                    == 0);
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       emStrlen
   \   0000000E   0xB106             CBZ.N    R6,??emCompareCommandName_0
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \                     ??emCompareCommandName_0: (+1)
   \   00000012   0x4602             MOV      R2,R0
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       halCommonMemCompare
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x4180             SBCS     R0,R0,R0
   \   00000020   0x0FC0             LSRS     R0,R0,#+31
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    528          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     emCommandState

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x63 0x6F          DC8 "command-interpreter2-util.c"
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2D    
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x70    
   \              0x72 0x65    
   \              0x74 0x65    
   \              0x72 0x32    
   \              0x2D 0x75    
   \              0x74 0x69    
   \              0x6C 0x2E    
   \              0x63 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x42 0x61          DC8 "Bad IP format"
   \              0x64 0x20    
   \              0x49 0x50    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x6D 0x61    
   \              0x74 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   emCommandReaderInitStateVar
       0   emCommandReaderReinit
      16   emCompareCommandName
        16   -> emStrlen
        16   -> halCommonMemCompare
       8   emFirstByteOfArg
         8   -> emTokenPointer
      32   emStringToUnsignedInt
        32   -> emTokenLength
        32   -> emTokenPointer
        32   -> emberCommandArgumentCount
        32   -> emberHexToInt
        32   -> halInternalAssertFailed
       0   emTokenLength
       0   emTokenPointer
       0   emberCommandArgumentCount
       0   emberCommandName
       0   emberCommandReaderInit
         0   -> emCommandReaderReinit
       0   emberCommandReaderSetDefaultBase
      16   emberGetExtendedPanIdArgument
        16   -> emberGetStringArgument
        16   -> emberReverseMemCopy
       0   emberGetIpArgument
         0   -> getIpArgument
       0   emberGetIpPrefixArgument
         0   -> getIpArgument
       8   emberGetNestedCommand
         8   -> halInternalAssertFailed
      32   emberGetStringArgument
        32   -> emFirstByteOfArg
        32   -> emberStringCommandArgument
        32   -> halCommonMemMove
        32   -> halCommonMemSet
       0   emberHexToInt
      16   emberSignedCommandArgument
        16   -> emFetchInt32u
        16   -> emFirstByteOfArg
        16   -> emStringToUnsignedInt
        16   -> emTokenLength
        16   -> emTokenPointer
        16   -> emberFetchHighLowInt16u
        16   -> halInternalAssertFailed
      24   emberStringCommandArgument
        24   -> emTokenLength
        24   -> emTokenPointer
       0   emberStringToIpAddress
         0   -> stringToIp
       0   emberStringToIpPrefix
         0   -> stringToIp
      16   emberUnsignedCommandArgument
         0   -> emFetchInt32u
         0   -> emStringToUnsignedInt
        16   -> emTokenLength
        16   -> emTokenPointer
        16   -> halInternalAssertFailed
      16   getIpArgument
        16   -> emberSerialPrintfLine
        16   -> emberStringCommandArgument
        16   -> stringToIp
      56   stringToIp
        56   -> emberHexToInt
        56   -> emberStoreHighLowInt16u
        56   -> halCommonMemMove
        56   -> halCommonMemSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       6  ?Subroutine0
       8  ?Subroutine1
      12  ?Subroutine2
      28  ?_0
      16  ?_1
      50  emCommandReaderInitStateVar
      40  emCommandReaderReinit
     132  emCommandState
      36  emCompareCommandName
      20  emFirstByteOfArg
     134  emStringToUnsignedInt
      12  emTokenLength
      14  emTokenPointer
      12  emberCommandArgumentCount
      10  emberCommandName
      16  emberCommandReaderInit
       8  emberCommandReaderSetDefaultBase
      26  emberGetExtendedPanIdArgument
       4  emberGetIpArgument
       4  emberGetIpPrefixArgument
      32  emberGetNestedCommand
     108  emberGetStringArgument
      30  emberHexToInt
      96  emberSignedCommandArgument
      92  emberStringCommandArgument
       4  emberStringToIpAddress
       4  emberStringToIpPrefix
      78  emberUnsignedCommandArgument
      46  getIpArgument
     278  stringToIp

 
   132 bytes in section .bss
 1 228 bytes in section .text
 
 1 228 bytes of CODE memory
   132 bytes of DATA memory

Errors: none
Warnings: none
