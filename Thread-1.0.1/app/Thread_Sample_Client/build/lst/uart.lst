###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  14:43:39
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\uart.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\uart.c -D APP_BTL -D
#        CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D PHY_EM3XX -D
#        "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"uart.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\lst\uart.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\obj\uart.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\uart.c
      1          /** @file hal/micro/cortexm3/uart.c
      2           *  @brief EM3XX UART Library.
      3           *
      4           * <!-- Copyright 2014 Silicon Laboratories, Inc.                        *80*-->
      5           */
      6          
      7          #include PLATFORM_HEADER
      8          #include "stack/include/ember.h"
      9          #include "stack/include/error.h"
     10          #include "stack/platform/micro/debug-channel.h"
     11          #include "hal/hal.h"
     12          #include "hal/micro/micro-types.h"
     13          
     14          #if (! defined(EMBER_STACK_IP))
     15          #include "stack/include/packet-buffer.h"
     16          #endif
     17          
     18          #include "app/util/serial/serial.h"
     19          
     20          // Allow some code to be disabled (and flash saved) if
     21          //  a port is unused or in low-level driver mode
     22          // port 0 is VUART
     23          #if (EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED)
     24            #define EM_SERIAL0_ENABLED 0
     25            #define EM_SER0_PORT_EN(port) (false)
     26          #else
     27            #define EM_SERIAL0_ENABLED 1
     28            #define EM_SER0_PORT_EN(port) ((port) == 0)
     29          #endif
     30          #if (EMBER_SERIAL0_MODE == EMBER_SERIAL_LOWLEVEL)
     31            #error Serial 0 (Virtual Uart) does not support LOWLEVEL mode
     32          #endif
     33          
     34          // port 1 is SC1
     35          #if !defined(EMBER_MICRO_HAS_SC1) \
     36              || (EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED) \
     37              || (EMBER_SERIAL1_MODE == EMBER_SERIAL_LOWLEVEL)
     38            #define EM_SERIAL1_ENABLED 0
     39            #define EM_SER1_PORT_EN(port)     (false)
     40            #define EM_SER1_PORT_FIFO(port)   (false)
     41            #define EM_SER1_PORT_BUFFER(port) (false)
     42          #else
     43            #define EM_SERIAL1_ENABLED 1
     44            #define EM_SER1_PORT_EN(port) ((port) == 1)
     45            #if     (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
     46              #define EM_SER1_PORT_FIFO(port)   EM_SER1_PORT_EN(port)
     47              #define EM_SER1_PORT_BUFFER(port) (false)
     48            #else//Must be EMBER_SERIAL_BUFFER
     49              #define EM_SER1_PORT_FIFO(port)   (false)
     50              #define EM_SER1_PORT_BUFFER(port) EM_SER1_PORT_EN(port)
     51            #endif
     52            #ifndef SOFTUART
     53              #define EM_PHYSICAL_UART
     54            #endif
     55          #endif
     56          
     57          // port 2 is SC3
     58          #if !defined(EMBER_MICRO_HAS_SC3) \
     59              || (EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED) \
     60              || (EMBER_SERIAL2_MODE == EMBER_SERIAL_LOWLEVEL)
     61            #define EM_SERIAL2_ENABLED 0
     62            #define EM_SER2_PORT_EN(port)     (false)
     63            #define EM_SER2_PORT_FIFO(port)   (false)
     64            #define EM_SER2_PORT_BUFFER(port) (false)
     65          #else
     66            #define EM_SERIAL2_ENABLED 1
     67            #define EM_SER2_PORT_EN(port) ((port) == 2)
     68            #if     (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
     69              #define EM_SER2_PORT_FIFO(port)   EM_SER2_PORT_EN(port)
     70              #define EM_SER2_PORT_BUFFER(port) (false)
     71            #else//Must be EMBER_SERIAL_BUFFER
     72              #define EM_SER2_PORT_FIFO(port)   (false)
     73              #define EM_SER2_PORT_BUFFER(port) EM_SER2_PORT_EN(port)
     74            #endif
     75            #define EM_PHYSICAL_UART
     76          #endif
     77          
     78          // port 3 is USB
     79          #if !defined(CORTEXM3_EM35X_USB) \
     80              || (EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED) \
     81            || defined (USB_MSD) \
     82            || defined (USB_HID)
     83            #define EM_SERIAL3_ENABLED 0
     84            #define EM_SER3_PORT_EN(port) (false)
     85            #ifdef USB_HID
     86              #include "hal/micro/cortexm3/usb/em_usb.h"
     87              #include "hal/micro/cortexm3/usb/hid/usbconfig.h"
     88              #include "hal/micro/cortexm3/usb/hid/descriptors.h"
     89            #endif
     90            #define EM_SER3_PORT_FIFO(port)   (false)
     91            #define EM_SER3_PORT_BUFFER(port) (false)
     92          #else
     93            #define EM_SERIAL3_ENABLED 1
     94            #define EM_SER3_PORT_EN(port) ((port) == 3)
     95            #if     (EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO)
     96              #define EM_SER3_PORT_FIFO(port)   EM_SER3_PORT_EN(port)
     97              #define EM_SER3_PORT_BUFFER(port) (false)
     98            #else//Must be EMBER_SERIAL_BUFFER
     99              #define EM_SER3_PORT_FIFO(port)   (false)
    100              #define EM_SER3_PORT_BUFFER(port) EM_SER3_PORT_EN(port)
    101            #endif
    102          
    103            #include "hal/micro/cortexm3/usb/em_usb.h"
    104            #include "hal/micro/cortexm3/usb/cdc/usbconfig.h"
    105            #include "hal/micro/cortexm3/usb/cdc/descriptors.h"

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute struct <unnamed> const deviceDesc
   \                     deviceDesc:
   \   00000000   0x12 0x01          DC8 18, 1
   \   00000002   0x0200             DC16 512
   \   00000004   0x02 0x00          DC8 2, 0, 0, 8
   \              0x00 0x08    
   \   00000008   0x10C4 0x0003      DC16 4292, 3, 0
   \              0x0000       
   \   0000000E   0x01 0x02          DC8 1, 2, 3, 1, 0, 0
   \              0x03 0x01    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute unsigned char const configDesc[67]
   \                     configDesc:
   \   00000000   0x09 0x02          DC8 9, 2, 67, 0, 2, 1, 0, 192, 50, 9, 4, 0, 0, 1, 2, 2, 0, 0, 5, 36, 0
   \              0x43 0x00    
   \              0x02 0x01    
   \              0x00 0xC0    
   \              0x32 0x09    
   \              0x04 0x00    
   \              0x00 0x01    
   \              0x02 0x02    
   \              0x00 0x00    
   \              0x05 0x24    
   \              0x00         
   \   00000015   0x20 0x01          DC8 32, 1, 5, 36, 1, 0, 1, 4, 36, 2, 2, 5, 36, 6, 0, 1, 7, 5, 130, 3
   \              0x05 0x24    
   \              0x01 0x00    
   \              0x01 0x04    
   \              0x24 0x02    
   \              0x02 0x05    
   \              0x24 0x06    
   \              0x00 0x01    
   \              0x07 0x05    
   \              0x82 0x03    
   \   00000029   0x40 0x00          DC8 64, 0, 255, 9, 4, 1, 0, 2, 10, 0, 0, 0, 7, 5, 133, 2, 64, 0, 0, 7
   \              0xFF 0x09    
   \              0x04 0x01    
   \              0x00 0x02    
   \              0x0A 0x00    
   \              0x00 0x00    
   \              0x07 0x05    
   \              0x85 0x02    
   \              0x40 0x00    
   \              0x00 0x07    
   \   0000003D   0x05 0x05          DC8 5, 5, 2, 64, 0, 0, 0
   \              0x02 0x40    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute _langID const langID
   \                     langID:
   \   00000000   0x04 0x03          DC8 4, 3, 9, 4
   \              0x09 0x04    

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute _iManufacturer const iManufacturer
   \                     iManufacturer:
   \   00000000   0x32 0x03          DC8 50, 3
   \   00000002   0x0053 0x0069      DC16 83, 105, 108, 105, 99, 111, 110, 32, 76, 97, 98, 111, 114, 97, 116
   \              0x006C 0x0069
   \              0x0063 0x006F
   \              0x006E 0x0020
   \              0x004C 0x0061
   \              0x0062 0x006F
   \              0x0072 0x0061
   \              0x0074       
   \   00000020   0x006F 0x0072      DC16 111, 114, 105, 101, 115, 32, 73, 110, 99, 46, 0
   \              0x0069 0x0065
   \              0x0073 0x0020
   \              0x0049 0x006E
   \              0x0063 0x002E
   \              0x0000       
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute _iProduct const iProduct
   \                     iProduct:
   \   00000000   0x38 0x03          DC8 56, 3
   \   00000002   0x0053 0x0069      DC16 83, 105, 108, 105, 99, 111, 110, 32, 76, 97, 98, 115, 32, 67, 68
   \              0x006C 0x0069
   \              0x0063 0x006F
   \              0x006E 0x0020
   \              0x004C 0x0061
   \              0x0062 0x0073
   \              0x0020 0x0043
   \              0x0044       
   \   00000020   0x0043 0x0020      DC16 67, 32, 83, 101, 114, 105, 97, 108, 32, 80, 111, 114, 116, 0
   \              0x0053 0x0065
   \              0x0072 0x0069
   \              0x0061 0x006C
   \              0x0020 0x0050
   \              0x006F 0x0072
   \              0x0074 0x0000

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute void const *const strings[4]
   \                     strings:
   \   00000000   0x........         DC32 langID, iManufacturer, iProduct, iSerialNumber
   \              0x........   
   \              0x........   
   \              0x........   

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute unsigned char const bufferingMultiplier[4]
   \                     bufferingMultiplier:
   \   00000000   0x01 0x01          DC8 1, 1, 2, 2
   \              0x02 0x02    

   \                                 In section .rodata, align 4, keep-with-next
   \   static __absolute USBD_Callbacks_TypeDef const callbacks
   \                     callbacks:
   \   00000000   0x00000000         DC32 0H, stateChange, SetupCmd, 0H, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute struct <unnamed> const initstruct
   \                     initstruct:
   \   00000000   0x........         DC32 deviceDesc, configDesc, strings
   \              0x........   
   \              0x........   
   \   0000000C   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x........         DC32 bufferingMultiplier, callbacks, 0
   \              0x........   
   \              0x00000000   

   \                                 In section .data, align 4
    106            sernum iSerialNumber =
   \                     iSerialNumber:
   \   00000000   0x20 0x03          DC8 32, 3
   \   00000002   0x0030 0x0030      DC16 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 0
   \              0x0030 0x0030
   \              0x0030 0x0030
   \              0x0030 0x0030
   \              0x0030 0x0030
   \              0x0030 0x0030
   \              0x0030 0x0030
   \              0x0030 0x0030
   \              0x0000       
    107            {
    108              .len  = 32,
    109              .type = USB_STRING_DESCRIPTOR,
    110              .name = {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
    111              .name[ 16 ] = '\0'
    112            };
    113          #endif
    114          
    115          
    116          
    117          
    118          #if defined(EM_ENABLE_SERIAL_FIFO) && defined(EM_ENABLE_SERIAL_BUFFER)
    119            #define EM_SER_MULTI(expr) (expr)
    120          #else // None/Single/Same UARTs -- no need to runtime check their mode at all
    121            #define EM_SER_MULTI(expr) (true)
    122          #endif
    123          
    124          // TODO
    125          #if EM_SERIAL1_ENABLED && (defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL1_XONXOFF)) && EM_SERIAL2_ENABLED
    126            #error Flow control is not currently supported when using both physical UARTs
    127          #endif
    128          
    129          //State information for RX DMA Buffer operation
    130          typedef struct EmSerialBufferState {
    131            const uint16_t fifoSize;
    132            const uint16_t rxStartIndexB;
    133            uint16_t prevCountA;
    134            uint16_t prevCountB;
    135            bool waitingForTailA;
    136            bool waitingForTailB;
    137            bool waitingForInputToB;
    138            EmberMessageBuffer holdBuf[2];
    139          } EmSerialBufferState;
    140          
    141          // to save flash and speed, if there is only one UART in use, make SCx_REG
    142          // and friends decay into a simple register access
    143          #if !EM_SERIAL1_ENABLED || !EM_SERIAL2_ENABLED
    144            #if EM_SERIAL1_ENABLED
    145              #define SCx_REG(port, reg) SC1_##reg
    146              #define INT_SCxCFG(port) INT_SC1CFG
    147              #define INT_SCxFLAG(port) INT_SC1FLAG
    148              #define INT_SCx(port) INT_SC1
    149            #else
    150              #define SCx_REG(port, reg) SC3_##reg
    151              #define INT_SCxCFG(port) INT_SC3CFG
    152              #define INT_SCxFLAG(port) INT_SC3FLAG
    153              #define INT_SCx(port) INT_SC3
    154            #endif
    155          #else
    156            const uint32_t serialControllerBlockAddresses[] = { SC1_RXBEGA_ADDR, SC3_RXBEGA_ADDR };
    157            // index into the above array.
    158            // keep in mind port 1 is SC1 and port 2 is SC3 (this is the tricky one)
    159            #define SCx_REG(port, reg) (*((volatile uint32_t *)(                          \
    160                                        (SC1_##reg##_ADDR - SC1_RXBEGA_ADDR)            \
    161                                        + serialControllerBlockAddresses[(port) - 1])))
    162          
    163            const uint32_t serialControllerIntCfgAddresses[] = { INT_SC1CFG_ADDR, INT_SC3CFG_ADDR };
    164            #define INT_SCxCFG(port) (*((volatile uint32_t *)serialControllerIntCfgAddresses[(port) - 1]))
    165          
    166            const uint32_t serialControllerIntFlagAddresses[]  = { INT_SC1FLAG_ADDR, INT_SC3FLAG_ADDR };
    167            #define INT_SCxFLAG(port) (*((volatile uint32_t *)serialControllerIntFlagAddresses[(port) - 1]))
    168          
    169            const uint32_t serialControllerNvecIntValues[] = { INT_SC1, INT_SC3 };
    170            #define INT_SCx(port) serialControllerNvecIntValues[(port) - 1]
    171          #endif
    172          
    173          #if defined(EZSP_UART) && \
    174              !defined(EMBER_SERIAL1_RTSCTS) && \
    175              !defined(EMBER_SERIAL1_XONXOFF)&& \
    176              !defined(EZSP_USB)
    177            #error EZSP-UART requires either RTS/CTS or XON/XOFF flow control!
    178          #endif
    179          
    180          #ifdef EMBER_SERIAL1_RTSCTS
    181            #if EMBER_SERIAL1_MODE != EMBER_SERIAL_BUFFER
    182            #error "Illegal serial port 1 configuration"
    183            #endif
    184          #endif
    185          
    186          #ifdef EMBER_SERIAL2_RTSCTS
    187            #if EMBER_SERIAL2_MODE != EMBER_SERIAL_BUFFER
    188            #error "Illegal serial port 2 configuration"
    189            #endif
    190          #endif
    191          
    192          #ifdef EMBER_SERIAL1_XONXOFF
    193            #if EMBER_SERIAL1_MODE != EMBER_SERIAL_FIFO
    194            #error "Illegal serial port 1 configuration"
    195            #endif
    196          
    197            static void halInternalUart1ForceXon(void); // forward declaration
    198          
    199            static int8_t xcmdCount;     // num XONs sent to host, written only by tx isr
    200                                        //-1 means an XOFF was sent last
    201                                        // 0 means ready to rx, but no XON has been sent
    202                                        // n>0 means ready to rx, and n XONs have been sent
    203            static uint8_t xonXoffTxByte; // if non-zero, an XON or XOFF byte to send ahead
    204                                        // of tx queue - cleared when byte is sent
    205            static uint8_t xonTimer;      // time when last data rx'ed from host, or when
    206                                        // an XON was sent (in 1/4 ticks)
    207          
    208            #define ASCII_XON         0x11  // requests host to pause sending
    209            #define ASCII_XOFF        0x13  // requests host to resume sending
    210            #define XON_REFRESH_TIME  8     // delay between repeat XONs (1/4 sec units)
    211            #define XON_REFRESH_COUNT 3     // max number of repeat XONs to send after 1st
    212          
    213            // Define thresholds for XON/XOFF flow control in terms of queue used values
    214            // Take into account the 4 byte transmit FIFO
    215            #if (EMBER_SERIAL1_RX_QUEUE_SIZE == 128)
    216              #define XON_LIMIT       16    // send an XON
    217              #define XOFF_LIMIT      96    // send an XOFF
    218            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE == 64)
    219              #define XON_LIMIT       8
    220              #define XOFF_LIMIT      36
    221            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE == 32)
    222              #define XON_LIMIT       2
    223              #define XOFF_LIMIT      8
    224            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE > 32)
    225              #define XON_LIMIT       (EMBER_SERIAL1_RX_QUEUE_SIZE/8)
    226              #define XOFF_LIMIT      (EMBER_SERIAL1_RX_QUEUE_SIZE*3/4)
    227            #else
    228              #error "Serial port 1 receive buffer too small!"
    229            #endif
    230          #endif  // EMBER_SERIAL1_XONXOFF
    231          
    232          #ifdef EMBER_SERIAL2_XONXOFF
    233            #error "XON/XOFF is not supported on port 2"
    234          #endif
    235          
    236          #ifdef EMBER_SERIAL3_XONXOFF
    237            #error "XON/XOFF is not supported on port 3"
    238          #endif
    239          
    240          ////////////////////// SOFTUART Pin and Speed definitions //////////////////////
    241          //use a logic analyzer and trial and error to determine these values if
    242          //the SysTick time changes or you want to try a different baud
    243          //These were found using EMU 0x50
    244          #define FULL_BIT_TIME_SCLK  0x9C0UL  //9600 baud with FLKC @ SCLK(24MHz)
    245          #define START_BIT_TIME_SCLK 0x138UL  //9600 baud with FLKC @ SCLK(24MHz)
    246          //USE PB6 (GPIO22) for TXD
    247          #define CONFIG_SOFT_UART_TX_BIT() \
    248            GPIO_PCCFGH = (GPIO_PCCFGH&(~PC6_CFG_MASK)) | (1 << PC6_CFG_BIT)
    249          #define SOFT_UART_TX_BIT(bit)  GPIO_PCOUT = (GPIO_PCOUT&(~PC6_MASK))|((bit)<<PC6_BIT)
    250          //USE PB7 (GPIO23) for RXD
    251          #define CONFIG_SOFT_UART_RX_BIT() \
    252            GPIO_PCCFGH = (GPIO_PCCFGH&(~PC7_CFG_MASK)) | (4 << PC7_CFG_BIT)
    253          #define SOFT_UART_RX_BIT  ((GPIO_PCIN&PC7)>>PC7_BIT)
    254          ////////////////////// SOFTUART Pin and Speed definitions //////////////////////
    255          
    256          #if defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL2_RTSCTS)
    257            void halInternalUartRxCheckRts(uint8_t port);
    258          #else
    259            #define halInternalUartRxCheckRts(x) do {} while(0)
    260          #endif
    261          
    262          #if defined(EMBER_SERIAL1_RTSCTS)
    263            // define this for backwards compatibility
    264            void halInternalUart1RxCheckRts( void )
    265            {
    266              halInternalUartRxCheckRts(1);
    267            }
    268          #endif
    269          
    270          // Save flash if ports are undefined
    271          #if defined(EM_PHYSICAL_UART)
    272          

   \                                 In section .text, align 4, keep-with-next
    273            const uint8_t baudSettings[] = {
   \                     baudSettings:
   \   00000000   0x30 0x60          DC8 48, 96, 144, 192, 193, 194, 195, 148, 196, 149, 197, 92, 150, 198
   \              0x90 0xC0    
   \              0xC1 0xC2    
   \              0xC3 0x94    
   \              0xC4 0x95    
   \              0xC5 0x5C    
   \              0x96 0xC6    
   \   0000000E   0xAC 0x97          DC8 172, 151, 152, 153, 13, 0
   \              0x98 0x99    
   \              0x0D 0x00    
    274              // This table is indexed by the supported BAUD_xxx enum from serial.h.
    275              // The actual baud rate is encoded in a byte and converted algorithmically
    276              // into the needed SCx register values based on system clock frequency
    277              // Here each byte is divided into two 4-bit nibbles 0x<mul><exp> where:
    278              // baud = <mul> * 100 * 2^<exp> when <exp> is <=10
    279              //  and = <mul> * 100 * 10^(<exp>-10) when <exp> is >10
    280              // This allows all supported baud rates (and many others) to be represented.
    281              0x30, //  0 - BAUD_300    =  3 * 100 * 2^0
    282              0x60, //  1 - BAUD_600    =  6 * 100 * 2^0
    283              0x90, //  2 - BAUD_900    =  9 * 100 * 2^0
    284              0xC0, //  3 - BAUD_1200   = 12 * 100 * 2^0
    285              0xC1, //  4 - BAUD_2400   = 12 * 100 * 2^1
    286              0xC2, //  5 - BAUD_4800   = 12 * 100 * 2^2
    287              0xC3, //  6 - BAUD_9600   = 12 * 100 * 2^3
    288              0x94, //  7 - BAUD_14400  =  9 * 100 * 2^4
    289              0xC4, //  8 - BAUD_19200  = 12 * 100 * 2^4
    290              0x95, //  9 - BAUD_28800  =  9 * 100 * 2^5
    291              0xC5, // 10 - BAUD_38400  = 12 * 100 * 2^5
    292              0x5C, // 11 - BAUD_50000  =  5 * 100 * 10^2
    293              0x96, // 12 - BAUD_57600  =  9 * 100 * 2^6
    294              0xC6, // 13 - BAUD_76800  = 12 * 100 * 2^6
    295              0xAC, // 14 - BAUD_100000 = 10 * 100 * 10^2
    296              0x97, // 15 - BAUD_115200 =  9 * 100 * 2^7
    297              0x98, // 16 - BAUD_230400 =  9 * 100 * 2^8
    298              0x99, // 17 - BAUD_460800 =  9 * 100 * 2^9
    299             #ifdef EMBER_SERIAL_BAUD_CUSTOM
    300              EMBER_SERIAL_BAUD_CUSTOM, //Hook for custom baud rate, see BOARD_HEADER
    301             #else
    302              0x9A, // 18 - BAUD_921600 =  9 * 100 * 2^10
    303             #endif
    304            };
    305          
    306          #endif // defined(EM_PHYSICAL_UART)
    307          
    308          #if EM_SERIAL1_ENABLED
    309            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    310            #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    311          
    312            #if    SLEEPY_IP_MODEM_UART
    313              //This macro is used to manipulate TxD to avoid glitching it across sleep
    314              //which can lead to spurrious data or framing errors seen by peer
    315              #define SC1_TXD_GPIO(gpioCfg, state) do {                                   \
    316                GPIO_PBCFGL = (GPIO_PBCFGL & ~PB1_CFG_MASK) | ((gpioCfg) << PB1_CFG_BIT); \
    317                (state) ? (GPIO_PBSET = PB1) : (GPIO_PBCLR = PB1);                        \
    318              } while (0)
    319            #else//!SLEEPY_IP_MODEM_UART
    320              #define SC1_TXD_GPIO(gpioCfg, state) do { } while (0)
    321            #endif//SLEEPY_IP_MODEM_UART
    322          #endif // EM_SERIAL1_ENABLED
    323          
    324          // figure out how many buffer state structs we need
    325          #if (EM_SERIAL1_ENABLED                                                        \
    326              && EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)                              \
    327              && (EM_SERIAL2_ENABLED                                                     \
    328              && EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER)                              \
    329              && (EM_SERIAL3_ENABLED                                                     \
    330              && EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER)
    331            static EmSerialBufferState serialBufferStates[] = {
    332              { EMBER_SERIAL1_RX_QUEUE_SIZE,
    333                (EMBER_SERIAL1_RX_QUEUE_SIZE/2),
    334                0,
    335                0,
    336                false,
    337                false,
    338                false,
    339                { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    340              },
    341              { EMBER_SERIAL2_RX_QUEUE_SIZE,
    342                (EMBER_SERIAL2_RX_QUEUE_SIZE/2),
    343                0,
    344                0,
    345                false,
    346                false,
    347                false,
    348                { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    349              },
    350              { EMBER_SERIAL3_RX_QUEUE_SIZE,
    351                (EMBER_SERIAL3_RX_QUEUE_SIZE/2),
    352                0,
    353                0,
    354                false,
    355                false,
    356                false,
    357                { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    358              }
    359            };
    360          
    361            #define BUFSTATE(port) (serialBufferStates + (port) - 1)
    362          #elif (EM_SERIAL1_ENABLED                                          \
    363                 && EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    364            static EmSerialBufferState serialBufferState = {
    365              EMBER_SERIAL1_RX_QUEUE_SIZE,
    366              (EMBER_SERIAL1_RX_QUEUE_SIZE/2),
    367              0,
    368              0,
    369              false,
    370              false,
    371              false,
    372              { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    373            };
    374          
    375            #define BUFSTATE(port) (&serialBufferState)
    376          #elif (EM_SERIAL2_ENABLED                                          \
    377                 && EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER)
    378            static EmSerialBufferState serialBufferState = {
    379              EMBER_SERIAL2_RX_QUEUE_SIZE,
    380              (EMBER_SERIAL2_RX_QUEUE_SIZE/2),
    381              0,
    382              0,
    383              false,
    384              false,
    385              false,
    386              { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    387            };
    388          
    389            #define BUFSTATE(port) (&serialBufferState)
    390          #elif (EM_SERIAL3_ENABLED                                          \
    391                 && EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER)
    392            static EmSerialBufferState serialBufferState = {
    393              EMBER_SERIAL3_RX_QUEUE_SIZE,
    394              (EMBER_SERIAL3_RX_QUEUE_SIZE/2),
    395              0,
    396              0,
    397              false,
    398              false,
    399              false,
    400              { EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    401            };
    402          
    403            #define BUFSTATE(port) (&serialBufferState)
    404          #endif
    405          
    406          // prototypes
    407          #if defined(EM_PHYSICAL_UART)
    408          static void halInternalUartTxIsr(uint8_t port);
    409          #endif
    410          static void uartErrorMark(uint8_t port, uint8_t errors);
    411          #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    412          static void halInternalRestartUartDma(uint8_t port);
    413          #endif
    414          
    415          // init function for soft uart
    416          #ifdef SOFTUART
    417          static EmberStatus halInternalInitSoftUart()
    418          {
    419            //make sure the TX bit starts at idle high
    420            SOFT_UART_TX_BIT(1);
    421            CONFIG_SOFT_UART_TX_BIT();
    422            CONFIG_SOFT_UART_RX_BIT();
    423          
    424            return EMBER_SUCCESS;
    425          }
    426          #endif
    427          
    428          #ifdef EM_PHYSICAL_UART

   \                                 In section .text, align 2, keep-with-next
    429          static void halInternalInitUartInterrupts(uint8_t port)
    430          {
    431            #if defined(EM_ENABLE_SERIAL_FIFO)
    432              if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
    433                // Make the RX Valid interrupt level sensitive (instead of edge)
    434                // SC1_INTMODE = SC_SPIRXVALMODE;
    435                // Enable just RX interrupts; TX interrupts are controlled separately
    436                INT_SCxCFG(port) |= (INT_SCRXVAL   |
    437                                     INT_SCRXOVF   |
    438                                     INT_SC1FRMERR |
    439                                     INT_SC1PARERR);
   \                     halInternalInitUartInterrupts: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x4000a808
   \   00000004   0x6C01             LDR      R1,[R0, #+64]
   \   00000006   0xF441 0x41C0      ORR      R1,R1,#0x6000
   \   0000000A   0xF041 0x0109      ORR      R1,R1,#0x9
   \   0000000E   0x6401             STR      R1,[R0, #+64]
    440                INT_SCxFLAG(port) = 0xFFFF; // Clear any stale interrupts
   \   00000010   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000014   0x6001             STR      R1,[R0, #+0]
    441                INT_CFGSET = INT_SCx(port);
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable26_1  ;; 0xe000e100
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    442              }
    443            #endif
    444            #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    445              if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
    446                halInternalRestartUartDma(port);
    447          
    448                // don't do this for port 1 if it's being used for EZSP
    449                #ifdef EZSP_UART
    450                  if (port != 1) {
    451                #endif
    452                    INT_SCxCFG(port) |= (INT_SCRXOVF   |
    453                                         INT_SC1FRMERR |
    454                                         INT_SC1PARERR);
    455                #ifdef EZSP_UART
    456                  }
    457                #endif
    458          
    459                // The receive side of buffer mode does not require any interrupts.
    460                // The transmit side of buffer mode requires interrupts, which
    461                // will be configured on demand in halInternalStartUartTx(), so just
    462                // enable the top level interrupt for the transmit side.
    463                INT_SCxFLAG(port) = 0xFFFF; // Clear any stale interrupts
    464                INT_CFGSET = INT_SCx(port); // Enable top-level interrupt
    465          
    466                #ifdef EMBER_SERIAL1_RTSCTS
    467                  // TODO refactor this into a variable that can be queried at runtime
    468                  if (EM_SER1_PORT_EN(port)) {
    469                    // Software-based RTS/CTS needs interrupts on DMA buffer unloading.
    470                    INT_SCxCFG(port) |= (INT_SCRXULDA | INT_SCRXULDB);
    471                    SCx_REG(port, UARTCFG) |= (SC_UARTFLOW | SC_UARTRTS);
    472                  }
    473                #endif
    474                #ifdef EMBER_SERIAL2_RTSCTS
    475                  if (EM_SER2_PORT_EN(port)) {
    476                    // Software-based RTS/CTS needs interrupts on DMA buffer unloading.
    477                    INT_SCxCFG(port) |= (INT_SCRXULDA | INT_SCRXULDB);
    478                    SCx_REG(port, UARTCFG) |= (SC_UARTFLOW | SC_UARTRTS);
    479                  }
    480                #endif
    481              }
    482            #endif
    483          }
   \   0000001E   0x4770             BX       LR               ;; return
    484          
    485          // init function for physical UART
    486          static EmberStatus halInternalInitPhysicalUart(uint8_t port,
    487                                                         SerialBaudRate rate,
    488                                                         SerialParity parity,
    489                                                         uint8_t stopBits)
    490          {
    491            uint32_t tempcfg;
    492          
    493            // set baud rate
    494            // If rate is one of the BAUD_ settings from serial.h then use
    495            // its baudSetting[] value from above, otherwise interpret it
    496            // as a custom baudSetting[] encoded value.
    497            if (rate < sizeof(baudSettings)/sizeof(*baudSettings)) {
    498              rate = baudSettings[rate];
    499            }
    500            // Convert encoded rate into baud by extracting the <mul> and <exp>
    501            // nibbles.  <mul> is always multiplied by 100.  For <exp> <= 10,
    502            // that result is multipled by 2^<exp>; for <exp> > 10 that result
    503            // is multipled by 10^(<exp>-10).
    504            tempcfg = (uint32_t)(rate >> 4) * 100; // multiplier
    505            rate &= 0x0F; // exponent
    506            if (rate <= 10) {
    507              tempcfg <<= rate;
    508            } else {
    509              while (rate-- > 10) {
    510                tempcfg *= 10;
    511              }
    512            }
    513            EmberStatus status = halInternalUartSetBaudRate(port, tempcfg);
    514            if (status != EMBER_SUCCESS) {
    515              return status;
    516            }
    517          
    518            // Default is always 8 data bits irrespective of parity setting,
    519            // according to Lee, but hack overloads high-order nibble of stopBits to
    520            // allow user to specify desired number of data bits:  7 or 8 (default).
    521            if (((stopBits & 0xF0) >> 4) == 7) {
    522              tempcfg = 0;
    523            } else {
    524              tempcfg = SC_UART8BIT;
    525            }
    526          
    527            // parity bits
    528            if (parity == PARITY_ODD) {
    529              tempcfg |= SC_UARTPAR | SC_UARTODD;
    530            } else if( parity == PARITY_EVEN ) {
    531              tempcfg |= SC_UARTPAR;
    532            }
    533          
    534            // stop bits
    535            if ((stopBits & 0x0F) >= 2) {
    536              tempcfg |= SC_UART2STP;
    537            }
    538          
    539            // set all of the above into the config register
    540            SCx_REG(port, UARTCFG) = tempcfg;
    541          
    542            // put the peripheral into UART mode
    543            SCx_REG(port, MODE) = SC1_MODE_UART;
    544          
    545            if (EM_SER1_PORT_EN(port)) { // port 1 special glitch-free case 
    546              SC1_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
    547            }
    548          
    549            halInternalInitUartInterrupts(port);
    550          
    551            #ifdef EMBER_SERIAL1_XONXOFF
    552              if (EM_SER1_PORT_EN(port)) { // port 1 XON/XOFF special case
    553                halInternalUart1ForceXon();
    554              }
    555            #endif
    556          
    557            return EMBER_SUCCESS;
    558          }
    559          #endif // EM_PHYSICAL_UART
    560          
    561          // initialize USB Virtual COM Port
    562          #if EM_SERIAL3_ENABLED
    563          static EmberStatus halInternalInitUsbVcp(void)
    564          {
    565            #if defined(CORTEXM3_EM35X_USB)
    566              halResetWatchdog();
    567          
    568              tokTypeMfgEui64 tokEui64;
    569              halCommonGetMfgToken((void *)&tokEui64, TOKEN_MFG_EUI_64);
    570          
    571              uint8_t i = 0;
    572              uint8_t j = 0;
    573              for(j = 0; j<8; j++) {
    574                iSerialNumber.name[i++] = nibble2Ascii((tokEui64[j]>>4)&0xF);
    575                iSerialNumber.name[i++] = nibble2Ascii((tokEui64[j]>>0)&0xF);
    576              }
    577          
    578              USBD_Init(&initstruct);
    579          
    580              // USBD_Read(EP_OUT, receiveBuffer, 50, dataReceivedCallback);
    581          
    582              //It is necessary to wait for the COM port on the host to become
    583              //active before serial port3 can be used.
    584              uint16_t startTime = halCommonGetInt16uMillisecondTick();
    585              while(USBD_GetUsbState()!=USBD_STATE_CONFIGURED) {
    586                #ifdef BOOTLOADER
    587                  halUsbIsr();
    588                #endif
    589                //Give ourselves a healthy 1 second for a COM port to open.
    590                if(elapsedTimeInt16u(startTime,
    591                                     halCommonGetInt16uMillisecondTick()) > 1000) {
    592                  return EMBER_SERIAL_INVALID_PORT;
    593                }
    594              }
    595          
    596              return EMBER_SUCCESS;
    597            #else
    598              return EMBER_SERIAL_INVALID_PORT;
    599            #endif
    600          }
    601          #endif
    602          
    603          #if (EM_SERIAL0_ENABLED ||\
    604               EM_SERIAL1_ENABLED ||\
    605               EM_SERIAL2_ENABLED ||\
    606               EM_SERIAL3_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    607          EmberStatus halInternalUartInit(uint8_t port,
    608                                          SerialBaudRate rate,
    609                                          SerialParity parity,
    610                                          uint8_t stopBits)
    611          {
   \                     halInternalUartInit: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x461E             MOV      R6,R3
    612            #if EM_SERIAL0_ENABLED
    613              if (EM_SER0_PORT_EN(port)) {
   \   00000006   0xB910             CBNZ.N   R0,??halInternalUartInit_0
    614                // Initialize the debug channel
    615                return emDebugInit();
   \   00000008   0x.... 0x....      BL       emDebugInit
   \   0000000C   0xBD76             POP      {R1,R2,R4-R6,PC}
    616              }
    617            #endif
    618          
    619            #ifdef SOFTUART
    620              if (EM_SER1_PORT_EN(port)) {
    621                return halInternalInitSoftUart();
    622              }
    623            #endif
    624          
    625            #ifdef EM_PHYSICAL_UART
    626              if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \                     ??halInternalUartInit_0: (+1)
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD136             BNE.N    ??halInternalUartInit_1
    627                return halInternalInitPhysicalUart(port, rate, parity, stopBits);
   \   00000012   0x2913             CMP      R1,#+19
   \   00000014   0xBF3C             ITT      CC 
   \   00000016   0x.... 0x....      ADRCC.W  R0,baudSettings
   \   0000001A   0x5C09             LDRBCC   R1,[R1, R0]
   \   0000001C   0x0908             LSRS     R0,R1,#+4
   \   0000001E   0x2264             MOVS     R2,#+100
   \   00000020   0x4350             MULS     R0,R2,R0
   \   00000022   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000026   0x290B             CMP      R1,#+11
   \   00000028   0xDA03             BGE.N    ??halInternalUartInit_2
   \   0000002A   0x4088             LSLS     R0,R0,R1
   \   0000002C   0xE006             B.N      ??halInternalUartInit_3
   \                     ??halInternalUartInit_4: (+1)
   \   0000002E   0x220A             MOVS     R2,#+10
   \   00000030   0x4350             MULS     R0,R2,R0
   \                     ??halInternalUartInit_2: (+1)
   \   00000032   0x460A             MOV      R2,R1
   \   00000034   0x1E51             SUBS     R1,R2,#+1
   \   00000036   0xB2D2             UXTB     R2,R2
   \   00000038   0x2A0B             CMP      R2,#+11
   \   0000003A   0xDAF8             BGE.N    ??halInternalUartInit_4
   \                     ??halInternalUartInit_3: (+1)
   \   0000003C   0x4601             MOV      R1,R0
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      BL       halInternalUartSetBaudRate
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD15F             BNE.N    ??halInternalUartInit_5
   \   00000048   0x0930             LSRS     R0,R6,#+4
   \   0000004A   0x2807             CMP      R0,#+7
   \   0000004C   0xBF0C             ITE      EQ 
   \   0000004E   0x2000             MOVEQ    R0,#+0
   \   00000050   0x2002             MOVNE    R0,#+2
   \   00000052   0x2D01             CMP      R5,#+1
   \   00000054   0xBF08             IT       EQ 
   \   00000056   0xF040 0x0018      ORREQ    R0,R0,#0x18
   \   0000005A   0xD003             BEQ.N    ??halInternalUartInit_6
   \   0000005C   0x2D02             CMP      R5,#+2
   \   0000005E   0xBF08             IT       EQ 
   \   00000060   0xF040 0x0008      ORREQ    R0,R0,#0x8
   \                     ??halInternalUartInit_6: (+1)
   \   00000064   0xF006 0x010F      AND      R1,R6,#0xF
   \   00000068   0x2902             CMP      R1,#+2
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable26_2  ;; 0x4000c854
   \   0000006E   0xBFA8             IT       GE 
   \   00000070   0xF040 0x0004      ORRGE    R0,R0,#0x4
   \   00000074   0x6088             STR      R0,[R1, #+8]
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x6008             STR      R0,[R1, #+0]
   \   0000007A   0x.... 0x....      BL       halInternalInitUartInterrupts
   \   0000007E   0xE040             B.N      ??halInternalUartInit_7
    628              }
    629            #endif
    630          
    631            #if EM_SERIAL3_ENABLED && defined(CORTEXM3_EM35X_USB)
    632              if (EM_SER3_PORT_EN(port)) {
   \                     ??halInternalUartInit_1: (+1)
   \   00000080   0x2803             CMP      R0,#+3
   \   00000082   0xD140             BNE.N    ??halInternalUartInit_8
    633                return halInternalInitUsbVcp();
   \   00000084   0x.... 0x....      BL       halInternalResetWatchDog
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   0000008C   0x8801             LDRH     R1,[R0, #+0]
   \   0000008E   0x2308             MOVS     R3,#+8
   \   00000090   0x227F             MOVS     R2,#+127
   \   00000092   0xA800             ADD      R0,SP,#+0
   \   00000094   0x.... 0x....      BL       halInternalGetMfgTokenData
   \   00000098   0x2200             MOVS     R2,#+0
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \                     ??halInternalUartInit_9: (+1)
   \   000000A0   0xAC00             ADD      R4,SP,#+0
   \   000000A2   0x1C53             ADDS     R3,R2,#+1
   \   000000A4   0x5D04             LDRB     R4,[R0, R4]
   \   000000A6   0x0925             LSRS     R5,R4,#+4
   \   000000A8   0x2D0A             CMP      R5,#+10
   \   000000AA   0xB2D2             UXTB     R2,R2
   \   000000AC   0xBFB4             ITE      LT 
   \   000000AE   0x2630             MOVLT    R6,#+48
   \   000000B0   0x2637             MOVGE    R6,#+55
   \   000000B2   0xEB01 0x0242      ADD      R2,R1,R2, LSL #+1
   \   000000B6   0x1975             ADDS     R5,R6,R5
   \   000000B8   0x8055             STRH     R5,[R2, #+2]
   \   000000BA   0x1C5A             ADDS     R2,R3,#+1
   \   000000BC   0xF004 0x050F      AND      R5,R4,#0xF
   \   000000C0   0x2D0A             CMP      R5,#+10
   \   000000C2   0xBFB4             ITE      LT 
   \   000000C4   0x2530             MOVLT    R5,#+48
   \   000000C6   0x2537             MOVGE    R5,#+55
   \   000000C8   0xF004 0x040F      AND      R4,R4,#0xF
   \   000000CC   0xB2DB             UXTB     R3,R3
   \   000000CE   0x192C             ADDS     R4,R5,R4
   \   000000D0   0xEB01 0x0343      ADD      R3,R1,R3, LSL #+1
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x2808             CMP      R0,#+8
   \   000000D8   0x805C             STRH     R4,[R3, #+2]
   \   000000DA   0xDBE1             BLT.N    ??halInternalUartInit_9
   \   000000DC   0x.... 0x....      ADR.W    R0,initstruct
   \   000000E0   0x.... 0x....      BL       USBD_Init
   \   000000E4   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   000000E8   0x4604             MOV      R4,R0
   \                     ??halInternalUartInit_10: (+1)
   \   000000EA   0x.... 0x....      BL       USBD_GetUsbState
   \   000000EE   0x2804             CMP      R0,#+4
   \   000000F0   0xD007             BEQ.N    ??halInternalUartInit_7
   \   000000F2   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   000000F6   0x1B00             SUBS     R0,R0,R4
   \   000000F8   0xB280             UXTH     R0,R0
   \   000000FA   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000FE   0xDDF4             BLE.N    ??halInternalUartInit_10
   \   00000100   0xE001             B.N      ??halInternalUartInit_8
   \                     ??halInternalUartInit_7: (+1)
   \   00000102   0x2000             MOVS     R0,#+0
    634              }
   \   00000104   0xBD76             POP      {R1,R2,R4-R6,PC}
    635            #endif
    636          
    637            return EMBER_SERIAL_INVALID_PORT;
   \                     ??halInternalUartInit_8: (+1)
   \   00000106   0x2021             MOVS     R0,#+33
   \                     ??halInternalUartInit_5: (+1)
   \   00000108   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    638          }
    639          #endif//(!defined(EM_SERIAL0_DISABLED) || !defined(EM_SERIAL1_DISABLED))
    640          
    641          #ifdef SOFTUART
    642          //this requires use of the SysTick counter and will destroy interrupt latency!
    643          static void softwareUartTxByte(uint8_t byte)
    644          {
    645            uint8_t i;
    646            // BIT_TIMEs were determined based on 24 MHz MCU clock.
    647            // Scale 'em for the actual MCU clock in effect, with rounding.
    648            // (Because the FCLK might not evenly divide by 1000000 or even 500000, use
    649            // quad arithmetic dividing it by 250000.)
    650            uint16_t fullBitTime = (uint16_t)(((FULL_BIT_TIME_SCLK
    651                                         * (halMcuClockHz() / 250000UL)) + 48) / 96);
    652          
    653            ATOMIC(
    654              ST_RVR = fullBitTime; //set the SysTick reload value register
    655              //enable core clock reference and the counter itself
    656              ST_CSR = (ST_CSR_CLKSOURCE | ST_CSR_ENABLE);
    657              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    658          
    659              //go low for start bit
    660              SOFT_UART_TX_BIT(0); //go low for start bit
    661              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    662          
    663              //loop over all 8 data bits transmitting each
    664              for (i=0;i<8;i++) {
    665                SOFT_UART_TX_BIT(byte&0x1); //data bit
    666                while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    667                byte = (byte>>1);
    668              }
    669          
    670              SOFT_UART_TX_BIT(1); //stop bit
    671              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    672          
    673              //disable SysTick
    674              ST_CSR = 0;
    675            )
    676          }
    677          #endif //SOFTUART
    678          
    679          #if (EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER)
    680          void usbReleaseBuffer( USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining )
    681          {
    682            assert(status == USB_STATUS_OK);
    683            emberReleaseMessageBuffer(BUFSTATE(3)->holdBuf[0]);
    684            BUFSTATE(3)->holdBuf[0] = EMBER_NULL_MESSAGE_BUFFER;
    685          }
    686          #endif
    687          

   \                                 In section .text, align 2, keep-with-next
    688          void halInternalStartUartTx(uint8_t port)
    689          {
   \                     halInternalStartUartTx: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    690            #if EM_SERIAL0_ENABLED
    691              if (EM_SER0_PORT_EN(port)) {
   \   00000004   0xD113             BNE.N    ??halInternalStartUartTx_0
    692                #if EMBER_SERIAL0_MODE == EMBER_SERIAL_FIFO
    693                  EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[0];
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26_5
   \   0000000A   0x6804             LDR      R4,[R0, #+0]
    694                  assert(q->tail == 0);
   \   0000000C   0x8860             LDRH     R0,[R4, #+2]
   \   0000000E   0xB128             CBZ.N    R0,??halInternalStartUartTx_1
   \   00000010   0xF240 0x21B6      MOVW     R1,#+694
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       halInternalAssertFailed
    695                  emDebugSendVuartMessage(q->fifo, q->used);
   \                     ??halInternalStartUartTx_1: (+1)
   \   0000001C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000001E   0xB2C9             UXTB     R1,R1
   \   00000020   0x1DA0             ADDS     R0,R4,#+6
   \   00000022   0x.... 0x....      BL       emDebugSendVuartMessage
    696                  q->used = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x80A0             STRH     R0,[R4, #+4]
    697                  q->head = 0;
   \   0000002A   0x8020             STRH     R0,[R4, #+0]
    698                  return;
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}
    699                #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_BUFFER
    700                  EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[0];
    701                  assert(q->nextByte == NULL);
    702                  emSerialBufferNextMessageIsr(q);
    703                  while (q->nextByte != NULL) {
    704                    emDebugSendVuartMessage(q->nextByte, (q->lastByte-q->nextByte)+1);
    705                    emSerialBufferNextBlockIsr(q,0);
    706                  }
    707                  return;
    708                #endif
    709              }
    710            #endif//!defined(EM_SERIAL0_DISABLED)
    711          
    712            #if EM_SERIAL1_ENABLED && defined(SOFTUART)
    713              if (EM_SER1_PORT_EN(port)) {
    714                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[1];
    715                // Always configure the bit because other operations might have
    716                // tried to compromise it
    717                SOFT_UART_TX_BIT(1);
    718                CONFIG_SOFT_UART_TX_BIT();
    719                while (q->used > 0) {
    720                  uint8_t byte = FIFO_DEQUEUE(q, emSerialTxQueueWraps[1]);
    721                  softwareUartTxByte(byte);
    722                }
    723                return;
    724              }
    725            #endif
    726          
    727            #if defined(EM_PHYSICAL_UART)
    728              // If the port is configured, go ahead and start transmit
    729              #if defined(EM_ENABLE_SERIAL_FIFO)
    730                if ((EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) &&
    731                    (SCx_REG(port, MODE) == SC1_MODE_UART)) {
   \                     ??halInternalStartUartTx_0: (+1)
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD113             BNE.N    ??halInternalStartUartTx_2
   \   00000032   0x....             LDR.N    R0,??DataTable26_2  ;; 0x4000c854
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD115             BNE.N    ??halInternalStartUartTx_3
    732                  // Ensure UART TX interrupts are enabled,
    733                  // and call the ISR to send any pending output
    734                  ATOMIC(
    735                    // Enable TX interrupts
    736                    INT_SCxCFG(port) |= (INT_SCTXFREE | INT_SCTXIDLE);
    737                    // Pretend we got a tx interrupt
    738                    halInternalUartTxIsr(port);
    739                  )
   \   0000003A   0x.... 0x....      BL       _disableBasePri
   \   0000003E   0x4605             MOV      R5,R0
   \   00000040   0x....             LDR.N    R0,??DataTable26_6  ;; 0x4000a848
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF041 0x0106      ORR      R1,R1,#0x6
   \   00000048   0x6001             STR      R1,[R0, #+0]
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x.... 0x....      BL       halInternalUartTxIsr
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000056   0x.... 0x....      B.W      _writeBasePri
    740                  return;
    741                }
    742              #endif // defined(EM_ENABLE_SERIAL_FIFO)
    743              #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    744                if ((EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) &&
    745                    (SCx_REG(port, MODE) == SC1_MODE_UART)) {
    746                  // Ensure UART TX interrupts are enabled,
    747                  // and call the ISR to send any pending output
    748                  ATOMIC(
    749                    INT_SCxCFG(port) |= (INT_SCTXULDA | INT_SCTXULDB | INT_SCTXIDLE);
    750                    // Pretend we got a tx interrupt
    751                    halInternalUartTxIsr(port);
    752                  )
    753                  return;
    754                }
    755              #endif // defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    756            #endif // EM_PHYSICAL_UART
    757          
    758            // why not buffered mode? --RDM
    759            #if EM_SERIAL3_ENABLED
    760              if (EM_SER3_PORT_EN(port)) {
   \                     ??halInternalStartUartTx_2: (+1)
   \   0000005A   0x2803             CMP      R0,#+3
   \   0000005C   0xBF04             ITT      EQ 
   \   0000005E   0xE8BD 0x4031      POPEQ    {R0,R4,R5,LR}
   \   00000062   0x.... 0x....      BEQ.W    usbTxData
    761                #if defined(CORTEXM3_EM35X_USB)
    762                  #if (EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO)
    763                  usbTxData();
    764                  #else //Must be EMBER_SERIAL_BUFFER
    765                    EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[3];
    766                    assert( !((q->used == 0) && (q->nextByte != NULL)) );
    767                    while ( q->used > 0 ) {
    768                      if ( q->nextByte == NULL ) {
    769                        // new message pending, but nextByte not set up yet
    770                        emSerialBufferNextMessageIsr(q);
    771                      }
    772                      if (!USBD_EpIsBusy(EP_IN))
    773                      {
    774                        USBD_Write( EP_IN, q->nextByte, (uint32_t)q->lastByte - (uint32_t)q->nextByte + 1, (USB_XferCompleteCb_TypeDef) &usbReleaseBuffer );
    775          
    776                        if (BUFSTATE(3)->holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER)
    777                          emberReleaseMessageBuffer(BUFSTATE(3)->holdBuf[0]);
    778                        BUFSTATE(3)->holdBuf[0] = q->currentBuffer;
    779                        emberHoldMessageBuffer(BUFSTATE(3)->holdBuf[0]);
    780                        emSerialBufferNextBlockIsr(q, 3);
    781                      }
    782                      else
    783                      {
    784                        break;
    785                      }
    786                    } // while ( q->used > 0 )
    787                  #endif
    788                  return;
    789                #endif
    790              }
    791            #endif // EM_SERIAL3_ENABLED && EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO
    792          }
   \                     ??halInternalStartUartTx_3: (+1)
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    793          

   \                                 In section .text, align 2, keep-with-next
    794          void halInternalStopUartTx(uint8_t port)
    795          {
    796            // Nothing for port 0 (virtual uart)
    797          
    798            #if defined(EM_PHYSICAL_UART)
    799              #if defined(EM_ENABLE_SERIAL_FIFO)
    800                if (EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) {
   \                     halInternalStopUartTx: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD104             BNE.N    ??halInternalStopUartTx_0
    801                  // Disable TX Interrupts
    802                  INT_SCxCFG(port) &= ~(INT_SCTXFREE | INT_SCTXIDLE);
   \   00000004   0x....             LDR.N    R0,??DataTable26_6  ;; 0x4000a848
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF021 0x0106      BIC      R1,R1,#0x6
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    803                }
    804              #endif // defined(EM_ENABLE_SERIAL_FIFO)
    805              #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    806                if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
    807                  // Ensure DMA operations are complete before shutting off interrupts,
    808                  // otherwise we might miss an important interrupt and cause a
    809                  // packet buffer leak, e.g.
    810                  while (SCx_REG(port, DMACTRL) & (SC_TXLODA | SC_TXLODB)) {}
    811                  while ( !(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) ) {}
    812                  // Disable TX Interrupts
    813                  INT_SCxCFG(port) &= ~(INT_SCTXULDA | INT_SCTXULDB | INT_SCTXIDLE);
    814                }
    815              #endif // defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    816            #endif // defined(EM_PHYSICAL_UART)
    817          }
   \                     ??halInternalStopUartTx_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    818          
    819          
    820          //full blocking, no queue overflow issues, can be used in or out of int context
    821          //does not return until character is transmitted.

   \                                 In section .text, align 2, keep-with-next
    822          EmberStatus halInternalForceWriteUartData(uint8_t port, uint8_t *data, uint8_t length)
    823          {
   \                     halInternalForceWriteUartData: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x460B             MOV      R3,R1
   \   00000004   0x4611             MOV      R1,R2
    824            #if EM_SERIAL0_ENABLED
    825              if (EM_SER0_PORT_EN(port)) {
   \   00000006   0xB920             CBNZ.N   R0,??halInternalForceWriteUartData_0
    826                emDebugSendVuartMessage(data, length);
   \   00000008   0x4618             MOV      R0,R3
   \   0000000A   0x.... 0x....      BL       emDebugSendVuartMessage
    827                return EMBER_SUCCESS;
   \                     ??halInternalForceWriteUartData_1: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}
    828              }
    829            #endif
    830          
    831            #ifdef SOFTUART
    832              if (EM_SER1_PORT_EN(port)) {
    833                //always configure the bit because other operations might have
    834                //tried to compromise it
    835                SOFT_UART_TX_BIT(1);
    836                CONFIG_SOFT_UART_TX_BIT();
    837                while (length--) {
    838                  SC1_DATA = *data; // why is the soft UART using the physical UART? --RDM
    839                  softwareUartTxByte(*data);
    840                  data++;
    841                }
    842                return EMBER_SUCCESS;
    843              }
    844            #endif
    845          
    846            #if defined(EM_PHYSICAL_UART)
    847              //if the port is configured, go ahead and transmit
    848              if ((EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) &&
    849                  (SCx_REG(port, MODE) == SC1_MODE_UART)) {
   \                     ??halInternalForceWriteUartData_0: (+1)
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD114             BNE.N    ??halInternalForceWriteUartData_2
   \   00000016   0x....             LDR.N    R0,??DataTable26_7  ;; 0x4000c83c
   \   00000018   0x6982             LDR      R2,[R0, #+24]
   \   0000001A   0x2A01             CMP      R2,#+1
   \   0000001C   0xD007             BEQ.N    ??halInternalForceWriteUartData_3
    850                while (length--) {
    851                  //spin until data register has room for more data
    852                  while (!(SCx_REG(port, UARTSTAT) & SC_UARTTXFREE)) {}
    853                  SCx_REG(port, DATA) = *data;
    854                  data++;
    855                }
    856          
    857                //spin until TX complete (TX is idle)
    858                while (!(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE)) {}
    859          
    860                return EMBER_SUCCESS;
    861              }
    862            #endif // defined(EM_PHYSICAL_UART)
    863          
    864            #if EM_SERIAL3_ENABLED
    865              if (EM_SER3_PORT_EN(port)) {
    866                #if defined(CORTEXM3_EM35X_USB)
    867                  //This function will block until done sending all the data.
    868                  usbForceTxData(data, length);
    869                  return EMBER_SUCCESS;
    870                #endif
    871              }
    872            #endif // EM_SERIAL3_ENABLED
    873          
    874            return EMBER_SERIAL_INVALID_PORT;
   \                     ??halInternalForceWriteUartData_4: (+1)
   \   0000001E   0x2021             MOVS     R0,#+33
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
   \                     ??halInternalForceWriteUartData_5: (+1)
   \   00000022   0x68C2             LDR      R2,[R0, #+12]
   \   00000024   0x0752             LSLS     R2,R2,#+29
   \   00000026   0xD5FC             BPL.N    ??halInternalForceWriteUartData_5
   \   00000028   0xF813 0x2B01      LDRB     R2,[R3], #+1
   \   0000002C   0x6002             STR      R2,[R0, #+0]
   \                     ??halInternalForceWriteUartData_3: (+1)
   \   0000002E   0x460A             MOV      R2,R1
   \   00000030   0x1E51             SUBS     R1,R2,#+1
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x2A00             CMP      R2,#+0
   \   00000036   0xD1F4             BNE.N    ??halInternalForceWriteUartData_5
   \                     ??halInternalForceWriteUartData_6: (+1)
   \   00000038   0x68C1             LDR      R1,[R0, #+12]
   \   0000003A   0x0649             LSLS     R1,R1,#+25
   \   0000003C   0xD5FC             BPL.N    ??halInternalForceWriteUartData_6
   \   0000003E   0xE7E6             B.N      ??halInternalForceWriteUartData_1
   \                     ??halInternalForceWriteUartData_2: (+1)
   \   00000040   0x2803             CMP      R0,#+3
   \   00000042   0xD1EC             BNE.N    ??halInternalForceWriteUartData_4
   \   00000044   0x4618             MOV      R0,R3
   \   00000046   0x.... 0x....      BL       usbForceTxData
   \   0000004A   0xE7E0             B.N      ??halInternalForceWriteUartData_1
    875          }
    876          
    877          // Useful for waiting on serial port characters before interrupts have been
    878          // turned on.

   \                                 In section .text, align 2, keep-with-next
    879          EmberStatus halInternalForceReadUartByte(uint8_t port, uint8_t* dataByte)
    880          {
   \                     halInternalForceReadUartByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
    881            EmberStatus err = EMBER_SUCCESS;
   \   00000006   0x2500             MOVS     R5,#+0
    882          
    883            #if EM_SERIAL0_ENABLED
    884              if (EM_SER0_PORT_EN(port)) {
   \   00000008   0xB9F6             CBNZ.N   R6,??halInternalForceReadUartByte_0
    885                EmSerialFifoQueue *q = emSerialRxQueues[0];
   \   0000000A   0x....             LDR.N    R0,??DataTable26_8
   \   0000000C   0x6807             LDR      R7,[R0, #+0]
    886                ATOMIC(
    887                  if (q->used == 0) {
    888                    WAKE_CORE = WAKE_CORE_FIELD;
    889                  }
    890                  if (q->used > 0) {
    891                    *dataByte = FIFO_DEQUEUE(q, emSerialRxQueueWraps[0]);
    892                  } else {
    893                    err = EMBER_SERIAL_RX_EMPTY;
    894                  }
    895                )
   \   0000000E   0x.... 0x....      BL       _disableBasePri
   \   00000012   0x88B9             LDRH     R1,[R7, #+4]
   \   00000014   0xB911             CBNZ.N   R1,??halInternalForceReadUartByte_1
   \   00000016   0x....             LDR.N    R2,??DataTable26_9  ;; 0x40000024
   \   00000018   0x2120             MOVS     R1,#+32
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   \                     ??halInternalForceReadUartByte_1: (+1)
   \   0000001C   0x88B9             LDRH     R1,[R7, #+4]
   \   0000001E   0xB181             CBZ.N    R1,??halInternalForceReadUartByte_2
   \   00000020   0x8879             LDRH     R1,[R7, #+2]
   \   00000022   0x....             LDR.N    R2,??DataTable26_10
   \   00000024   0x19C9             ADDS     R1,R1,R7
   \   00000026   0x7989             LDRB     R1,[R1, #+6]
   \   00000028   0x7021             STRB     R1,[R4, #+0]
   \   0000002A   0x8879             LDRH     R1,[R7, #+2]
   \   0000002C   0x8812             LDRH     R2,[R2, #+0]
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   00000034   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   00000038   0x8079             STRH     R1,[R7, #+2]
   \   0000003A   0x88B9             LDRH     R1,[R7, #+4]
   \   0000003C   0x1E49             SUBS     R1,R1,#+1
   \   0000003E   0x80B9             STRH     R1,[R7, #+4]
   \   00000040   0xE000             B.N      ??halInternalForceReadUartByte_3
   \                     ??halInternalForceReadUartByte_2: (+1)
   \   00000042   0x2526             MOVS     R5,#+38
   \                     ??halInternalForceReadUartByte_3: (+1)
   \   00000044   0x.... 0x....      BL       _writeBasePri
    896              }
    897            #endif // EM_SERIAL0_ENABLED
    898          
    899            #if defined(EM_PHYSICAL_UART)
    900              #if defined(EM_ENABLE_SERIAL_FIFO)
    901                if (EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) {
   \                     ??halInternalForceReadUartByte_0: (+1)
   \   00000048   0x2E01             CMP      R6,#+1
   \   0000004A   0xD106             BNE.N    ??halInternalForceReadUartByte_4
    902                  if (SCx_REG(port, UARTSTAT) & SC_UARTRXVAL) {
   \   0000004C   0x....             LDR.N    R0,??DataTable26_7  ;; 0x4000c83c
   \   0000004E   0x68C1             LDR      R1,[R0, #+12]
   \   00000050   0x0789             LSLS     R1,R1,#+30
   \   00000052   0xBF46             ITTE     MI 
   \   00000054   0x6800             LDRMI    R0,[R0, #+0]
   \   00000056   0x7020             STRBMI   R0,[R4, #+0]
   \   00000058   0x2526             MOVPL    R5,#+38
    903                    *dataByte = (uint8_t) SCx_REG(port, DATA);
    904                  } else {
    905                    err = EMBER_SERIAL_RX_EMPTY;
    906                  }
    907                }
    908              #endif
    909              #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    910                if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
    911                  //When in buffer mode, the DMA channel is active and the RXVALID bit (as
    912                  //used above in FIFO mode) will never get set.  To maintain the DMA/Buffer
    913                  //model of operation, we need to break the conceptual model in this function
    914                  //and make a function call upwards away from the hardware.  The ReadByte
    915                  //function calls back down into halInternalUartRxPump and forces the
    916                  //sequencing of the serial queues and the DMA buffer, resulting in a forced
    917                  //read byte being returned if it is there.
    918                  if (emberSerialReadByte(port, dataByte) != EMBER_SUCCESS) {
    919                    err = EMBER_SERIAL_RX_EMPTY;
    920                  }
    921                }
    922              #endif // defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    923            #endif // defined(EM_PHYSICAL_UART)
    924          
    925            return err;
   \                     ??halInternalForceReadUartByte_4: (+1)
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    926          }
    927          
    928          // blocks until the text actually goes out

   \                                 In section .text, align 2, keep-with-next
    929          void halInternalWaitUartTxComplete(uint8_t port)
    930          {
   \                     halInternalWaitUartTxComplete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    931            halResetWatchdog();
   \   00000004   0x.... 0x....      BL       halInternalResetWatchDog
    932          
    933            // Nothing to do for port 0 (virtual uart)
    934          
    935            #if defined(EM_PHYSICAL_UART)
    936            if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD103             BNE.N    ??halInternalWaitUartTxComplete_0
    937                while ( !(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) ) {}
   \                     ??halInternalWaitUartTxComplete_1: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable26_11  ;; 0x4000c848
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0640             LSLS     R0,R0,#+25
   \   00000012   0xD5FB             BPL.N    ??halInternalWaitUartTxComplete_1
    938                return;
    939              }
    940            #endif // defined(EM_PHYSICAL_UART)
    941          }
   \                     ??halInternalWaitUartTxComplete_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    942          
    943          // Debug Channel calls this ISR to push up data it has received

   \                                 In section .text, align 2, keep-with-next
    944          void halStackReceiveVuartMessage(uint8_t *data, uint8_t length)
    945          {
   \                     halStackReceiveVuartMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    946            #if EM_SERIAL0_ENABLED
    947              EmSerialFifoQueue *q = emSerialRxQueues[0];
   \   00000002   0x....             LDR.N    R2,??DataTable26_8
   \   00000004   0x....             LDR.N    R3,??DataTable26_10
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xE004             B.N      ??CrossCallReturnLabel_0
    948          
    949              while (length--) {
    950                //Use (emSerialRxQueueSizes - 1) so that the FIFO never completely fills
    951                //and the head never wraps around to the tail
    952                if ((q->used < (emSerialRxQueueSizes[0] - 1))) {
    953                  FIFO_ENQUEUE(q,*data++,emSerialRxQueueWraps[0]);
   \                     ??halStackReceiveVuartMessage_0: (+1)
   \   0000000A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000000E   0x881D             LDRH     R5,[R3, #+0]
   \   00000010   0x.... 0x....      BL       ?Subroutine0
    954                } else {
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000014   0x460C             MOV      R4,R1
   \   00000016   0x1E61             SUBS     R1,R4,#+1
   \   00000018   0xB2E4             UXTB     R4,R4
   \   0000001A   0xB154             CBZ.N    R4,??halStackReceiveVuartMessage_1
   \   0000001C   0x8894             LDRH     R4,[R2, #+4]
   \   0000001E   0x....             LDR.N    R5,??DataTable26_12
   \   00000020   0x882D             LDRH     R5,[R5, #+0]
   \   00000022   0x1E6D             SUBS     R5,R5,#+1
   \   00000024   0x42AC             CMP      R4,R5
   \   00000026   0xDBF0             BLT.N    ??halStackReceiveVuartMessage_0
    955                  uartErrorMark(0, EMBER_SERIAL_RX_OVERFLOW);
   \   00000028   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002C   0x2123             MOVS     R1,#+35
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             B.N      uartErrorMark
    956                  return;  // no sense in trying to enqueue the rest
    957                }
    958              }
    959            #endif // EM_SERIAL0_ENABLED
    960          }
   \                     ??halStackReceiveVuartMessage_1: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x8815             LDRH     R5,[R2, #+0]
   \   00000002   0xF810 0x4B01      LDRB     R4,[R0], #+1
   \   00000006   0x18AD             ADDS     R5,R5,R2
   \   00000008   0x71AC             STRB     R4,[R5, #+6]
   \   0000000A   0x8814             LDRH     R4,[R2, #+0]
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x1C64             ADDS     R4,R4,#+1
   \   00000002   0xFB94 0xF6F5      SDIV     R6,R4,R5
   \   00000006   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   0000000A   0x8014             STRH     R4,[R2, #+0]
   \   0000000C   0x8894             LDRH     R4,[R2, #+4]
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \   00000010   0x8094             STRH     R4,[R2, #+4]
   \   00000012   0x4770             BX       LR
    961          
    962          #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
    963          static void halInternalRestartUartDma(uint8_t port)
    964          {
    965            //Reset the DMA software and restart it.
    966            EmSerialFifoQueue *q = emSerialRxQueues[port];
    967            uint32_t startAddress = (uint32_t)q->fifo;
    968            uint8_t head;
    969            uint8_t tail;
    970            uint8_t loadA = 0;
    971            uint8_t loadB = 0;
    972            BUFSTATE(port)->prevCountA = 0;
    973            BUFSTATE(port)->prevCountB = 0;
    974            BUFSTATE(port)->waitingForTailA = false;
    975            BUFSTATE(port)->waitingForTailB = false;
    976            BUFSTATE(port)->waitingForInputToB = false;
    977            //reload all defaults addresses - they will be adjusted below if needed
    978            SCx_REG(port, DMACTRL) = SC_RXDMARST;
    979            SCx_REG(port, RXBEGA) =  startAddress;
    980            SCx_REG(port, RXENDA) = (startAddress + BUFSTATE(port)->fifoSize/2 - 1);
    981            SCx_REG(port, RXBEGB) =  (startAddress + BUFSTATE(port)->fifoSize/2);
    982            SCx_REG(port, RXENDB) = (startAddress + BUFSTATE(port)->fifoSize - 1);
    983          
    984            //adjust buffer addresses as needed and reload available buffers
    985            if ( q->used != BUFSTATE(port)->fifoSize ) {
    986              //we can only reload if the FIFO isn't full!
    987              //the FIFO is not empty or full, figure out what to do:
    988              //at this point we know we always have to adjust ST_ADDR to the head
    989              //we need to know which buffer the head is in, and always load that buff
    990              if ((q->head) < BUFSTATE(port)->rxStartIndexB) {
    991                SCx_REG(port, RXBEGA) = startAddress + (q->head);
    992                loadA++;
    993              } else {
    994                SCx_REG(port, RXBEGB) = startAddress + (q->head);
    995                loadB++;
    996              }
    997              //check to see if the head and the tail are not in the same buffer
    998              if((q->tail)/(BUFSTATE(port)->rxStartIndexB)) {
    999                tail = true;  //Tail in B buffer
   1000              } else {
   1001                tail = false; //Tail in A buffer
   1002              }
   1003          
   1004              if((q->head)/(BUFSTATE(port)->rxStartIndexB)) {
   1005                head = true;  //Head in B buffer
   1006              } else {
   1007                head = false; //Head in A buffer
   1008              }
   1009          
   1010              if ( tail != head ) {
   1011                //the head and the tail are in different buffers
   1012                //we need to flag the buffer the tail is in so the Pump function does
   1013                //not try to reenable it until it has been drained like normal.
   1014                if ((q->tail)<BUFSTATE(port)->rxStartIndexB) {
   1015                  BUFSTATE(port)->waitingForTailA = true;
   1016                } else {
   1017                  BUFSTATE(port)->waitingForTailB = true;
   1018                }
   1019              } else {
   1020                //the head and the tail are in the same buffers
   1021                if (q->used <= BUFSTATE(port)->rxStartIndexB) {
   1022                  //The serial FIFO is less no more than half full!
   1023                  if (!loadB) {
   1024                    //the head is in B, and we're capable of loading A
   1025                    //BUT: we can't activate A because the DMA defaults to A first,
   1026                    //  and it needs to start using B first to fill from the head
   1027                    //  SO, only load A if B hasn't been marked yet for loading.
   1028                    loadA++;
   1029                  } else {
   1030                    //B is loaded and waiting for data, A is being supressed until
   1031                    //B receives at least one byte so A doesn't prematurely load and
   1032                    //steal bytes meant for B first.
   1033                    BUFSTATE(port)->waitingForTailA = true;
   1034                    BUFSTATE(port)->waitingForInputToB = true;
   1035                  }
   1036                  //We can always loadB at this point thanks to our waiting* flags.
   1037                  loadB++;
   1038                } else {
   1039                  //The serial FIFO is more than half full!
   1040                  //Since this case requires moving an end address of a buffer, which
   1041                  //severely breaks DMA'ing into a FIFO, we cannot do anything.
   1042                  //Doing nothing is ok because we are more than half full anyways,
   1043                  //and under normal operation we would only load a buffer when our
   1044                  //used count is less than half full.
   1045                  //Configure so the Pump function takes over when the serial FIFO drains
   1046                  SCx_REG(port, RXBEGA) =  startAddress;
   1047                  SCx_REG(port, RXBEGB) =  (startAddress + BUFSTATE(port)->fifoSize/2);
   1048                  loadA = 0;
   1049                  loadB = 0;
   1050                  BUFSTATE(port)->waitingForTailA = true;
   1051                  BUFSTATE(port)->waitingForTailB = true;
   1052                }
   1053              }
   1054          
   1055              //Address are set, flags are set, DMA is ready, so now we load buffers
   1056              if (loadA) {
   1057                SCx_REG(port, DMACTRL) = SC_RXLODA;
   1058              }
   1059              if (loadB) {
   1060                SCx_REG(port, DMACTRL) = SC_RXLODB;
   1061              }
   1062            } else {
   1063              //we're full!!  doh!  have to wait for the FIFO to drain
   1064              BUFSTATE(port)->waitingForTailA = true;
   1065              BUFSTATE(port)->waitingForTailB = true;
   1066            }
   1067          }
   1068          #endif // defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
   1069          
   1070          #ifdef EM_PHYSICAL_UART

   \                                 In section .text, align 2, keep-with-next
   1071          void halInternalUartRxIsr(uint8_t port, uint16_t causes)
   1072          {
   \                     halInternalUartRxIsr: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   1073            #if defined(EM_ENABLE_SERIAL_FIFO)
   1074              if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
   1075                EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000006   0x....             LDR.N    R0,??DataTable26_8
   \   00000008   0x.... 0x....      LDR.W    R9,??DataTable26_10
   \   0000000C   0x.... 0x....      LDR.W    R8,??DataTable26_12
   \   00000010   0x....             LDR.N    R7,??DataTable26_7  ;; 0x4000c83c
   \   00000012   0x4625             MOV      R5,R4
   \   00000014   0xF850 0x6025      LDR      R6,[R0, R5, LSL #+2]
   \   00000018   0xE014             B.N      ??halInternalUartRxIsr_0
   1076          
   1077                // At present we really don't care which interrupt(s)
   1078                // occurred, just that one did.  Loop reading RXVALID
   1079                // data (loop is necessary for bursty data otherwise
   1080                // we could leave with RXVALID and not get another
   1081                // RXVALID interrupt), processing any errors noted
   1082                // along the way.
   1083                while ( SCx_REG(port, UARTSTAT) & SC_UARTRXVAL ) {
   1084                  uint8_t errors = SCx_REG(port, UARTSTAT) & (SC_UARTFRMERR |
   1085                                                 SC_UARTRXOVF  |
   1086                                                 SC_UARTPARERR );
   1087                  uint8_t incoming = (uint8_t) SCx_REG(port, DATA);
   1088          #if     (CORTEXM3_EM35X_GEN3 && defined(ENABLE_OSC24M) && (ENABLE_OSC24M != 24) \
   1089                   && (ENABLE_OSC24M != 24000) && (ENABLE_OSC24M != 24000000))
   1090                  // Hack workaround for EMLIPARI-101 UART HW bug on non-24 MHz SysClk
   1091                  static bool uartFixTried = false;
   1092                  if ( (errors & SC_UARTFRMERR) && (incoming != 0 /* a BRK */) ) {
   1093                    if (!uartFixTried) {
   1094                      // Try to correct for this HW bug by inverting fraction bit
   1095                      SCx_REG(port, UARTFRAC) = !SCx_REG(port, UARTFRAC);
   1096                      uartFixTried = true;
   1097                    }
   1098                    incoming >>= 1;
   1099                    errors &= ~SC_UARTFRMERR;
   1100                  }
   1101          #endif//(CORTEXM3_EM35X_GEN3 && defined(ENABLE_OSC24M) && ...)
   1102          
   1103                  if ( (errors == 0) && (q->used < (emSerialRxQueueSizes[port]-1)) ) {
   \                     ??halInternalUartRxIsr_1: (+1)
   \   0000001A   0x88B1             LDRH     R1,[R6, #+4]
   \   0000001C   0xF838 0x2015      LDRH     R2,[R8, R5, LSL #+1]
   \   00000020   0x1E52             SUBS     R2,R2,#+1
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xDA1C             BGE.N    ??halInternalUartRxIsr_2
   1104          #ifdef EMBER_SERIAL1_XONXOFF
   1105                    if (EM_SER1_PORT_FIFO(port)) {
   1106                      // Discard any XON or XOFF bytes received
   1107                      if ( (incoming != ASCII_XON) && (incoming != ASCII_XOFF) ) {
   1108                        FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   1109                      }
   1110                    } else {
   1111                      FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   1112                    }
   1113          #else
   1114                    FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   \   00000026   0x8831             LDRH     R1,[R6, #+0]
   \   00000028   0x1989             ADDS     R1,R1,R6
   \   0000002A   0x7188             STRB     R0,[R1, #+6]
   \   0000002C   0x8830             LDRH     R0,[R6, #+0]
   \   0000002E   0xF839 0x1015      LDRH     R1,[R9, R5, LSL #+1]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000038   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000003C   0x8030             STRH     R0,[R6, #+0]
   \   0000003E   0x88B0             LDRH     R0,[R6, #+4]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x80B0             STRH     R0,[R6, #+4]
   1115          #endif
   1116                  } else {
   \                     ??halInternalUartRxIsr_0: (+1)
   \   00000044   0x68F8             LDR      R0,[R7, #+12]
   \   00000046   0x0780             LSLS     R0,R0,#+30
   \   00000048   0xD516             BPL.N    ??halInternalUartRxIsr_3
   \   0000004A   0x68F8             LDR      R0,[R7, #+12]
   \   0000004C   0xF010 0x0138      ANDS     R1,R0,#0x38
   \   00000050   0x6838             LDR      R0,[R7, #+0]
   \   00000052   0xD0E2             BEQ.N    ??halInternalUartRxIsr_1
   1117                    // Translate error code
   1118                    if ( errors == 0 ) {
   1119                      errors = EMBER_SERIAL_RX_OVERFLOW;
   1120                      HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERFLOW_ERROR);
   1121                    } else if ( errors & SC_UARTRXOVF ) {
   \   00000054   0x0708             LSLS     R0,R1,#+28
   \   00000056   0xD405             BMI.N    ??halInternalUartRxIsr_4
   1122                      errors = EMBER_SERIAL_RX_OVERRUN_ERROR;
   1123                      HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERRUN_ERROR);
   1124                    } else if ( errors & SC_UARTFRMERR ) {
   \   00000058   0x06C8             LSLS     R0,R1,#+27
   \   0000005A   0xD505             BPL.N    ??halInternalUartRxIsr_5
   1125                      errors = EMBER_SERIAL_RX_FRAME_ERROR;
   \   0000005C   0x2124             MOVS     R1,#+36
   \   0000005E   0xE007             B.N      ??halInternalUartRxIsr_6
   1126                      HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_FRAMING_ERROR);
   1127                    } else if ( errors & SC_UARTPARERR ) {
   \                     ??halInternalUartRxIsr_2: (+1)
   \   00000060   0x2123             MOVS     R1,#+35
   \   00000062   0xE005             B.N      ??halInternalUartRxIsr_6
   \                     ??halInternalUartRxIsr_4: (+1)
   \   00000064   0x2127             MOVS     R1,#+39
   \   00000066   0xE003             B.N      ??halInternalUartRxIsr_6
   \                     ??halInternalUartRxIsr_5: (+1)
   \   00000068   0x0688             LSLS     R0,R1,#+26
   \   0000006A   0xBF4C             ITE      MI 
   \   0000006C   0x2125             MOVMI    R1,#+37
   \   0000006E   0x2101             MOVPL    R1,#+1
   1128                      errors = EMBER_SERIAL_RX_PARITY_ERROR;
   1129                    } else { // unknown
   1130                      errors = EMBER_ERR_FATAL;
   1131                    }
   1132                    uartErrorMark(port, errors);
   \                     ??halInternalUartRxIsr_6: (+1)
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       uartErrorMark
   \   00000076   0xE7E5             B.N      ??halInternalUartRxIsr_0
   1133                  }
   1134          #ifdef EMBER_SERIAL1_XONXOFF
   1135                  if (EM_SER1_PORT_FIFO(port) &&
   1136                      (q->used >= XOFF_LIMIT) && (xcmdCount >= 0))  {
   1137                    xonXoffTxByte = ASCII_XOFF;
   1138                    halInternalStartUartTx(1);
   1139                  }
   1140          #endif
   1141                } // end of while ( SC1_UARTSTAT & SC1_UARTRXVAL )
   1142              }
   1143            #endif
   1144          
   1145            #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
   1146              if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
   1147              #ifdef EMBER_SERIAL1_RTSCTS
   1148                // TODO this flow control will fail if port 2 is active
   1149                // If RTS is controlled by sw, this ISR is called when a buffer unloads.
   1150                if (causes & (INT_SCRXULDA | INT_SCRXULDB)) {
   1151                  // Deassert RTS if the rx queue tail is not in an active DMA buffer:
   1152                  // if it is, then there's at least one empty DMA buffer
   1153                  if ( !( (emSerialRxQueues[port]->tail < emSerialRxQueueSizes[port]/2) &&
   1154                         (SCx_REG(port, DMASTAT) & SC_RXACTA) ) &&
   1155                       !( (emSerialRxQueues[port]->tail >= emSerialRxQueueSizes[port]/2)
   1156                          && (SCx_REG(port, DMASTAT) & SC_RXACTB) ) ) {
   1157                    SCx_REG(port, UARTCFG) &= ~SC_UARTRTS;        // deassert RTS
   1158                  }
   1159                #ifdef EZSP_UART
   1160                  // TODO fix EZSP_UART
   1161                  if ( ( (causes & INT_SCRXULDA) && (SC1_DMASTAT & SC_RXOVFA) ) ||
   1162                       ( (causes & INT_SCRXULDB) && (SC1_DMASTAT & SC_RXOVFB) ) ) {
   1163                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERFLOW_ERROR);
   1164                  }
   1165                  if ( ( (causes & INT_SCRXULDA) && (SC1_DMASTAT & SC_RXFRMA) ) ||
   1166                       ( (causes & INT_SCRXULDB) && (SC1_DMASTAT & SC_RXFRMB) ) ) {
   1167                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_FRAMING_ERROR);
   1168                  }
   1169                #else//!EZSP_UART
   1170                  causes &= ~(INT_SCRXULDA | INT_SCRXULDB);
   1171                  if (causes == 0) { // if no errors in addition, all done
   1172                    return;
   1173                  }
   1174                #endif//EZSP_UART
   1175                }
   1176              #endif  //#ifdef EMBER_SERIAL1_RTSCTS
   1177              #ifndef EZSP_UART
   1178              //Load all of the hardware status, then immediately reset so we can process
   1179              //what happened without worrying about new data changing these values.
   1180              //We're in an error condition anyways, so it is ok to have the DMA disabled
   1181              //for a while (less than 80us, while 4 bytes @ 115.2kbps is 350us)
   1182              {
   1183                EmSerialFifoQueue *q = emSerialRxQueues[port];
   1184                uint16_t status  = SCx_REG(port, DMASTAT);
   1185                uint16_t errCntA = SCx_REG(port, RXERRA);
   1186                uint16_t errCntB = SCx_REG(port, RXERRB);
   1187                uint32_t errorIdx = emSerialRxQueueSizes[port]*2;
   1188                uint32_t tempIdx;
   1189                uint32_t startAddress = (uint32_t)q->fifo;
   1190          
   1191                //interrupts acknowledged at the start of the master SC1 ISR
   1192                uint16_t intSrc  = causes;
   1193                uint8_t errorType = EMBER_SUCCESS;
   1194          
   1195                SCx_REG(port, DMACTRL) = SC_RXDMARST;  //to clear error
   1196                //state fully captured, DMA reset, now we process error and restart
   1197          
   1198                if ( intSrc & INT_SCRXOVF ) {
   1199                  //Read the data register four times to clear
   1200                  //the RXOVERRUN condition and empty the FIFO, giving us 4 bytes
   1201                  //worth of time (from this point) to reenable the DMA.
   1202                  (void) SCx_REG(port, DATA);
   1203                  (void) SCx_REG(port, DATA);
   1204                  (void) SCx_REG(port, DATA);
   1205                  (void) SCx_REG(port, DATA);
   1206          
   1207                  if ( status & ( SC_RXFRMA
   1208                               | SC_RXFRMB
   1209                               | SC_RXPARA
   1210                               | SC_RXPARB ) ) {
   1211                    //We just emptied hardware FIFO so the overrun condition is cleared.
   1212                    //Byte errors require special handling to roll back the serial FIFO.
   1213                    goto dealWithByteError;
   1214                  }
   1215          
   1216                //record the error type
   1217                emSerialRxError[port] = EMBER_SERIAL_RX_OVERRUN_ERROR;
   1218          
   1219                //check for a retriggering of the Rx overflow, don't advance FIFO if so
   1220                if ( !(BUFSTATE(port)->waitingForTailA && BUFSTATE(port)->waitingForTailB) ) {
   1221                  //first, move head to end of buffer head is in
   1222                  //second, move head to end of other buffer if tail is not in other buffer
   1223                  if ((q->head)<BUFSTATE(port)->rxStartIndexB) {
   1224                    //head inside A
   1225                    q->used += (BUFSTATE(port)->rxStartIndexB - q->head);
   1226                    q->head = (BUFSTATE(port)->rxStartIndexB);
   1227                    if ((q->tail)<BUFSTATE(port)->rxStartIndexB) {
   1228                      //tail not inside of B
   1229                      q->used += BUFSTATE(port)->rxStartIndexB;
   1230                      q->head = 0;
   1231                    }
   1232                  } else {
   1233                    //head inside B
   1234                    q->used += (BUFSTATE(port)->fifoSize - q->head);
   1235                    q->head = 0;
   1236                    if ((q->tail)>=BUFSTATE(port)->rxStartIndexB) {
   1237                      //tail is not inside of A
   1238                      q->used += BUFSTATE(port)->rxStartIndexB;
   1239                      q->head = BUFSTATE(port)->rxStartIndexB;
   1240                    }
   1241                  }
   1242                }
   1243          
   1244                //Record the error position in the serial FIFO
   1245                if (q->used != BUFSTATE(port)->fifoSize) {
   1246                  //mark the byte at q->head as the error
   1247                  emSerialRxErrorIndex[port] = q->head;
   1248                } else {
   1249                  //Since the FIFO is full, the error index needs special handling
   1250                  //so there is no conflict between the head and tail looking at the same
   1251                  //index which needs to be marked as an error.
   1252                  emSerialRxErrorIndex[port] = RX_FIFO_FULL;
   1253                }
   1254          
   1255                //By now the error is accounted for and the DMA hardware is reset.
   1256                //By definition, the overrun error means we have no room left, therefore
   1257                //we can't reenable the DMA.  Reset the previous counter states, and set
   1258                //the waitingForTail flags to true - this tells the Pump function we have
   1259                //data to process.  The Pump function will reenable the buffers as they
   1260                //become available, just like normal.
   1261                BUFSTATE(port)->prevCountA = 0;
   1262                BUFSTATE(port)->prevCountB = 0;
   1263                BUFSTATE(port)->waitingForInputToB = false;
   1264                BUFSTATE(port)->waitingForTailA = true;
   1265                BUFSTATE(port)->waitingForTailB = true;
   1266                //from this point we fall through to the end of the Isr and return.
   1267          
   1268                } else {
   1269                dealWithByteError:
   1270                  //We have a byte error to deal with and possibly more than one byte error,
   1271                  //of different types in different DMA buffers, so check each error flag.
   1272                  //All four error checks translate the DMA buffer's error position to their
   1273                  //position in the serial FIFO, and compares the error locations to find
   1274                  //the first error to occur after the head of the FIFO.  This error is the
   1275                  //error condition that is stored and operated on.
   1276                  if ( status & SC_RXFRMA ) {
   1277                    tempIdx = errCntA;
   1278                    if (tempIdx < q->head) {
   1279                      tempIdx += BUFSTATE(port)->fifoSize;
   1280                    }
   1281                    if (tempIdx<errorIdx) {
   1282                      errorIdx = tempIdx;
   1283                    }
   1284                    errorType = EMBER_SERIAL_RX_FRAME_ERROR;
   1285                  }
   1286                  if ( status & SC_RXFRMB ) {
   1287                    tempIdx = (errCntB + SCx_REG(port, RXBEGB)) - startAddress;
   1288                    if (tempIdx < q->head) {
   1289                      tempIdx += BUFSTATE(port)->fifoSize;
   1290                    }
   1291                    if (tempIdx<errorIdx) {
   1292                      errorIdx = tempIdx;
   1293                    }
   1294                    errorType = EMBER_SERIAL_RX_FRAME_ERROR;
   1295                  }
   1296                  if ( status & SC_RXPARA ) {
   1297                    tempIdx = errCntA;
   1298                    if (tempIdx < q->head) {
   1299                      tempIdx += BUFSTATE(port)->fifoSize;
   1300                    }
   1301                    if (tempIdx<errorIdx) {
   1302                      errorIdx = tempIdx;
   1303                    }
   1304                    errorType = EMBER_SERIAL_RX_PARITY_ERROR;
   1305                  }
   1306                  if ( status & SC_RXPARB ) {
   1307                    tempIdx = (errCntB + SCx_REG(port, RXBEGB)) - startAddress;
   1308                    if (tempIdx < q->head) {
   1309                      tempIdx += BUFSTATE(port)->fifoSize;
   1310                    }
   1311                    if (tempIdx<errorIdx) {
   1312                      errorIdx = tempIdx;
   1313                    }
   1314                    errorType = EMBER_SERIAL_RX_PARITY_ERROR;
   1315                  }
   1316          
   1317                  //We now know the type and location of the first error.
   1318                  //Move up to the error location and increase the used count.
   1319                  q->head = (errorIdx % BUFSTATE(port)->fifoSize);
   1320                  if (q->head < q->tail) {
   1321                    q->used = ((q->head + BUFSTATE(port)->fifoSize) - q->tail);
   1322                  } else {
   1323                    q->used = (q->head - q->tail);
   1324                  }
   1325          
   1326                  //Mark the byte at q->head as the error
   1327                  emSerialRxError[port] = errorType;
   1328                  if (q->used != BUFSTATE(port)->fifoSize) {
   1329                    //mark the byte at q->head as the error
   1330                    emSerialRxErrorIndex[port] = q->head;
   1331                  } else {
   1332                    //Since the FIFO is full, the error index needs special handling
   1333                    //so there is no conflict between the head and tail looking at the same
   1334                    //index which needs to be marked as an error.
   1335                    emSerialRxErrorIndex[port] = RX_FIFO_FULL;
   1336                  }
   1337          
   1338                  //By now the error is accounted for and the DMA hardware is reset.
   1339                  halInternalRestartUartDma(port);
   1340                }
   1341              }
   1342              #endif // #ifndef EZSP_UART
   1343              }
   1344            #endif //(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1345          }
   \                     ??halInternalUartRxIsr_3: (+1)
   \   00000078   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1346          #endif//!defined(EM_SERIAL1_DISABLED)
   1347          
   1348          
   1349          #if EM_SERIAL3_ENABLED

   \                                 In section .text, align 2, keep-with-next
   1350            void halInternalUart3RxIsr(uint8_t *rxData, uint8_t length)
   1351            {
   \                     halInternalUart3RxIsr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1352              EmSerialFifoQueue *q = emSerialRxQueues[3];
   \   00000002   0x....             LDR.N    R2,??DataTable26_8
   \   00000004   0x....             LDR.N    R3,??DataTable26_10
   \   00000006   0x68D2             LDR      R2,[R2, #+12]
   \   00000008   0xE004             B.N      ??CrossCallReturnLabel_1
   1353          
   1354              while(length--) {
   1355                if(q->used < (EMBER_SERIAL3_RX_QUEUE_SIZE-1)) {
   1356                  FIFO_ENQUEUE(q, *rxData, emSerialRxQueueWraps[3]);
   \                     ??halInternalUart3RxIsr_0: (+1)
   \   0000000A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000000E   0x88DD             LDRH     R5,[R3, #+6]
   \   00000010   0x.... 0x....      BL       ?Subroutine0
   1357                  rxData++;
   1358                } else {
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000014   0x460C             MOV      R4,R1
   \   00000016   0x1E61             SUBS     R1,R4,#+1
   \   00000018   0xB2E4             UXTB     R4,R4
   \   0000001A   0xB13C             CBZ.N    R4,??halInternalUart3RxIsr_1
   \   0000001C   0x8894             LDRH     R4,[R2, #+4]
   \   0000001E   0x2C7F             CMP      R4,#+127
   \   00000020   0xDBF3             BLT.N    ??halInternalUart3RxIsr_0
   1359                  uartErrorMark(3, EMBER_SERIAL_RX_OVERFLOW);
   \   00000022   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000026   0x2123             MOVS     R1,#+35
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x....             B.N      uartErrorMark
   1360                  return;
   1361                }
   1362              }
   1363            }
   \                     ??halInternalUart3RxIsr_1: (+1)
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
   1364          #endif
   1365          
   1366          
   1367          #ifdef SOFTUART
   1368          //this requires use of the SysTick counter and will destroy interrupt latency!
   1369          static uint8_t softwareUartRxByte(void)
   1370          {
   1371            uint8_t i;
   1372            uint8_t bit;
   1373            uint8_t byte = 0;
   1374            // BIT_TIMEs were determined based on 24 MHz MCU clock.
   1375            // Scale 'em for the actual MCU clock in effect, with rounding.
   1376            // (Because the FCLK might not evenly divide by 1000000 or even 500000, use
   1377            // quad arithmetic dividing it by 250000.)
   1378            uint16_t fullBitTime  = (uint16_t)((( FULL_BIT_TIME_SCLK
   1379                                                * (halMcuClockHz() / 250000)) + 48) / 96);
   1380            uint16_t startBitTime = (uint16_t)(((START_BIT_TIME_SCLK
   1381                                                * (halMcuClockHz() / 250000)) + 48) / 96);
   1382            ATOMIC(
   1383              INTERRUPTS_ON();
   1384              //we can only begin receiveing if the input is idle high
   1385              while (SOFT_UART_RX_BIT != 1) {}
   1386              //now wait for our start bit
   1387              while (SOFT_UART_RX_BIT != 0) {}
   1388              INTERRUPTS_OFF();
   1389          
   1390              //set reload value such that move to the center of an incoming bit
   1391              ST_RVR = startBitTime;
   1392              ST_CVR = 0; //writing the current value will cause it to reset to zero
   1393              //enable core clock reference and the counter itself
   1394              ST_CSR = (ST_CSR_CLKSOURCE | ST_CSR_ENABLE);
   1395              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 0.5bit time
   1396              //set reload value such that move 1bit time
   1397              ST_RVR = fullBitTime;
   1398              ST_CVR = 0; //writing the current value will cause it to reset to zero
   1399          
   1400              //loop 8 times recieving all 8 bits and building up the byte
   1401              for (i=0;i<8;i++) {
   1402                while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
   1403                bit = SOFT_UART_RX_BIT; //get the data bit
   1404                bit = ((bit&0x1)<<7);
   1405                byte = (byte>>1)|(bit);
   1406              }
   1407          
   1408              //disable SysTick
   1409              ST_CSR = 0;
   1410            )
   1411            return byte;
   1412          }
   1413          #endif //SOFTUART
   1414          

   \                                 In section .text, align 2, keep-with-next
   1415          void halInternalUartRxPump(uint8_t port)
   1416          {
   1417            #ifdef SOFTUART
   1418              if (EM_SER1_PORT_EN(port)) {
   1419                EmSerialFifoQueue *q = emSerialRxQueues[1];
   1420                uint8_t errors;
   1421                uint8_t byte;
   1422          
   1423                //always configure the bit because other operations might have
   1424                //tried to compromise it
   1425                CONFIG_SOFT_UART_RX_BIT();
   1426          
   1427                //this will block waiting for a start bit!
   1428                byte = softwareUartRxByte();
   1429          
   1430                if (q->used < (EMBER_SERIAL1_RX_QUEUE_SIZE-1)) {
   1431                    FIFO_ENQUEUE(q, byte, emSerialRxQueueWraps[1]);
   1432                } else {
   1433                  errors = EMBER_SERIAL_RX_OVERFLOW;
   1434                  uartErrorMark(1, errors);
   1435                }
   1436                return;
   1437              }
   1438            #endif
   1439          
   1440            #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
   1441              if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
   1442                EmSerialFifoQueue *q = emSerialRxQueues[port];
   1443                uint8_t tail,head;
   1444                uint16_t count=0;
   1445                uint8_t loadA;
   1446                uint8_t loadB;
   1447                //Load all of the hardware status, so we can process what happened
   1448                //without worrying about new data changing these values.
   1449                uint8_t dmaStatus = SCx_REG(port, DMACTRL);
   1450                uint16_t currCountA = SCx_REG(port, RXCNTA);
   1451                uint16_t currCountB = SCx_REG(port, RXCNTB);
   1452          
   1453                //Normal check to see if A has any data
   1454                if (BUFSTATE(port)->prevCountA != currCountA) {
   1455                  //Update the counters and head location for the new data
   1456                  count = (currCountA - BUFSTATE(port)->prevCountA);
   1457                  q->used += count;
   1458                  q->head = (q->head + count) % emSerialRxQueueSizes[port];
   1459                  BUFSTATE(port)->prevCountA = currCountA;
   1460                  BUFSTATE(port)->waitingForTailA = true;
   1461                }
   1462                //Normal check to see if B has any data at all
   1463                if (BUFSTATE(port)->prevCountB != currCountB) {
   1464                  //Update the counters and head location for the new data
   1465                  count = (currCountB - BUFSTATE(port)->prevCountB);
   1466                  q->used += count;
   1467                  q->head = (q->head + count) % emSerialRxQueueSizes[port];
   1468                  BUFSTATE(port)->prevCountB = currCountB;
   1469                  BUFSTATE(port)->waitingForTailB = true;
   1470                  BUFSTATE(port)->waitingForInputToB = false;
   1471                }
   1472          
   1473          
   1474                //if the used count is greater than half the buffer size, nothing can be done
   1475                if (q->used > BUFSTATE(port)->rxStartIndexB) {
   1476                  return;
   1477                }
   1478                //if nothing is in the FIFO, we can reload both if needed
   1479                if (q->used == 0) {
   1480                  loadA = true;
   1481                  loadB = true;
   1482                  goto reloadBuffers;
   1483                }
   1484                //0 < used < bufferSize, so figure out where tail and head are
   1485                if((q->tail)/(BUFSTATE(port)->rxStartIndexB)) {
   1486                  tail = true;  //Tail in B buffer
   1487                } else {
   1488                  tail = false; //Tail in A buffer
   1489                }
   1490          
   1491                if(((uint16_t)(q->head - 1))/(BUFSTATE(port)->rxStartIndexB)) {
   1492                  head = true;  //Head in B buffer
   1493                } else {
   1494                  head = false; //Head in A buffer
   1495                }
   1496          
   1497                //To load, the tail must be in the same buffer as the head so we don't
   1498                //overwrite any bytes that haven't drained from the serial FIFO yet.
   1499                if (tail!=head) {
   1500                  halInternalUartRxCheckRts(port);
   1501                  return;
   1502                }
   1503                // Recall tail true means data is inside B
   1504                loadA = tail;
   1505                loadB = !tail;
   1506            reloadBuffers:
   1507                //check if the buffers need to be reloaded
   1508                if ( (loadA) && (!BUFSTATE(port)->waitingForInputToB) ) {
   1509                  if ( (dmaStatus&SC_RXLODA)
   1510                      != SC_RXLODA) {
   1511                    //An error interrupt can move the addresses of the buffer
   1512                    //during the flush/reset/reload operation.  At this point the
   1513                    //buffer is clear of any usage, so we can reset the addresses
   1514                    SCx_REG(port, RXBEGA) = (uint32_t)q->fifo;
   1515                    SCx_REG(port, RXENDA) = (uint32_t)(q->fifo + BUFSTATE(port)->fifoSize/2 - 1);
   1516                    BUFSTATE(port)->prevCountA = 0;
   1517                    BUFSTATE(port)->waitingForTailA = false;
   1518                    SCx_REG(port, DMACTRL) = SC_RXLODA;
   1519                  }
   1520                }
   1521                if (loadB) {
   1522                  if ( (dmaStatus&SC_RXLODB)
   1523                      != SC_RXLODB) {
   1524                    //An error interrupt can move the addresses of the buffer
   1525                    //during the flush/reset/reload operation.  At this point the
   1526                    //buffer is clear of any usage, so we can reset the addresses
   1527                    SCx_REG(port, RXBEGB) = (uint32_t)(q->fifo + BUFSTATE(port)->fifoSize/2);
   1528                    SCx_REG(port, RXENDB) = (uint32_t)(q->fifo + BUFSTATE(port)->fifoSize - 1);
   1529                    BUFSTATE(port)->prevCountB = 0;
   1530                    BUFSTATE(port)->waitingForTailB = false;
   1531                    SCx_REG(port, DMACTRL) = SC_RXLODB;
   1532                  }
   1533                }
   1534                halInternalUartRxCheckRts(port);
   1535              }
   1536            #endif // defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
   1537          }
   \                     halInternalUartRxPump: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1538          
   1539          #if defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL2_RTSCTS)
   1540          void halInternalUartRxCheckRts(uint8_t port)
   1541          {
   1542            // Verify RTS is controlled by SW (not AUTO mode), and isn't already asserted.
   1543            // (The logic to deassert RTS is in halInternalUart1RxIsr().)
   1544            if ((SCx_REG(port, UARTCFG) & (SC_UARTFLOW | SC_UARTAUTO | SC_UARTRTS)) == SC_UARTFLOW) {
   1545              // Assert RTS if the rx queue tail is in an active (or pending) DMA buffer,
   1546              // because this means the other DMA buffer is empty.
   1547              ATOMIC (
   1548                if ( ( (emSerialRxQueues[port]->tail < emSerialRxQueueSizes[port]/2) &&
   1549                       (SCx_REG(port, DMACTRL) & SC_RXLODA) ) ||
   1550                     ( (emSerialRxQueues[port]->tail >= emSerialRxQueueSizes[port]/2)
   1551                        && (SCx_REG(port, DMACTRL) & SC_RXLODB) ) ) {
   1552                    SCx_REG(port, UARTCFG) |= SC_UARTRTS;          // assert RTS
   1553                }
   1554              )
   1555            }
   1556          }
   1557          #endif
   1558          
   1559          #ifdef EMBER_SERIAL1_RTSCTS
   1560          bool halInternalUartFlowControlRxIsEnabled(uint8_t port)
   1561          {
   1562            return ( (SCx_REG(port, UARTCFG) & (SC_UARTFLOW | SC_UARTAUTO | SC_UARTRTS)) ==
   1563                     (SC_UARTFLOW | SC_UARTRTS) );
   1564          }
   1565          #endif
   1566          #ifdef EMBER_SERIAL1_XONXOFF
   1567          bool halInternalUartFlowControlRxIsEnabled(uint8_t port)
   1568          {
   1569            xonTimer = halCommonGetInt16uQuarterSecondTick(); //FIXME move into new func?
   1570            return ( (xonXoffTxByte == 0) && (xcmdCount > 0) );
   1571          }
   1572          
   1573          bool halInternalUartXonRefreshDone(uint8_t port)
   1574          {
   1575            return (xcmdCount == XON_REFRESH_COUNT);
   1576          }
   1577          #endif
   1578          

   \                                 In section .text, align 2, keep-with-next
   1579          bool halInternalUartTxIsIdle(uint8_t port)
   1580          {
   1581            // TODO how do we determine idle for the VUART or USB?
   1582            #if defined(EM_PHYSICAL_UART)
   1583              if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \                     halInternalUartTxIsIdle: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD10A             BNE.N    ??halInternalUartTxIsIdle_0
   1584                return ( (SCx_REG(port, MODE) == SC1_MODE_UART) &&
   1585                         ((SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) != 0) );
   \   00000004   0x....             LDR.N    R0,??DataTable26_11  ;; 0x4000c848
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD104             BNE.N    ??halInternalUartTxIsIdle_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0980             LSRS     R0,R0,#+6
   \   00000010   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000014   0x4770             BX       LR
   \                     ??halInternalUartTxIsIdle_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR
   1586              }
   1587            #endif
   1588          
   1589            return true;
   \                     ??halInternalUartTxIsIdle_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR               ;; return
   1590          }
   1591          
   1592          #if defined(EM_PHYSICAL_UART)
   1593          // If called outside of an ISR, it should be from within an ATOMIC block.

   \                                 In section .text, align 2, keep-with-next
   1594          static void halInternalUartTxIsr(uint8_t port)
   1595          {
   \                     halInternalUartTxIsr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1596            #if defined(EM_ENABLE_SERIAL_FIFO)
   1597              if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
   1598                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000002   0x....             LDR.N    R1,??DataTable26_5
   \   00000004   0x....             LDR.N    R2,??DataTable26_13
   \   00000006   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000000A   0x....             LDR.N    R3,??DataTable26_7  ;; 0x4000c83c
   \   0000000C   0xE00F             B.N      ??halInternalUartTxIsr_0
   1599          
   1600                // At present we really don't care which interrupt(s)
   1601                // occurred, just that one did.  Loop while there is
   1602                // room to send more data and we've got more data to
   1603                // send.  For UART there is no error detection.
   1604          
   1605          #ifdef EMBER_SERIAL1_XONXOFF
   1606                // Sending an XON or XOFF takes priority over data in the tx queue.
   1607                if (xonXoffTxByte && (SCx_REG(port, UARTSTAT) & SC_UARTTXFREE) ) {
   1608                  SCx_REG(port, DATA) = xonXoffTxByte;
   1609                  if (xonXoffTxByte == ASCII_XOFF) {
   1610                    xcmdCount = -1;
   1611                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_XOFF);
   1612                  } else {
   1613                    xcmdCount = (xcmdCount < 0) ? 1: xcmdCount + 1;
   1614                  }
   1615                  xonXoffTxByte = 0;    // clear to indicate XON/XOFF was sent
   1616                }
   1617          #endif
   1618                while ( (q->used > 0) && (SCx_REG(port, UARTSTAT) & SC_UARTTXFREE) ) {
   1619                  SCx_REG(port, DATA) = FIFO_DEQUEUE(q, emSerialTxQueueWraps[port]);
   \                     ??halInternalUartTxIsr_1: (+1)
   \   0000000E   0x884C             LDRH     R4,[R1, #+2]
   \   00000010   0x1864             ADDS     R4,R4,R1
   \   00000012   0x79A4             LDRB     R4,[R4, #+6]
   \   00000014   0x601C             STR      R4,[R3, #+0]
   \   00000016   0x884C             LDRH     R4,[R1, #+2]
   \   00000018   0xF832 0x5010      LDRH     R5,[R2, R0, LSL #+1]
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \   0000001E   0xFB94 0xF6F5      SDIV     R6,R4,R5
   \   00000022   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   00000026   0x804C             STRH     R4,[R1, #+2]
   \   00000028   0x888C             LDRH     R4,[R1, #+4]
   \   0000002A   0x1E64             SUBS     R4,R4,#+1
   \   0000002C   0x808C             STRH     R4,[R1, #+4]
   1620                }
   \                     ??halInternalUartTxIsr_0: (+1)
   \   0000002E   0x888C             LDRH     R4,[R1, #+4]
   \   00000030   0xB114             CBZ.N    R4,??halInternalUartTxIsr_2
   \   00000032   0x68DC             LDR      R4,[R3, #+12]
   \   00000034   0x0764             LSLS     R4,R4,#+29
   \   00000036   0xD4EA             BMI.N    ??halInternalUartTxIsr_1
   1621              }
   1622            #endif
   1623            #if defined(EM_ENABLE_SERIAL_BUFFER) && !defined (CORTEXM3_EM35X_USB)
   1624              if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
   1625                EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1626          
   1627                // The only interrupts we care about here are UNLOAD's and IDLE.
   1628                // Our algorithm doesn't really care which interrupt occurred,
   1629                // or even if one really didn't.  If there is data to send and
   1630                // a DMA channel available to send it, then out it goes.
   1631          
   1632                assert( !((q->used == 0) && (q->nextByte != NULL)) );
   1633                while ( q->used > 0 ) {
   1634                  if ( q->nextByte == NULL ) {
   1635                    // new message pending, but nextByte not set up yet
   1636                    emSerialBufferNextMessageIsr(q);
   1637                  }
   1638          
   1639                  // Something to send: do we have a DMA channel to send it on?
   1640                  // Probe for an available channel by checking the channel's
   1641                  // SC1_DMACTRL.TX_LOAD   == 0 (channel unloaded) &&
   1642                  // SC1_DMASTAT.TX_ACTIVE == 0 (channel not active)
   1643                  // The latter check should be superfluous but is a safety mechanism.
   1644                  if ( !(SCx_REG(port, DMACTRL) & SC_TXLODA) &&
   1645                       !(SCx_REG(port, DMASTAT) & SC_TXACTA) ) {
   1646                    // Channel A is available
   1647                    SCx_REG(port, TXBEGA)  = (uint32_t)q->nextByte;
   1648                    SCx_REG(port, TXENDA) = (uint32_t)q->lastByte;
   1649                    INT_SCxFLAG(port) = INT_SCTXULDA; // Ack if pending
   1650                    SCx_REG(port, DMACTRL) = SC_TXLODA;
   1651                    // Release previously held buffer and hold the newly-loaded one
   1652                    // so we can safely use emSerialBufferNextBlockIsr() to check for
   1653                    // more data to send without the risk of reusing a buffer we're
   1654                    // in the process of DMA-ing.
   1655                    if (BUFSTATE(port)->holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER)
   1656                      emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1657                    BUFSTATE(port)->holdBuf[0] = q->currentBuffer;
   1658                    emberHoldMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1659                    emSerialBufferNextBlockIsr(q, port);
   1660                  } else
   1661                  if ( !(SCx_REG(port, DMACTRL) & SC_TXLODB) &&
   1662                       !(SCx_REG(port, DMASTAT) & SC_TXACTB) ) {
   1663                    // Channel B is available
   1664                    SCx_REG(port, TXBEGB)  = (uint32_t)q->nextByte;
   1665                    SCx_REG(port, TXENDB) = (uint32_t)q->lastByte;
   1666                    INT_SCxFLAG(port) = INT_SCTXULDB; // Ack if pending
   1667                    SCx_REG(port, DMACTRL) = SC_TXLODB;
   1668                    // Release previously held buffer and hold the newly-loaded one
   1669                    // so we can safely use emSerialBufferNextBlockIsr() to check for
   1670                    // more data to send without the risk of reusing a buffer we're
   1671                    // in the process of DMA-ing.
   1672                    if (BUFSTATE(port)->holdBuf[1] != EMBER_NULL_MESSAGE_BUFFER)
   1673                      emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1674                    BUFSTATE(port)->holdBuf[1] = q->currentBuffer;
   1675                    emberHoldMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1676                    emSerialBufferNextBlockIsr(q, port);
   1677                  } else {
   1678                    // No channels available; can't send anything now so break out of loop
   1679                    break;
   1680                  }
   1681          
   1682                } // while ( q->used > 0 )
   1683          
   1684                // Release previously-held buffer(s) from an earlier DMA operation
   1685                // if that channel is now free (i.e. it's completed the DMA and we
   1686                // didn't need to use that channel for more output in this call).
   1687                if ( (BUFSTATE(port)->holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER) &&
   1688                     !(SCx_REG(port, DMACTRL) & SC_TXLODA) &&
   1689                     !(SCx_REG(port, DMASTAT) & SC_TXACTA) ) {
   1690                  emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1691                  BUFSTATE(port)->holdBuf[0] = EMBER_NULL_MESSAGE_BUFFER;
   1692                }
   1693                if ( (BUFSTATE(port)->holdBuf[1] != EMBER_NULL_MESSAGE_BUFFER) &&
   1694                     !(SCx_REG(port, DMACTRL) & SC_TXLODB) &&
   1695                     !(SCx_REG(port, DMASTAT) & SC_TXACTB) ) {
   1696                  emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1697                  BUFSTATE(port)->holdBuf[1] = EMBER_NULL_MESSAGE_BUFFER;
   1698                }
   1699              }
   1700            #endif
   1701          }
   \                     ??halInternalUartTxIsr_2: (+1)
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   1702          #endif // defined(EM_PHYSICAL_UART)
   1703          
   1704          
   1705          #if EM_SERIAL1_ENABLED
   1706            //The following registers are the only SC1-UART registers that need to be
   1707            //saved across deep sleep cycles.  All other SC1-UART registers are
   1708            //reenabled or restarted using more complex init or restart algorithms.

   \                                 In section .bss, align 4
   1709            static uint32_t  SC1_UARTPER_SAVED;
   \                     SC1_UARTPER_SAVED:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   1710            static uint32_t  SC1_UARTFRAC_SAVED;
   1711            static uint32_t  SC1_UARTCFG_SAVED;
   1712          #endif // EM_SERIAL1_ENABLED
   1713          #if EM_SERIAL2_ENABLED
   1714            //The following registers are the only SC3-UART registers that need to be
   1715            //saved across deep sleep cycles.  All other SC3-UART registers are
   1716            //reenabled or restarted using more complex init or restart algorithms.
   1717            static uint32_t  SC3_UARTPER_SAVED;
   1718            static uint32_t  SC3_UARTFRAC_SAVED;
   1719            static uint32_t  SC3_UARTCFG_SAVED;
   1720          #endif // EM_SERIAL2_ENABLED
   1721          

   \                                 In section .text, align 2, keep-with-next
   1722          void halInternalPowerDownUart(void)
   1723          {
   1724            #if EM_SERIAL1_ENABLED
   1725              SC1_UARTPER_SAVED = SC1_UARTPER;
   \                     halInternalPowerDownUart: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable26_14  ;; 0x4000c85c
   \   00000002   0x....             LDR.N    R1,??DataTable26_15
   \   00000004   0x68C2             LDR      R2,[R0, #+12]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   1726              SC1_UARTFRAC_SAVED = SC1_UARTFRAC;
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   1727              SC1_UARTCFG_SAVED = SC1_UARTCFG;
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6088             STR      R0,[R1, #+8]
   1728              SC1_TXD_GPIO(GPIOCFG_OUT, 1); // Avoid gitching TxD going down
   1729            #endif // EM_SERIAL1_ENABLED
   1730            #if EM_SERIAL2_ENABLED
   1731              SC3_UARTPER_SAVED = SC3_UARTPER;
   1732              SC3_UARTFRAC_SAVED = SC3_UARTFRAC;
   1733              SC3_UARTCFG_SAVED = SC3_UARTCFG;
   1734              // TODO SC3_TXD_GPIO(GPIOCFG_OUT, 1); // Avoid gitching TxD going down
   1735            #endif // EM_SERIAL1_ENABLED
   1736          }
   \   00000010   0x4770             BX       LR               ;; return
   1737          

   \                                 In section .text, align 2, keep-with-next
   1738          void halInternalPowerUpUart(void)
   1739          {
   \                     halInternalPowerUpUart: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1740            #if EM_SERIAL1_ENABLED
   1741              SC1_UARTPER = SC1_UARTPER_SAVED;
   \   00000002   0x....             LDR.N    R1,??DataTable26_15
   \   00000004   0x....             LDR.N    R0,??DataTable26_2  ;; 0x4000c854
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0x6142             STR      R2,[R0, #+20]
   1742              SC1_UARTFRAC = SC1_UARTFRAC_SAVED;
   \   0000000A   0x684A             LDR      R2,[R1, #+4]
   \   0000000C   0x6182             STR      R2,[R0, #+24]
   1743              SC1_UARTCFG = SC1_UARTCFG_SAVED;
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6081             STR      R1,[R0, #+8]
   1744          
   1745              SC1_MODE = SC1_MODE_UART;
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x6001             STR      R1,[R0, #+0]
   1746              SC1_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
   1747          
   1748              halInternalInitUartInterrupts(1);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       halInternalInitUartInterrupts
   1749            #endif
   1750          
   1751            #if EM_SERIAL2_ENABLED
   1752              SC3_UARTPER = SC3_UARTPER_SAVED;
   1753              SC3_UARTFRAC = SC3_UARTFRAC_SAVED;
   1754              SC3_UARTCFG = SC3_UARTCFG_SAVED;
   1755          
   1756              SC3_MODE = SC3_MODE_UART;
   1757              //SC3_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
   1758          
   1759              halInternalInitUartInterrupts(2);
   1760            #endif
   1761          
   1762            #if EM_SERIAL3_ENABLED || defined (USB_MSD) || defined (USB_HID)
   1763              //Remember, halInternalPowerUpUart does not return anything.  Powering
   1764              //up the USB requires going through its normal configuration and
   1765              //enumeration process.
   1766              #if defined(CORTEXM3_EM35X_USB)
   1767                USBD_Init(&initstruct);
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x.... 0x....      ADR.W    R0,initstruct
   \   00000024   0x.... 0x....      B.W      USBD_Init
   1768              #endif
   1769            #endif
   1770          }
   1771          
   1772          

   \                                 In section .text, align 2, keep-with-next
   1773          void halInternalRestartUart(void)
   1774          {
   1775            // This is no longer needed and should be removed as a dinosaur --DMM
   1776          }
   \                     halInternalRestartUart: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1777          
   1778          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO) && defined(EMBER_SERIAL1_XONXOFF)
   1779          // TODO XON/XOFF on port 2
   1780          void halInternalUartFlowControl(uint8_t port)
   1781          {
   1782            if (EM_SER1_PORT_EN(port)) {
   1783              uint16_t used = emSerialRxQueues[1]->used;
   1784              uint8_t time = halCommonGetInt16uQuarterSecondTick();
   1785          
   1786              if (used) {
   1787                xonTimer = time;
   1788              }
   1789              // Send an XON if the rx queue is below the XON threshold
   1790              // and an XOFF had been sent that needs to be reversed
   1791              ATOMIC(
   1792                if ( (xcmdCount == -1) && (used <= XON_LIMIT) ) {
   1793                  halInternalUart1ForceXon();
   1794                } else if ( (used == 0) &&
   1795                            ((uint8_t)(time - xonTimer) >= XON_REFRESH_TIME) &&
   1796                            (xcmdCount < XON_REFRESH_COUNT) ) {
   1797                  halInternalUart1ForceXon();
   1798                }
   1799              )
   1800            }
   1801          }
   1802          #endif
   1803          
   1804          #ifdef EMBER_SERIAL1_XONXOFF
   1805          // Must be called from within an ATOMIC block.
   1806          static void halInternalUart1ForceXon(void)
   1807          {
   1808            if (xonXoffTxByte == ASCII_XOFF) {  // if XOFF waiting to be sent, cancel it
   1809              xonXoffTxByte = 0;
   1810              xcmdCount = 0;
   1811            } else {                            // else, send XON and record the time
   1812              xonXoffTxByte = ASCII_XON;
   1813              halInternalStartUartTx(1);
   1814            }
   1815            xonTimer = halCommonGetInt16uQuarterSecondTick();
   1816          }
   1817          #endif
   1818          
   1819          #if EM_SERIAL1_ENABLED

   \                                 In section .text, align 2, keep-with-next
   1820          void halSc1Isr(void)
   1821          {
   \                     halSc1Isr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1822            uint32_t interrupt;
   1823          
   1824            //this read and mask is performed in two steps otherwise the compiler
   1825            //will complain about undefined order of volatile access
   1826            interrupt = INT_SC1FLAG;
   \   00000002   0x....             LDR.N    R4,??DataTable26  ;; 0x4000a808
   \   00000004   0xE00F             B.N      ??halSc1Isr_0
   1827            interrupt &= INT_SC1CFG;
   1828          
   1829            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1830              while (interrupt != 0) {
   \                     ??halSc1Isr_1: (+1)
   \   00000006   0xF246 0x7029      MOVW     R0,#+26409
   \   0000000A   0x4205             TST      R5,R0
   1831            #endif // (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1832          
   1833                INT_SC1FLAG = interrupt; // acknowledge the interrupts early
   \   0000000C   0x6025             STR      R5,[R4, #+0]
   1834          
   1835                // RX events
   1836                if ( interrupt & (INT_SCRXVAL   | // RX has data
   1837                                  INT_SCRXOVF   | // RX Overrun error
   1838                                  INT_SCRXFIN   | // RX done [TWI]
   1839                                  INT_SCNAK     | // RX Nack [TWI]
   1840                                  INT_SCRXULDA  | // RX DMA A has data
   1841                                  INT_SCRXULDB  | // RX DMA B has data
   1842                                  INT_SC1FRMERR | // RX Frame error
   1843                                  INT_SC1PARERR ) // RX Parity error
   1844                   ) {
   \   0000000E   0xD003             BEQ.N    ??halSc1Isr_2
   1845                  halInternalUartRxIsr(1, interrupt);
   \   00000010   0xB2A9             UXTH     R1,R5
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       halInternalUartRxIsr
   1846                }
   1847          
   1848                // TX events
   1849                if ( interrupt & (INT_SCTXFREE | // TX has room
   1850                                  INT_SCTXIDLE | // TX idle (more room)
   1851                                  INT_SCTXUND  | // TX Underrun [SPI/TWI]
   1852                                  INT_SCTXFIN  | // TX complete [TWI]
   1853                                  INT_SCCMDFIN | // TX Start/Stop done [TWI]
   1854                                  INT_SCTXULDA | // TX DMA A has room
   1855                                  INT_SCTXULDB ) // TX DMA B has room
   1856                   ) {
   \                     ??halSc1Isr_2: (+1)
   \   00000018   0xF641 0x00D6      MOVW     R0,#+6358
   \   0000001C   0x4205             TST      R5,R0
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x2001             MOVNE    R0,#+1
   \   00000022   0x.... 0x....      BLNE     halInternalUartTxIsr
   1857                  halInternalUartTxIsr(1);
   1858                }
   1859          
   1860            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1861                interrupt = INT_SC1FLAG;
   \                     ??halSc1Isr_0: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   1862                interrupt &= INT_SC1CFG;
   \   00000028   0x6C21             LDR      R1,[R4, #+64]
   \   0000002A   0xEA11 0x0500      ANDS     R5,R1,R0
   1863              }
   \   0000002E   0xD1EA             BNE.N    ??halSc1Isr_1
   1864            #endif // (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1865          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1866          #endif // EM_SERIAL1_ENABLED
   1867          
   1868          #if EM_SERIAL2_ENABLED
   1869          void halSc3Isr(void)
   1870          {
   1871            uint32_t interrupt;
   1872          
   1873            //this read and mask is performed in two steps otherwise the compiler
   1874            //will complain about undefined order of volatile access
   1875            interrupt = INT_SC3FLAG;
   1876            interrupt &= INT_SC3CFG;
   1877          
   1878            #if (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1879              while (interrupt != 0) {
   1880            #endif // (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1881          
   1882                INT_SC3FLAG = interrupt; // acknowledge the interrupts early
   1883          
   1884                // RX events
   1885                if ( interrupt & (INT_SCRXVAL   | // RX has data
   1886                                  INT_SCRXOVF   | // RX Overrun error
   1887                                  INT_SCRXFIN   | // RX done [TWI]
   1888                                  INT_SCNAK     | // RX Nack [TWI]
   1889                                  INT_SCRXULDA  | // RX DMA A has data
   1890                                  INT_SCRXULDB  | // RX DMA B has data
   1891                                  INT_SC1FRMERR | // RX Frame error
   1892                                  INT_SC1PARERR ) // RX Parity error
   1893                   ) {
   1894                  halInternalUartRxIsr(2, interrupt);
   1895                }
   1896          
   1897                // TX events
   1898                if ( interrupt & (INT_SCTXFREE | // TX has room
   1899                                  INT_SCTXIDLE | // TX idle (more room)
   1900                                  INT_SCTXUND  | // TX Underrun [SPI/TWI]
   1901                                  INT_SCTXFIN  | // TX complete [TWI]
   1902                                  INT_SCCMDFIN | // TX Start/Stop done [TWI]
   1903                                  INT_SCTXULDA | // TX DMA A has room
   1904                                  INT_SCTXULDB ) // TX DMA B has room
   1905                   ) {
   1906                  halInternalUartTxIsr(2);
   1907                }
   1908          
   1909            #if (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1910                interrupt = INT_SC3FLAG;
   1911                interrupt &= INT_SC3CFG;
   1912              }
   1913            #endif // (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1914          }
   1915          #endif // EM_SERIAL2_ENABLED
   1916          

   \                                 In section .text, align 2, keep-with-next
   1917          static void uartErrorMark(uint8_t port, uint8_t errors)
   1918          {
   \                     uartErrorMark: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1919            EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000002   0x....             LDR.N    R2,??DataTable26_8
   1920          
   1921            // save error code & location in queue
   1922            if ( emSerialRxError[port] == EMBER_SUCCESS ) {
   \   00000004   0x....             LDR.N    R4,??DataTable26_16
   \   00000006   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   0000000A   0x5D05             LDRB     R5,[R0, R4]
   \   0000000C   0x....             LDR.N    R3,??DataTable26_17
   \   0000000E   0xB925             CBNZ.N   R5,??uartErrorMark_0
   1923              emSerialRxErrorIndex[port] = q->head;
   \   00000010   0x8812             LDRH     R2,[R2, #+0]
   \   00000012   0xF823 0x2010      STRH     R2,[R3, R0, LSL #+1]
   1924              emSerialRxError[port] = errors;
   \   00000016   0x5501             STRB     R1,[R0, R4]
   \   00000018   0xBD30             POP      {R4,R5,PC}
   1925            } else {
   1926              // Flush back to previous error location & update value
   1927              q->head = emSerialRxErrorIndex[port];
   \                     ??uartErrorMark_0: (+1)
   \   0000001A   0xF833 0x3010      LDRH     R3,[R3, R0, LSL #+1]
   \   0000001E   0x8013             STRH     R3,[R2, #+0]
   1928              emSerialRxError[port] = errors;
   \   00000020   0x5501             STRB     R1,[R0, R4]
   1929              if(q->head < q->tail) {
   \   00000022   0x8813             LDRH     R3,[R2, #+0]
   \   00000024   0x8851             LDRH     R1,[R2, #+2]
   \   00000026   0x428B             CMP      R3,R1
   \   00000028   0xD205             BCS.N    ??uartErrorMark_1
   1930                q->used = (emSerialRxQueueSizes[port] - q->tail) + q->head;
   \   0000002A   0x....             LDR.N    R4,??DataTable26_12
   \   0000002C   0xF834 0x0010      LDRH     R0,[R4, R0, LSL #+1]
   \   00000030   0x1A40             SUBS     R0,R0,R1
   \   00000032   0x1818             ADDS     R0,R3,R0
   \   00000034   0xE000             B.N      ??uartErrorMark_2
   1931              } else {
   1932                q->used = q->head - q->tail;
   \                     ??uartErrorMark_1: (+1)
   \   00000036   0x1A58             SUBS     R0,R3,R1
   \                     ??uartErrorMark_2: (+1)
   \   00000038   0x8090             STRH     R0,[R2, #+4]
   1933              }
   1934            }
   1935          }
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x4000A808         DC32     0x4000a808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x4000C854         DC32     0x4000c854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x........         DC32     TOKEN_MFG_EUI_64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x........         DC32     iSerialNumber

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x........         DC32     emSerialTxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x4000A848         DC32     0x4000a848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_7:
   \   00000000   0x4000C83C         DC32     0x4000c83c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_8:
   \   00000000   0x........         DC32     emSerialRxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_9:
   \   00000000   0x40000024         DC32     0x40000024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_10:
   \   00000000   0x........         DC32     emSerialRxQueueWraps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_11:
   \   00000000   0x4000C848         DC32     0x4000c848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_12:
   \   00000000   0x........         DC32     emSerialRxQueueSizes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_13:
   \   00000000   0x........         DC32     emSerialTxQueueWraps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_14:
   \   00000000   0x4000C85C         DC32     0x4000c85c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_15:
   \   00000000   0x........         DC32     SC1_UARTPER_SAVED

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_16:
   \   00000000   0x........         DC32     emSerialRxError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_17:
   \   00000000   0x........         DC32     emSerialRxErrorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x75 0x61          DC8 "uart.c"
   \              0x72 0x74    
   \              0x2E 0x63    
   \              0x00         
   \   00000007   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   halInternalForceReadUartByte
        24   -> _disableBasePri
        24   -> _writeBasePri
       8   halInternalForceWriteUartData
         8   -> emDebugSendVuartMessage
         8   -> usbForceTxData
       0   halInternalInitUartInterrupts
       0   halInternalPowerDownUart
       8   halInternalPowerUpUart
         0   -> USBD_Init
         8   -> halInternalInitUartInterrupts
       0   halInternalRestartUart
      16   halInternalStartUartTx
        16   -> _disableBasePri
         0   -> _writeBasePri
        16   -> emDebugSendVuartMessage
        16   -> halInternalAssertFailed
        16   -> halInternalUartTxIsr
       0   halInternalStopUartTx
      16   halInternalUart3RxIsr
         0   -> uartErrorMark
      24   halInternalUartInit
        24   -> USBD_GetUsbState
        24   -> USBD_Init
        24   -> emDebugInit
        24   -> halCommonGetInt16uMillisecondTick
        24   -> halInternalGetMfgTokenData
        24   -> halInternalInitUartInterrupts
        24   -> halInternalResetWatchDog
        24   -> halInternalUartSetBaudRate
      32   halInternalUartRxIsr
        32   -> uartErrorMark
       0   halInternalUartRxPump
       0   halInternalUartTxIsIdle
      16   halInternalUartTxIsr
       8   halInternalWaitUartTxComplete
         8   -> halInternalResetWatchDog
      16   halSc1Isr
        16   -> halInternalUartRxIsr
      16   halStackReceiveVuartMessage
         0   -> uartErrorMark
      12   uartErrorMark


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_12
       4  ??DataTable26_13
       4  ??DataTable26_14
       4  ??DataTable26_15
       4  ??DataTable26_16
       4  ??DataTable26_17
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
      20  ?Subroutine0
      14  ?Subroutine1
       8  ?_0
      12  SC1_UARTPER_SAVED
          SC1_UARTFRAC_SAVED
          SC1_UARTCFG_SAVED
      20  baudSettings
       4  bufferingMultiplier
      20  callbacks
      68  configDesc
      20  deviceDesc
      94  halInternalForceReadUartByte
      76  halInternalForceWriteUartData
      32  halInternalInitUartInterrupts
      18  halInternalPowerDownUart
      40  halInternalPowerUpUart
       2  halInternalRestartUart
     104  halInternalStartUartTx
      16  halInternalStopUartTx
      46  halInternalUart3RxIsr
     266  halInternalUartInit
     124  halInternalUartRxIsr
       2  halInternalUartRxPump
      30  halInternalUartTxIsIdle
      58  halInternalUartTxIsr
      22  halInternalWaitUartTxComplete
      50  halSc1Isr
      52  halStackReceiveVuartMessage
      56  iManufacturer
      60  iProduct
      36  iSerialNumber
      28  initstruct
       4  langID
      16  strings
      60  uartErrorMark

 
    12 bytes in section .bss
    36 bytes in section .data
   248 bytes in section .rodata
 1 254 bytes in section .text
 
 1 254 bytes of CODE  memory
   248 bytes of CONST memory
    48 bytes of DATA  memory

Errors: none
Warnings: none
