###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  14:43:36
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\sleep.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\sleep.c -D APP_BTL -D
#        CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D PHY_EM3XX -D
#        "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"sleep.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\lst\sleep.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Client\build\obj\sleep.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\sleep.c
      1          /** @file hal/micro/cortexm3/sleep.c
      2           *
      3           * @brief EM3XX micro specific sleep functions.
      4           *
      5           * <!-- Copyright 2013 Silicon Laboratories, Inc.                       *80* -->
      6           */
      7          
      8          #include PLATFORM_HEADER
      9          #include "hal/micro/micro-common.h"
     10          #include "hal/micro/micro.h"
     11          #include "hal/micro/cortexm3/micro-common.h"
     12          #include "hal/micro/cortexm3/memmap.h"
     13          #include "hal/micro/cortexm3/mfg-token.h"
     14          #ifdef MINIMAL_HAL
     15            #define BYPASS_MPU(blah) blah
     16            #define EMBER_WAKE_PORT_A 0
     17            #define EMBER_WAKE_PORT_B 0
     18            #define EMBER_WAKE_PORT_C 0
     19          #else
     20            #include BOARD_HEADER
     21            #include "hal/micro/cortexm3/mpu.h"
     22            #include "hal/micro/cortexm3/wake-gpio.h"
     23          #endif //defined(MINIMAL_HAL)
     24          #include "hal/micro/cortexm3/diagnostic.h"
     25          
     26          
     27          //[[
     28          //This function is responsible for manually putting every piece of the Low
     29          //Voltage domain through a fake reset cycle.  This function is intended to
     30          //mimick a Low Voltage domain reset, with the except being any piece of
     31          //the chip that is enabled via cstartup (since cstartup will not be called
     32          //after this function).

   \                                 In section .text, align 2, keep-with-next
     33          void halInternalMimickLvReset(void)
     34          {
     35            //WBB350FIXME -- This function needs to differentiate between DS1 and DS0!!
     36          
     37            // Only three register blocks keep power across deep sleep:
     38            //  CM_HV, GPIO, SLOW_TIMERS
     39            //
     40            // All other register blocks lose their state across deep sleep and we
     41            // must force a reset of them to mimick a LV reset.  The blocks are listed
     42            // here in a loose order of importance.
     43          
     44            //// NVIC          ////
     45            //ST_CSR
     46            //ST_RVR
     47            //ST_CALVR
     48            //INT_CFGCLR
     49            //INT_PENDCLR
     50            //NVIC_IPR_3to0
     51            //NVIC_IPR_7to4
     52            //NVIC_IPR_11to8
     53            //NVIC_IPR_15to12
     54            //NVIC_IPR_19to16
     55            //SCS_VTOR
     56            //SCS_AIRCR
     57          
     58            //// EVENT         ////
     59            //// CM_LV         ////
     60            //// RAM_CTRL      ////
     61            //// FLASH_CONTROL ////
     62            //// TPIU          ////
     63            //// AUX_ADC       ////
     64            //// SERIAL        ////
     65            //// TMR1          ////
     66            //// TMR2          ////
     67            //// ITM           ////
     68            //// DWT           ////
     69            //// FPB           ////
     70            //// CAL_ADC       ////
     71            //// BASEBAND      ////
     72            //// MAC           ////
     73            //// SECURITY      ////
     74          
     75            //WBB350FIXME -- Fill out this function and complete SLEEP13 testcase to
     76            //               cover this
     77          }
   \                     halInternalMimickLvReset: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     78          
     79          
     80          #ifdef SLEEP_TRACE //WBB350FIXME -- Find a less intrusive technique
     81            extern bool sleepTraceOn;
     82            extern uint8_t sleepTraceBuffer[];
     83            extern uint8_t sleepTraceIndex;
     84            extern uint8_t sleepTraceDelayPosition;
     85            #define SLEEP_TRACE_ADD_MARKER(byte)                 \
     86              do {                                               \
     87                if(sleepTraceOn) {                               \
     88                  if(sleepTraceIndex<50) {                       \
     89                    sleepTraceBuffer[sleepTraceIndex] = byte;    \
     90                  }                                              \
     91                  sleepTraceIndex++;                             \
     92                }                                                \
     93              } while(0)
     94            #define SLEEP_TRACE_1SEC_DELAY(position)             \
     95              do {                                               \
     96                if(sleepTraceDelayPosition==position) {          \
     97                  uint8_t delayCnt=(20*1);                         \
     98                  while(delayCnt-->0) {                          \
     99                    halCommonDelayMicroseconds(50000);           \
    100                  }                                              \
    101                }                                                \
    102              } while(0)
    103          #else //SLEEP_TRACE
    104            #define SLEEP_TRACE_ADD_MARKER(byte) do{}while(0)
    105            #define SLEEP_TRACE_1SEC_DELAY(position) do{}while(0)
    106          #endif //SLEEP_TRACE
    107          //]]
    108          
    109          
    110          

   \                                 In section .bss, align 4
    111          static WakeEvents halInternalWakeEvent={.eventflags = 0};
   \                     halInternalWakeEvent:
   \   00000000                      DS8 4
    112          

   \                                 In section .text, align 2, keep-with-next
    113          WakeEvents halGetWakeInfo(void)
    114          {
    115            return halInternalWakeEvent;
   \                     halGetWakeInfo: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    116          }
    117          
    118          #ifndef CORTEXM3_EM35X_GEN4 // HW bug fixed in GEN4
    119          //forceSleepTmrCnt is a flag indicating that the system timer module
    120          //should force a fake value for SLEEPTMR_CNT whenever the timer is
    121          //accessed.  For FogBugz 11909/11920 workaround.
    122          bool forceSleepTmrCnt = false;
    123          //wakeupSleepTmrCnt is a capturing of the SLEEPTMR_CNT immediately upon
    124          //waking up from deep sleep.  This value is used to know when the counter
    125          //has ticked forward.  For FogBugz 11909/11920 workaround.
    126          uint32_t wakeupSleepTmrCnt = 0;
    127          #endif//CORTEXM3_EM35X_GEN4 // HW bug fixed in GEN4
    128          

   \                                 In section .text, align 2, keep-with-next
    129          void halInternalSleep(SleepModes sleepMode)
    130          {
   \                     halInternalSleep: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    131            //Timer restoring always takes place during the wakeup sequence.  We save
    132            //the state here in case SLEEPMODE_NOTIMER is invoked, which would disable
    133            //the clocks.
    134            uint32_t SLEEPTMR_CLKEN_SAVED = SLEEPTMR_CLKEN;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable5_1  ;; 0x40000004
   \   00000008   0xB091             SUB      SP,SP,#+68
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0x9110             STR      R1,[SP, #+64]
    135          
    136            //SLEEPMODE_POWERDOWN and SLEEPMODE_POWERSAVE are deprecated.  Remap them
    137            //to their appropriate, new mode name.
    138            if(sleepMode == SLEEPMODE_POWERDOWN) {
   \   0000000E   0x2807             CMP      R0,#+7
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0x2003             MOVEQ    R0,#+3
    139              sleepMode = SLEEPMODE_MAINTAINTIMER;
   \   00000014   0xD002             BEQ.N    ??halInternalSleep_0
    140            } else if(sleepMode == SLEEPMODE_POWERSAVE) {
   \   00000016   0x2808             CMP      R0,#+8
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2002             MOVEQ    R0,#+2
    141              sleepMode = SLEEPMODE_WAKETIMER;
    142            }
    143          
    144            //This code assumes all wake source registers are properly configured.
    145            //As such, it should be called from halSleep() which configues the
    146            //wake sources.
    147          
    148            //The parameter gpioWakeSel is a bitfield composite of the GPIO wake
    149            //sources derived from the 3-6 ports, indicating which of the 24-48 GPIO
    150            //are configured as a wake source.
    151            WakeMask gpioWakeSel  = (GPIO_PAWAKE<<0);
   \                     ??halInternalSleep_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R5,??DataTable5_2  ;; 0x4000bc08
   \   00000020   0x6829             LDR      R1,[R5, #+0]
    152                     gpioWakeSel |= (GPIO_PBWAKE<<8);
   \   00000022   0x686A             LDR      R2,[R5, #+4]
    153                     gpioWakeSel |= (GPIO_PCWAKE<<16);
   \   00000024   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000028   0x68AA             LDR      R2,[R5, #+8]
   \   0000002A   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000002E   0x9100             STR      R1,[SP, #+0]
    154          #ifdef EMBER_WAKE_PORT_D
    155                     gpioWakeSel |= (GPIO_PDWAKE<<24);
    156          #endif
    157          #ifdef EMBER_WAKE_PORT_E
    158                     gpioWakeSel |= ((uint64_t)GPIO_PEWAKE<<32);
    159          #endif
    160          #ifdef EMBER_WAKE_PORT_F
    161                     gpioWakeSel |= ((uint64_t)GPIO_PFWAKE<<40);
    162          #endif
    163          
    164            //PB2 is also WAKE_SC1.  Set this wake source if PB2's GPIO wake is set.
    165            if(GPIO_PBWAKE & PB2) {
   \   00000030   0x6869             LDR      R1,[R5, #+4]
   \   00000032   0x0749             LSLS     R1,R1,#+29
   \   00000034   0xD503             BPL.N    ??halInternalSleep_1
    166              WAKE_SEL |= WAKE_SC1;
   \   00000036   0x69E1             LDR      R1,[R4, #+28]
   \   00000038   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000003C   0x61E1             STR      R1,[R4, #+28]
    167            }
    168          
    169            //PA2 is also WAKE_SC2.  Set this wake source if PA2's GPIO wake is set.
    170            if(GPIO_PAWAKE & PA2) {
   \                     ??halInternalSleep_1: (+1)
   \   0000003E   0x6829             LDR      R1,[R5, #+0]
   \   00000040   0x0749             LSLS     R1,R1,#+29
   \   00000042   0xD503             BPL.N    ??halInternalSleep_2
    171              WAKE_SEL |= WAKE_SC2;
   \   00000044   0x69E1             LDR      R1,[R4, #+28]
   \   00000046   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000004A   0x61E1             STR      R1,[R4, #+28]
    172            }
    173          
    174            //The WAKE_IRQD source can come from any pin based on IRQD's sel register.
    175            if(gpioWakeSel & BIT(GPIO_IRQDSEL)) {
   \                     ??halInternalSleep_2: (+1)
   \   0000004C   0x9900             LDR      R1,[SP, #+0]
   \   0000004E   0x69EA             LDR      R2,[R5, #+28]
   \   00000050   0x40D1             LSRS     R1,R1,R2
   \   00000052   0x07C9             LSLS     R1,R1,#+31
   \   00000054   0xD503             BPL.N    ??halInternalSleep_3
    176              WAKE_SEL |= WAKE_IRQD;
   \   00000056   0x69E1             LDR      R1,[R4, #+28]
   \   00000058   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000005C   0x61E1             STR      R1,[R4, #+28]
    177            }
    178          
    179            halInternalWakeEvent.eventflags = 0; //clear old wake events
   \                     ??halInternalSleep_3: (+1)
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x.... 0x....      LDR.W    R6,??DataTable5
    180          
    181            switch(sleepMode)
   \   00000064   0x.... 0x....      LDR.W    R7,??DataTable5_3  ;; 0x4000a014
   \   00000068   0x6031             STR      R1,[R6, #+0]
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xF000 0x8200      BEQ.W    ??halInternalSleep_4
   \   00000070   0xF0C0 0x8226      BCC.W    ??halInternalSleep_5
   \   00000074   0x2803             CMP      R0,#+3
   \   00000076   0xD01A             BEQ.N    ??halInternalSleep_6
   \   00000078   0xD304             BCC.N    ??halInternalSleep_7
   \   0000007A   0x2804             CMP      R0,#+4
   \   0000007C   0xF040 0x8220      BNE.W    ??halInternalSleep_5
    182            {
    183              case SLEEPMODE_NOTIMER:
    184                //The sleep timer clock sources (both RC and XTAL) are turned off.
    185                //Wakeup is possible from only GPIO.  System time is lost.
    186                //NOTE: Timer restoring always takes place during the wakeup sequence.
    187                SLEEPTMR_CLKEN = 0;
   \   00000080   0x6061             STR      R1,[R4, #+4]
    188                goto deepSleepCore;
   \   00000082   0xE014             B.N      ??halInternalSleep_6
    189          
    190              case SLEEPMODE_WAKETIMER:
    191                //The sleep timer clock sources remain running.  The RC is always
    192                //running and the 32kHz XTAL depends on the board header.  Wakeup
    193                //is possible from both GPIO and the sleep timer.  System time
    194                //is maintained.  The sleep timer is assumed to be configured
    195                //properly for wake events.
    196                //NOTE: This mode assumes the caller has configured the *entire*
    197                //      sleep timer properly.
    198          
    199                if(INT_SLEEPTMRCFG&INT_SLEEPTMRWRAP) {
   \                     ??halInternalSleep_7: (+1)
   \   00000084   0x6C38             LDR      R0,[R7, #+64]
   \   00000086   0x07C0             LSLS     R0,R0,#+31
   \   00000088   0xD503             BPL.N    ??halInternalSleep_8
    200                  WAKE_SEL |= WAKE_SLEEPTMRWRAP;
   \   0000008A   0x69E0             LDR      R0,[R4, #+28]
   \   0000008C   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000090   0x61E0             STR      R0,[R4, #+28]
    201                }
    202                if(INT_SLEEPTMRCFG&INT_SLEEPTMRCMPB) {
   \                     ??halInternalSleep_8: (+1)
   \   00000092   0x6C38             LDR      R0,[R7, #+64]
   \   00000094   0x0740             LSLS     R0,R0,#+29
   \   00000096   0xD503             BPL.N    ??halInternalSleep_9
    203                  WAKE_SEL |= WAKE_SLEEPTMRCMPB;
   \   00000098   0x69E0             LDR      R0,[R4, #+28]
   \   0000009A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000009E   0x61E0             STR      R0,[R4, #+28]
    204                }
    205                if(INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) {
   \                     ??halInternalSleep_9: (+1)
   \   000000A0   0x6C38             LDR      R0,[R7, #+64]
   \   000000A2   0x0780             LSLS     R0,R0,#+30
   \   000000A4   0xD503             BPL.N    ??halInternalSleep_6
    206                  WAKE_SEL |= WAKE_SLEEPTMRCMPA;
   \   000000A6   0x69E0             LDR      R0,[R4, #+28]
   \   000000A8   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000AC   0x61E0             STR      R0,[R4, #+28]
    207                }
    208                //fall into SLEEPMODE_MAINTAINTIMER's sleep code:
    209          
    210              case SLEEPMODE_MAINTAINTIMER:
    211                //The sleep timer clock sources remain running.  The RC is always
    212                //running and the 32kHz XTAL depends on the board header.  Wakeup
    213                //is possible from only GPIO.  System time is maintained.
    214                //NOTE: System time is maintained without any sleep timer interrupts
    215                //      because the hardware sleep timer counter is large enough
    216                //      to hold the entire count value and not need a RAM counter.
    217          
    218              ////////////////////////////////////////////////////////////////////////////
    219              // Core deep sleep code
    220              ////////////////////////////////////////////////////////////////////////////
    221          deepSleepCore:
    222                // Interrupts *must* be/stay disabled for DEEP SLEEP operation
    223                // INTERRUPTS_OFF will use BASEPRI to disable all interrupts except
    224                // fault handlers.
    225                INTERRUPTS_OFF();
   \                     ??halInternalSleep_6: (+1)
   \   000000AE   0x.... 0x....      BL       _disableBasePri
    226                // This is the point of no return.  From here on out, only the interrupt
    227                // sources available in WAKE_SEL will be captured and propagated across
    228                // deep sleep.
    229                //stick all our saved info onto stack since it's only temporary
    230                {
    231                  bool restoreWatchdog = halInternalWatchDogEnabled();
   \   000000B2   0x.... 0x....      BL       halInternalWatchDogEnabled
   \   000000B6   0xF88D 0x003C      STRB     R0,[SP, #+60]
    232                  bool skipSleep = false;
   \   000000BA   0xF04F 0x0900      MOV      R9,#+0
    233          
    234                  #if defined(CORTEXM3_EM35X_GEN4)
    235                    // On the 358x we must configure the RAM_RETAIN register to set which
    236                    // blocks of RAM are maintained across deepsleep. This register is
    237                    // reset during deepsleep so we must do this every time.
    238                    uint32_t ramRetainValue = (1<<((RAM_SIZE_B - _UNRETAINED_RAM_SEGMENT_SIZE)/
    239                                                 RAM_RETAIN_BLOCK_SIZE)) - 1;
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable5_4
    240                    RAM_RETAIN = ramRetainValue;
   \   000000C2   0x.... 0x....      LDR.W    R10,??DataTable5_5  ;; 0x40004004
   \   000000C6   0xF5C1 0x3180      RSB      R1,R1,#+65536
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x0B09             LSRS     R1,R1,#+12
   \   000000CE   0xFA00 0xF101      LSL      R1,R0,R1
   \   000000D2   0x1E49             SUBS     R1,R1,#+1
   \   000000D4   0xF8CA 0x1038      STR      R1,[R10, #+56]
    241          
    242                    // If we're retaining less than half the RAM then try to save power
    243                    if((ramRetainValue>>(RETAIN_BITS/2)) == 0) {
   \   000000D8   0x0A09             LSRS     R1,R1,#+8
   \   000000DA   0xD107             BNE.N    ??halInternalSleep_10
    244                      // This only works on the newest dies so check for that here
    245                      uint8_t *ptr = (uint8_t*)(DATA_BIG_INFO_BASE | MFG_PART_DATA_LOCATION);
    246                      if(ptr[2] >= 0x01) {
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x8080798
   \   000000E0   0x7809             LDRB     R1,[R1, #+0]
   \   000000E2   0xB119             CBZ.N    R1,??halInternalSleep_10
    247                        RAM_TEST |= RAM_TEST_RAM_REGB; // Disable the unused RAM regulator
   \   000000E4   0x6C61             LDR      R1,[R4, #+68]
   \   000000E6   0xF041 0x0120      ORR      R1,R1,#0x20
   \   000000EA   0x6461             STR      R1,[R4, #+68]
    248                      }
    249                    }
    250                  #endif
    251          
    252                  // Only three register blocks keep power across deep sleep:
    253                  //  CM_HV, GPIO, SLOW_TIMERS
    254                  //
    255                  // All other register blocks lose their state across deep sleep:
    256                  //  BASEBAND, MAC, SECURITY, SERIAL, TMR1, TMR2, EVENT, CM_LV, RAM_CTRL,
    257                  //  AUX_ADC, CAL_ADC, FLASH_CONTROL, ITM, DWT, FPB, NVIC, TPIU
    258                  //
    259                  // The sleep code will only save and restore registers where it is
    260                  // meaningful and necessary to do so.  In most cases, there must still
    261                  // be a powerup function to restore proper state.
    262                  //
    263                  // NOTE: halPowerUp() and halPowerDown() will always be called before
    264                  // and after this function.  halPowerDown and halPowerUp should leave
    265                  // the modules in a safe state and then restart the modules.
    266                  // (For example, shutting down and restarting Timer1)
    267                  //
    268                  //----BASEBAND
    269                  //        reinitialized by emberStackPowerUp()
    270                  //----MAC
    271                  //        reinitialized by emberStackPowerUp()
    272                  //----SECURITY
    273                  //        reinitialized by emberStackPowerUp()
    274                  //----SERIAL
    275                  //        reinitialized by halPowerUp() or similar
    276                  //----TMR1
    277                  //        reinitialized by halPowerUp() or similar
    278                  //----TMR2
    279                  //        reinitialized by halPowerUp() or similar
    280                  //----EVENT
    281                  //SRC or FLAG interrupts are not saved or restored
    282                  //MISS interrupts are not saved or restored
    283                  //MAC_RX_INT_MASK - reinitialized by emberStackPowerUp()
    284                  //MAC_TX_INT_MASK - reinitialized by emberStackPowerUp()
    285                  //MAC_TIMER_INT_MASK - reinitialized by emberStackPowerUp()
    286                  //BB_INT_MASK - reinitialized by emberStackPowerUp()
    287                  //SEC_INT_MASK - reinitialized by emberStackPowerUp()
    288                  uint32_t INT_SLEEPTMRCFG_SAVED = INT_SLEEPTMRCFG_REG;
   \                     ??halInternalSleep_10: (+1)
   \   000000EC   0x6C39             LDR      R1,[R7, #+64]
   \   000000EE   0x.... 0x....      LDR.W    R8,??DataTable5_7  ;; 0x4000a814
   \   000000F2   0x.... 0x....      LDR.W    R2,??DataTable5_8  ;; 0xe000ed08
   \   000000F6   0x910E             STR      R1,[SP, #+56]
    289                  uint32_t INT_MGMTCFG_SAVED = INT_MGMTCFG_REG;
   \   000000F8   0x6C79             LDR      R1,[R7, #+68]
   \   000000FA   0x910D             STR      R1,[SP, #+52]
    290                  //INT_TIM1CFG - reinitialized by halPowerUp() or similar
    291                  //INT_TIM2CFG - reinitialized by halPowerUp() or similar
    292                  //INT_SC1CFG - reinitialized by halPowerUp() or similar
    293                  //INT_SC2CFG - reinitialized by halPowerUp() or similar
    294                  //INT_ADCCFG - reinitialized by halPowerUp() or similar
    295                  uint32_t GPIO_INTCFGA_SAVED = GPIO_INTCFGA_REG;
   \   000000FC   0xF8D8 0x104C      LDR      R1,[R8, #+76]
   \   00000100   0x910C             STR      R1,[SP, #+48]
    296                  uint32_t GPIO_INTCFGB_SAVED = GPIO_INTCFGB_REG;
   \   00000102   0xF8D8 0x1050      LDR      R1,[R8, #+80]
   \   00000106   0x910B             STR      R1,[SP, #+44]
    297                  uint32_t GPIO_INTCFGC_SAVED = GPIO_INTCFGC_REG;
   \   00000108   0xF8D8 0x1054      LDR      R1,[R8, #+84]
   \   0000010C   0x910A             STR      R1,[SP, #+40]
    298                  uint32_t GPIO_INTCFGD_SAVED = GPIO_INTCFGD_REG;
   \   0000010E   0xF8D8 0x1058      LDR      R1,[R8, #+88]
   \   00000112   0x9109             STR      R1,[SP, #+36]
    299                  //SC1_INTMODE - reinitialized by halPowerUp() or similar
    300                  //SC2_INTMODE - reinitialized by halPowerUp() or similar
    301                  //----CM_LV
    302                  uint32_t OSC24M_BIASTRIM_SAVED = OSC24M_BIASTRIM_REG;
   \   00000114   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \   00000118   0x9108             STR      R1,[SP, #+32]
    303                  uint32_t OSCHF_TUNE_SAVED = OSCHF_TUNE_REG;
   \   0000011A   0xF8DA 0x1004      LDR      R1,[R10, #+4]
   \   0000011E   0x9107             STR      R1,[SP, #+28]
    304                  uint32_t DITHER_DIS_SAVED = DITHER_DIS_REG;
   \   00000120   0xF8DA 0x1014      LDR      R1,[R10, #+20]
   \   00000124   0x9106             STR      R1,[SP, #+24]
    305                  //OSC24M_CTRL - reinitialized by halPowerUp() or similar
    306                  //CPU_CLKSEL  - reinitialized by halPowerUp() or similar
    307                  //TMR1_CLK_SEL - reinitialized by halPowerUp() or similar
    308                  //TMR2_CLK_SEL - reinitialized by halPowerUp() or similar
    309                  uint32_t PCTRACE_SEL_SAVED = PCTRACE_SEL_REG;
   \   00000126   0xF8DA 0x1024      LDR      R1,[R10, #+36]
   \   0000012A   0x9105             STR      R1,[SP, #+20]
    310                  #ifdef PERIPHERAL_DISABLE
    311                    //Not every chip has PERIPHERAL_DISABLE
    312                    uint32_t PERIPHERAL_DISABLE_SAVED = PERIPHERAL_DISABLE;
   \   0000012C   0xF8DA 0x1034      LDR      R1,[R10, #+52]
   \   00000130   0x9104             STR      R1,[SP, #+16]
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable5_9  ;; 0xe000e100
   \   00000136   0x6809             LDR      R1,[R1, #+0]
   \   00000138   0x6812             LDR      R2,[R2, #+0]
   \   0000013A   0x9203             STR      R2,[SP, #+12]
    313                  #endif
    314                  //----RAM_CTRL
    315                  #if !defined(CORTEXM3_EM35X_GEN4)
    316                    uint32_t MEM_PROT_0_SAVED = MEM_PROT_0_REG;
    317                    uint32_t MEM_PROT_1_SAVED = MEM_PROT_1_REG;
    318                    uint32_t MEM_PROT_2_SAVED = MEM_PROT_2_REG;
    319                    uint32_t MEM_PROT_3_SAVED = MEM_PROT_3_REG;
    320                    uint32_t MEM_PROT_4_SAVED = MEM_PROT_4_REG;
    321                    uint32_t MEM_PROT_5_SAVED = MEM_PROT_5_REG;
    322                    uint32_t MEM_PROT_6_SAVED = MEM_PROT_6_REG;
    323                    uint32_t MEM_PROT_7_SAVED = MEM_PROT_7_REG;
    324                    uint32_t MEM_PROT_EN_SAVED = MEM_PROT_EN_REG;
    325                  #endif //!defined(CORTEXM3_EM35X_GEN4)
    326                  //----AUX_ADC
    327                  //        reinitialized by halPowerUp() or similar
    328                  //----CAL_ADC
    329                  //        reinitialized by emberStackPowerUp()
    330                  //----FLASH_CONTROL
    331                  //        configured on the fly by the flash library
    332                  //----ITM
    333                  //        reinitialized by halPowerUp() or similar
    334                  //----DWT
    335                  //        not used by software on chip
    336                  //----FPB
    337                  //        not used by software on chip
    338                  //----NVIC
    339                  //ST_CSR - fixed, restored by cstartup when exiting deep sleep
    340                  //ST_RVR - fixed, restored by cstartup when exiting deep sleep
    341                  uint32_t INT_CFGSET_SAVED = INT_CFGSET_REG; //mask against wake sources
    342                  //INT_PENDSET - used below when overlapping interrupts and wake sources
    343                  //NVIC_IPR_3to0 - fixed, restored by cstartup when exiting deep sleep
    344                  //NVIC_IPR_7to4 - fixed, restored by cstartup when exiting deep sleep
    345                  //NVIC_IPR_11to8 - fixed, restored by cstartup when exiting deep sleep
    346                  //NVIC_IPR_15to12 - fixed, restored by cstartup when exiting deep sleep
    347                  //NVIC_IPR_19to16 - fixed, restored by cstartup when exiting deep sleep
    348                  uint32_t SCS_VTOR_SAVED = SCS_VTOR_REG;
    349                  //SCS_CCR - fixed, restored by cstartup when exiting deep sleep
    350                  //SCS_SHPR_7to4 - fixed, restored by cstartup when exiting deep sleep
    351                  //SCS_SHPR_11to8 - fixed, restored by cstartup when exiting deep sleep
    352                  //SCS_SHPR_15to12 - fixed, restored by cstartup when exiting deep sleep
    353                  //SCS_SHCSR - fixed, restored by cstartup when exiting deep sleep
    354                  //----TPIU
    355                  //        reinitialized by halPowerUp() or similar
    356          
    357                  //emDebugPowerDown() should have shutdown the DWT/ITM/TPIU already.
    358          
    359                  //freeze input to the GPIO from LV (alternate output functions freeze)
    360                  EVENT_CTRL = LV_FREEZE;
   \   0000013C   0x2202             MOVS     R2,#+2
   \   0000013E   0x6022             STR      R2,[R4, #+0]
   \   00000140   0x.... 0x....      LDR.W    R2,??DataTable5_10  ;; 0x4000b008
   \   00000144   0x6812             LDR      R2,[R2, #+0]
   \   00000146   0xF88D 0x2004      STRB     R2,[SP, #+4]
   \   0000014A   0x.... 0x....      LDR.W    R2,??DataTable5_11  ;; 0x4000b208
   \   0000014E   0x6812             LDR      R2,[R2, #+0]
   \   00000150   0xF88D 0x2005      STRB     R2,[SP, #+5]
   \   00000154   0x.... 0x....      LDR.W    R2,??DataTable5_12  ;; 0x4000b408
   \   00000158   0x6812             LDR      R2,[R2, #+0]
   \   0000015A   0xF88D 0x2006      STRB     R2,[SP, #+6]
   \   0000015E   0xF04F 0x32FF      MOV      R2,#-1
   \   00000162   0x6262             STR      R2,[R4, #+36]
   \   00000164   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000168   0x04D2             LSLS     R2,R2,#+19
   \   0000016A   0xD50A             BPL.N    ??halInternalSleep_11
   \   0000016C   0x686A             LDR      R2,[R5, #+4]
   \   0000016E   0x07D2             LSLS     R2,R2,#+31
   \   00000170   0xD507             BPL.N    ??halInternalSleep_11
   \   00000172   0x69E2             LDR      R2,[R4, #+28]
   \   00000174   0x07D2             LSLS     R2,R2,#+31
   \   00000176   0xD504             BPL.N    ??halInternalSleep_11
    361                  //record GPIO state for wake monitoring purposes
    362                  //By having a snapshot of GPIO state, we can figure out after waking
    363                  //up exactly which GPIO could have woken us up.
    364                  //Reading the three IN registers is done separately to avoid warnings
    365                  //about undefined order of volatile access.
    366                  WakeEvents GPIO_IN_SAVED;
    367                  GPIO_IN_SAVED.events.portA = GPIO_PAIN;
    368                  GPIO_IN_SAVED.events.portB = GPIO_PBIN;
    369                  GPIO_IN_SAVED.events.portC = GPIO_PCIN;
    370                #ifdef EMBER_MICRO_PORT_D_GPIO
    371                  GPIO_IN_SAVED.events.portD = GPIO_PDIN;
    372                #endif
    373                #ifdef EMBER_MICRO_PORT_E_GPIO
    374                  GPIO_IN_SAVED.events.portE = GPIO_PEIN;
    375                #endif
    376                #ifdef EMBER_MICRO_PORT_F_GPIO
    377                  GPIO_IN_SAVED.events.portF = GPIO_PFIN;
    378                #endif
    379                  //reset the power up events by writing 1 to all bits.
    380                  PWRUP_EVENT = 0xFFFFFFFF;
    381                  //[[
    382                  SLEEP_TRACE_ADD_MARKER('A');
    383                  //]]
    384                  //By clearing the events, the wake up event capturing is activated.
    385                  //At this point we can safely check our interrupt flags since event
    386                  //capturing is now overlapped.  Up to now, interrupts indicate
    387                  //activity, after this point, powerup events indicate activity.
    388                  //If any of the interrupt flags are set, that means we saw a wake event
    389                  //sometime while entering sleep, so we need to skip over sleeping
    390                  //
    391                  //--possible interrupt sources for waking:
    392                  //  IRQA, IRQB, IRQC, IRQD
    393                  //  SleepTMR CMPA, CMPB, Wrap
    394                  //  WAKE_CORE (DebugIsr)
    395                  //
    396                  #if defined(EMBER_MICRO_PORT_B_GPIO)
    397                    #if EMBER_MICRO_PORT_B_GPIO & PB0
    398                      //check for IRQA interrupt and if IRQA (PB0) is wake source
    399                      if((INT_PENDSET&INT_IRQA) &&
    400                         (GPIO_PBWAKE&PB0) &&
    401                         (WAKE_SEL&GPIO_WAKE)) {
    402                        skipSleep = true;
    403                        //log IRQA as a wake event
    404                        halInternalWakeEvent.eventflags |= BIT(PORTB_PIN(0));
   \   00000178   0x6832             LDR      R2,[R6, #+0]
   \   0000017A   0xF442 0x7280      ORR      R2,R2,#0x100
   \   0000017E   0x4681             MOV      R9,R0
   \   00000180   0x6032             STR      R2,[R6, #+0]
    405                        //[[
    406                        SLEEP_TRACE_ADD_MARKER('B');
    407                        //]]
    408                      }
    409                    #endif
    410                    #if EMBER_MICRO_PORT_B_GPIO & PB6
    411                      //check for IRQB interrupt and if IRQB (PB6) is wake source
    412                      if((INT_PENDSET&INT_IRQB) &&
    413                         (GPIO_PBWAKE&PB6) &&
    414                         (WAKE_SEL&GPIO_WAKE)) {
   \                     ??halInternalSleep_11: (+1)
   \   00000182   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000186   0x0492             LSLS     R2,R2,#+18
   \   00000188   0xD50A             BPL.N    ??halInternalSleep_12
   \   0000018A   0x686A             LDR      R2,[R5, #+4]
   \   0000018C   0x0652             LSLS     R2,R2,#+25
   \   0000018E   0xD507             BPL.N    ??halInternalSleep_12
   \   00000190   0x69E2             LDR      R2,[R4, #+28]
   \   00000192   0x07D2             LSLS     R2,R2,#+31
   \   00000194   0xD504             BPL.N    ??halInternalSleep_12
    415                        skipSleep = true;
    416                        //log IRQB as a wake event
    417                        halInternalWakeEvent.eventflags |= BIT(PORTB_PIN(6));
   \   00000196   0x6832             LDR      R2,[R6, #+0]
   \   00000198   0xF442 0x4280      ORR      R2,R2,#0x4000
   \   0000019C   0x4681             MOV      R9,R0
   \   0000019E   0x6032             STR      R2,[R6, #+0]
    418                        //[[
    419                        SLEEP_TRACE_ADD_MARKER('C');
    420                        //]]
    421                      }
    422                    #endif
    423                  #endif
    424                  //check for IRQC interrupt and if IRQC (GPIO_IRQCSEL) is wake source
    425                  if((INT_PENDSET&INT_IRQC) &&
    426                     (gpioWakeSel&BIT(GPIO_IRQCSEL)) &&
    427                     (WAKE_SEL&GPIO_WAKE)) {
   \                     ??halInternalSleep_12: (+1)
   \   000001A0   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   000001A4   0x0452             LSLS     R2,R2,#+17
   \   000001A6   0xD50E             BPL.N    ??halInternalSleep_13
   \   000001A8   0x9A00             LDR      R2,[SP, #+0]
   \   000001AA   0x69AB             LDR      R3,[R5, #+24]
   \   000001AC   0x40DA             LSRS     R2,R2,R3
   \   000001AE   0x07D2             LSLS     R2,R2,#+31
   \   000001B0   0xD509             BPL.N    ??halInternalSleep_13
   \   000001B2   0x69E2             LDR      R2,[R4, #+28]
   \   000001B4   0x07D2             LSLS     R2,R2,#+31
   \   000001B6   0xD506             BPL.N    ??halInternalSleep_13
    428                    skipSleep = true;
    429                    //log IRQC as a wake event
    430                    halInternalWakeEvent.eventflags |= BIT(GPIO_IRQCSEL);
   \   000001B8   0x6832             LDR      R2,[R6, #+0]
   \   000001BA   0x69AB             LDR      R3,[R5, #+24]
   \   000001BC   0xFA00 0xF303      LSL      R3,R0,R3
   \   000001C0   0x431A             ORRS     R2,R3,R2
   \   000001C2   0x4681             MOV      R9,R0
   \   000001C4   0x6032             STR      R2,[R6, #+0]
    431                    //[[
    432                    SLEEP_TRACE_ADD_MARKER('D');
    433                    //]]
    434                  }
    435                  //check for IRQD interrupt and if IRQD (GPIO_IRQDSEL) is wake source
    436                  if((INT_PENDSET&INT_IRQD) &&
    437                     (gpioWakeSel&BIT(GPIO_IRQDSEL)) &&
    438                     ((WAKE_SEL&GPIO_WAKE) ||
    439                      (WAKE_SEL&WAKE_IRQD))) {
   \                     ??halInternalSleep_13: (+1)
   \   000001C6   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000001CA   0x0412             LSLS     R2,R2,#+16
   \   000001CC   0xD510             BPL.N    ??halInternalSleep_14
   \   000001CE   0x9A00             LDR      R2,[SP, #+0]
   \   000001D0   0x69EB             LDR      R3,[R5, #+28]
   \   000001D2   0x40DA             LSRS     R2,R2,R3
   \   000001D4   0x07D2             LSLS     R2,R2,#+31
   \   000001D6   0xD50B             BPL.N    ??halInternalSleep_14
   \   000001D8   0x69E2             LDR      R2,[R4, #+28]
   \   000001DA   0x07D2             LSLS     R2,R2,#+31
   \   000001DC   0xD402             BMI.N    ??halInternalSleep_15
   \   000001DE   0x69E2             LDR      R2,[R4, #+28]
   \   000001E0   0x0712             LSLS     R2,R2,#+28
   \   000001E2   0xD505             BPL.N    ??halInternalSleep_14
    440                    skipSleep = true;
    441                    //log IRQD as a wake event
    442                    halInternalWakeEvent.eventflags |= BIT(GPIO_IRQDSEL);
   \                     ??halInternalSleep_15: (+1)
   \   000001E4   0x6832             LDR      R2,[R6, #+0]
   \   000001E6   0x69EB             LDR      R3,[R5, #+28]
   \   000001E8   0x4681             MOV      R9,R0
   \   000001EA   0x4098             LSLS     R0,R0,R3
   \   000001EC   0x4310             ORRS     R0,R0,R2
   \   000001EE   0x6030             STR      R0,[R6, #+0]
    443                    //[[
    444                    SLEEP_TRACE_ADD_MARKER('E');
    445                    //]]
    446                  }
    447                  //check for SleepTMR CMPA interrupt and if SleepTMR CMPA is wake source
    448                  if((INT_SLEEPTMR&INT_SLEEPTMRCMPA) && (WAKE_SEL&WAKE_SLEEPTMRCMPA)) {
    449                    skipSleep = true;
    450                    //log SleepTMR CMPA as a wake event
    451                    halInternalWakeEvent.events.internal.bits.TIMER_WAKE_COMPA = true;
    452                    //[[
    453                    SLEEP_TRACE_ADD_MARKER('F');
    454                    //]]
    455                  }
    456                  //check for SleepTMR CMPB interrupt and if SleepTMR CMPB is wake source
    457                  if((INT_SLEEPTMR&INT_SLEEPTMRCMPB) && (WAKE_SEL&WAKE_SLEEPTMRCMPB)) {
    458                    skipSleep = true;
    459                    //log SleepTMR CMPB as a wake event
    460                    halInternalWakeEvent.events.internal.bits.TIMER_WAKE_COMPB = true;
    461                    //[[
    462                    SLEEP_TRACE_ADD_MARKER('G');
    463                    //]]
    464                  }
    465                  //check for SleepTMR WRAP interrupt and if SleepTMR WRAP is wake source
    466                  if((INT_SLEEPTMR&INT_SLEEPTMRWRAP) && (WAKE_SEL&WAKE_SLEEPTMRWRAP)) {
    467                    skipSleep = true;
    468                    //log SleepTMR WRAP as a wake event
    469                    halInternalWakeEvent.events.internal.bits.TIMER_WAKE_WRAP = true;
    470                    //[[
    471                    SLEEP_TRACE_ADD_MARKER('H');
    472                    //]]
    473                  }
    474                  //check for Debug interrupt and if WAKE_CORE is wake source
    475                  if((INT_PENDSET&INT_DEBUG) && (WAKE_SEL&WAKE_WAKE_CORE)) {
   \                     ??halInternalSleep_14: (+1)
   \   000001F0   0x....             LDR.N    R0,??DataTable5_13  ;; 0xe000e200
   \   000001F2   0x6800             LDR      R0,[R0, #+0]
   \   000001F4   0x03C0             LSLS     R0,R0,#+15
   \   000001F6   0xD508             BPL.N    ??halInternalSleep_16
   \   000001F8   0x69E0             LDR      R0,[R4, #+28]
   \   000001FA   0x0600             LSLS     R0,R0,#+24
   \   000001FC   0xD505             BPL.N    ??halInternalSleep_16
    476                    skipSleep = true;
    477                    //log WAKE_CORE as a wake event
    478                    halInternalWakeEvent.events.internal.bits.WAKE_CORE_B = true;
   \   000001FE   0x78F0             LDRB     R0,[R6, #+3]
   \   00000200   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000204   0xF04F 0x0901      MOV      R9,#+1
   \   00000208   0x70F0             STRB     R0,[R6, #+3]
    479                    //[[
    480                    SLEEP_TRACE_ADD_MARKER('I');
    481                    //]]
    482                  }
    483          
    484                  //only propagate across deep sleep the interrupts that are both
    485                  //enabled and possible wake sources
    486                  {
    487                    uint32_t wakeSourceInterruptMask = 0;
   \                     ??halInternalSleep_16: (+1)
   \   0000020A   0x2000             MOVS     R0,#+0
   \   0000020C   0x686A             LDR      R2,[R5, #+4]
   \   0000020E   0x07D2             LSLS     R2,R2,#+31
    488          
    489                    if(GPIO_PBWAKE&PB0) {
    490                      wakeSourceInterruptMask |= INT_IRQA;
    491                      //[[
    492                      SLEEP_TRACE_ADD_MARKER('J');
    493                      //]]
    494                    }
    495                    if(GPIO_PBWAKE&PB6) {
   \   00000210   0x686A             LDR      R2,[R5, #+4]
   \   00000212   0xBF48             IT       MI 
   \   00000214   0xF44F 0x5080      MOVMI    R0,#+4096
   \   00000218   0x0652             LSLS     R2,R2,#+25
    496                      wakeSourceInterruptMask |= INT_IRQB;
    497                      //[[
    498                      SLEEP_TRACE_ADD_MARKER('K');
    499                      //]]
    500                    }
    501                    if(gpioWakeSel&BIT(GPIO_IRQCSEL)) {
   \   0000021A   0x9A00             LDR      R2,[SP, #+0]
   \   0000021C   0x69AB             LDR      R3,[R5, #+24]
   \   0000021E   0xBF48             IT       MI 
   \   00000220   0xF440 0x5000      ORRMI    R0,R0,#0x2000
   \   00000224   0x40DA             LSRS     R2,R2,R3
   \   00000226   0x07D2             LSLS     R2,R2,#+31
    502                      wakeSourceInterruptMask |= INT_IRQC;
    503                      //[[
    504                      SLEEP_TRACE_ADD_MARKER('L');
    505                      //]]
    506                    }
    507                    if(gpioWakeSel&BIT(GPIO_IRQDSEL)) {
   \   00000228   0x9A00             LDR      R2,[SP, #+0]
   \   0000022A   0x69EB             LDR      R3,[R5, #+28]
   \   0000022C   0xBF48             IT       MI 
   \   0000022E   0xF440 0x4080      ORRMI    R0,R0,#0x4000
   \   00000232   0x40DA             LSRS     R2,R2,R3
   \   00000234   0x07D2             LSLS     R2,R2,#+31
    508                      wakeSourceInterruptMask |= INT_IRQD;
    509                      //[[
    510                      SLEEP_TRACE_ADD_MARKER('M');
    511                      //]]
    512                    }
    513                    if( (WAKE_SEL&WAKE_SLEEPTMRCMPA) ||
    514                        (WAKE_SEL&WAKE_SLEEPTMRCMPB) ||
    515                        (WAKE_SEL&WAKE_SLEEPTMRWRAP) ) {
   \   00000236   0x69E2             LDR      R2,[R4, #+28]
   \   00000238   0xBF48             IT       MI 
   \   0000023A   0xF440 0x4000      ORRMI    R0,R0,#0x8000
   \   0000023E   0x06D2             LSLS     R2,R2,#+27
   \   00000240   0xD405             BMI.N    ??halInternalSleep_17
   \   00000242   0x69E2             LDR      R2,[R4, #+28]
   \   00000244   0x0692             LSLS     R2,R2,#+26
   \   00000246   0xD402             BMI.N    ??halInternalSleep_17
   \   00000248   0x69E2             LDR      R2,[R4, #+28]
   \   0000024A   0x0652             LSLS     R2,R2,#+25
   \   0000024C   0xD501             BPL.N    ??halInternalSleep_18
    516                      wakeSourceInterruptMask |= INT_SLEEPTMR;
   \                     ??halInternalSleep_17: (+1)
   \   0000024E   0xF040 0x0010      ORR      R0,R0,#0x10
    517                      //[[
    518                      SLEEP_TRACE_ADD_MARKER('N');
    519                      //]]
    520                    }
    521                    if(WAKE_SEL&WAKE_WAKE_CORE) {
   \                     ??halInternalSleep_18: (+1)
   \   00000252   0x69E2             LDR      R2,[R4, #+28]
   \   00000254   0x0612             LSLS     R2,R2,#+24
   \   00000256   0xBF48             IT       MI 
   \   00000258   0xF440 0x3080      ORRMI    R0,R0,#0x10000
    522                      wakeSourceInterruptMask |= INT_DEBUG;
    523                      //[[
    524                      SLEEP_TRACE_ADD_MARKER('O');
    525                      //]]
    526                    }
    527          
    528                    INT_CFGSET_SAVED &= wakeSourceInterruptMask;
   \   0000025C   0x4008             ANDS     R0,R0,R1
   \   0000025E   0x9002             STR      R0,[SP, #+8]
    529                  }
    530          
    531                  //[[
    532                  //Since it is possible to perform a deep sleep cycle without actually
    533                  //leaving the running state (a wake source was captured while
    534                  //entering deep sleep or CSYSPWRUPREQ remained set), it is possible for
    535                  //the application to perform a sleep cycle and not have the entire
    536                  //low voltage domain reset.  In theory, the application is responsible
    537                  //for cleanly shutting down the entire chip and then bringing
    538                  //it back up around a sleep cycle (stack and hal sleep/powerup).  In
    539                  //practice, though, the safest thing to do is shut down the entire
    540                  //low voltage domain while entering deep sleep.  By doing this,
    541                  //we ensure the application always has the same sleep cycle operation
    542                  //and does not experience accidental peripheral operation that should
    543                  //not have survived.
    544                  halInternalMimickLvReset();
    545                  //]]
    546          
    547                  //disable watchdog while sleeping (since we can't reset it asleep)
    548                  halInternalDisableWatchDog(MICRO_DISABLE_WATCH_DOG_KEY);
   \   00000260   0x20A5             MOVS     R0,#+165
   \   00000262   0x.... 0x....      BL       halInternalDisableWatchDog
    549          
    550                  //The chip is not allowed to enter a deep sleep mode (which could
    551                  //cause a core reset cycle) while CSYSPWRUPREQ is set.  CSYSPWRUPREQ
    552                  //indicates that the debugger is trying to access sections of the
    553                  //chip that would get reset during deep sleep.  Therefore, a reset
    554                  //cycle could very easily cause the debugger to error and we don't
    555                  //want that.  While the power management state machine will stall
    556                  //if CSYSPWRUPREQ is set (to avoid the situation just described),
    557                  //in this stalled state the chip will not be responsive to wake
    558                  //events.  To be sensitive to wake events, we must handle them in
    559                  //software instead.  To accomplish this, we request that the
    560                  //CSYSPWRUPACK be inhibited (which will indicate the debugger is not
    561                  //connected).  But, we cannot induce deep sleep until CSYSPWRUPREQ/ACK
    562                  //go low and these are under the debuggers control, so we must stall
    563                  //and wait here.  If there is a wake event during this time, break
    564                  //out and wake like normal.  If the ACK eventually clears,
    565                  //we can proceed into deep sleep.  The CSYSPWRUPACK_INHIBIT
    566                  //functionality will hold off the debugger (by holding off the ACK)
    567                  //until we are safely past and out of deep sleep.  The power management
    568                  //state machine then becomes responsible for clearing
    569                  //CSYSPWRUPACK_INHIBIT and responding to a CSYSPWRUPREQ with a
    570                  //CSYSPWRUPACK at the right/safe time.
    571                  CSYSPWRUPACK_INHIBIT = CSYSPWRUPACK_INHIBIT_CSYSPWRUPACK_INHIBIT;
   \   00000266   0x2001             MOVS     R0,#+1
   \   00000268   0x63E0             STR      R0,[R4, #+60]
    572                  {
    573                    //Use a local copy of WAKE_SEL to avoid warnings from the compiler
    574                    //about order of volatile accesses
    575                    uint32_t wakeSel = WAKE_SEL;
   \   0000026A   0x69E0             LDR      R0,[R4, #+28]
    576                    //stall until a wake event or CSYSPWRUPREQ/ACK clears
    577                    while( (CSYSPWRUPACK_STATUS) && (!(PWRUP_EVENT&wakeSel)) ) {}
   \                     ??halInternalSleep_19: (+1)
   \   0000026C   0x6BA1             LDR      R1,[R4, #+56]
   \   0000026E   0xB111             CBZ.N    R1,??halInternalSleep_20
   \   00000270   0x6A61             LDR      R1,[R4, #+36]
   \   00000272   0x4201             TST      R1,R0
   \   00000274   0xD0FA             BEQ.N    ??halInternalSleep_19
    578                    //if there was a wake event, allow CSYSPWRUPACK and skip sleep
    579                    if(PWRUP_EVENT&wakeSel) {
   \                     ??halInternalSleep_20: (+1)
   \   00000276   0x6A61             LDR      R1,[R4, #+36]
   \   00000278   0x4201             TST      R1,R0
   \   0000027A   0xF000 0x80CA      BEQ.W    ??halInternalSleep_21
    580                      CSYSPWRUPACK_INHIBIT = CSYSPWRUPACK_INHIBIT_RESET;
   \   0000027E   0x2000             MOVS     R0,#+0
   \   00000280   0x63E0             STR      R0,[R4, #+60]
    581                      skipSleep = true;
    582                    }
    583                  }
    584          
    585          
    586                  //[[
    587                  SLEEP_TRACE_ADD_MARKER('P');
    588                  //]]
    589                  if(!skipSleep) {
    590                    //[[
    591                    SLEEP_TRACE_ADD_MARKER('Q');
    592                    //]]
    593                    //FogBugz 7283 states that we must switch to the OSCHF when entering
    594                    //deep sleep since using the 24MHz XTAL could result in RAM
    595                    //corruption.  This switch must occur at least 2*24MHz cycles before
    596                    //sleeping.
    597                    //
    598                    //FogBugz 8858 states that we cannot go into deep-sleep when the
    599                    //chip is clocked with the 24MHz XTAL with a duty cycle as low as
    600                    //70/30 since this causes power_down generation timing to fail.
    601                    //
    602                    //Hekla-S-003_Digital_specification.doc#21 states:  "Note that
    603                    //in Lipari there was a requirement to set the clock into OSCHF
    604                    //mode prior to entering deep sleep. This was a limitation brought
    605                    //about from an early version of the RAM IP used in Lipari and does
    606                    //not apply to Hekla so that requirement is removed."  But since
    607                    //continuing to switch the clock does not dramatically affect
    608                    //behavior and we prefer to keep our code as common as we can
    609                    //between 3xx chips, we still switch the clock for 358x/359.
    610                    OSC24M_CTRL &= ~OSC24M_CTRL_OSC24M_SEL;
    611                    //If DS12 needs to be forced regardless of state, clear
    612                    //REGEN_DSLEEP here.  This is hugely dangerous and
    613                    //should only be done in very controlled chip tests.
    614                    SCS_SCR |= SCS_SCR_SLEEPDEEP;      //enable deep sleep
    615          
    616          #ifdef BOOTLOADER_OPEN
    617                    void bootloaderInternalSaveContextAndDeepSleep(void);
    618          
    619                    // We don't have interrupts in the bootloader, so we can't just use
    620                    // SCS_ICSR to trigger a PendSV. So we manually call a function that
    621                    // pushes all registers on the stack and enters deep sleep via a WFI
    622                    // instruction.
    623                    //
    624          
    625                    // NOTE: Only set the reset reason in the bootloader. See bugzid 14827
    626                    // for more information.
    627                    // Also note that we leave the resetReason intact after waking up and restoring
    628                    // since resetReason is used in cstartup-iar.c during startup.
    629                    halResetInfo.crash.resetReason    = RESET_BOOTLOADER_DEEPSLEEP;
    630                    halResetInfo.crash.resetSignature = RESET_VALID_SIGNATURE;
    631          
    632                    bootloaderInternalSaveContextAndDeepSleep();
    633                    //I AM ASLEEP.  WHEN EXECUTION RESUMES, CSTARTUP WILL RESTORE TO HERE
    634          
    635                    extern bool sleepTimerInterruptOccurred;
    636          
    637                    // In normal non-bootloader sleep situations here's what would happen
    638                    // after we wakeup from deep sleep:
    639                    //
    640                    // 1. The INT_SLEEPTMRCFG register is restored (search for
    641                    //    INT_SLEEPTMRCFG_REG below). We know that this will have the
    642                    //    INT_SLEEPTMRCMPA bit set, because that's what we use for sleep.
    643                    // 2. This "if(sleep int triggered)?" test is true:
    644                    //      if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) &&
    645                    //          (halInternalWakeEvent&BIT(CMPA_INTERNAL_WAKE_EVENT_BIT)) )
    646                    //    And because it's true, the code below forces the sleep interrupt
    647                    //    like this:
    648                    //      INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPA;
    649                    // 3. The halSleepTimerIsr would clear INT_SLEEPTMRCFG and then set
    650                    //    sleepTimerInterruptOccurred to true.
    651                    //
    652                    // But we're in the bootloader deep sleep case, so we don't have that
    653                    // ISR (or any interrupts, actually!).
    654                    //
    655                    // So we'll handle it ourselves here by:
    656                    // 1. Setting sleepTimerInterruptOccurred to true.
    657                    // 2. Clearing the INT_SLEEPTMRCFG_SAVED variable so when it's
    658                    //    restored to INT_SLEEPTMRCFG_REG the "if(sleep int triggered)?"
    659                    //    will be false, and the deep sleep interrupt won't be forced.
    660                    sleepTimerInterruptOccurred = true;
    661          
    662                    INT_SLEEPTMRCFG_SAVED = 0;
    663          
    664                    // Invalidate the reset reason.
    665                    // Bugzid-14827: Only do this when in a bootloader because otherwise
    666                    // we will overwrite heap data like packetbuffers.
    667                    halResetInfo.crash.resetSignature = RESET_INVALID_SIGNATURE;
    668          #elif defined(MINIMAL_HAL)
    669                    //Call the context save restore function to trigger a context save.
    670                    halInternalContextSaveRestore(true);
    671                    //I AM ASLEEP.  WHEN EXECUTION RESUMES, CSTARTUP WILL RESTORE TO HERE
    672          #else
    673          #ifndef MINIMAL_HAL
    674                    // NOTE: Only bootloader sets the reset reason to allow deep sleep
    675                    // wakeup to know upon wake to stay in bootloader.  App does not
    676                    // set this, because this RAM is used for heap data (bugzid 14827),
    677                    // however app makes sure wakeup won't be fooled by happenstance
    678                    // if the heap actually contains the bootloader's pattern.
    679                    if ( halResetInfo.crash.resetReason == RESET_BOOTLOADER_DEEPSLEEP
    680                       &&halResetInfo.crash.resetSignature == RESET_VALID_SIGNATURE ) {
    681                      // temporarily corrupt resetSignature so wakeup returns here
    682                      // to app rather than thinking it's the bootloader that slept
    683                      halResetInfo.crash.resetSignature = RESET_INVALID_SIGNATURE;
    684                      // Hack repurpose skipSleep local as signal to post-wakeup code
    685                      skipSleep = true; // Signal to wakeup code below to restore
    686                    }
    687          #endif//MINIMAL_HAL
    688          
    689                    //Call the context save restore function to trigger a context save.
    690                    halInternalContextSaveRestore(true);
    691                    //I AM ASLEEP.  WHEN EXECUTION RESUMES, CSTARTUP WILL RESTORE TO HERE
    692          
    693          #ifndef MINIMAL_HAL
    694                    // If signalled above that we had to corrupt heap temporarily
    695                    // during sleep, restore it now upon wakeup!
    696                    if (skipSleep) {
    697                      halResetInfo.crash.resetSignature = RESET_VALID_SIGNATURE;
    698                      skipSleep = false; // Done with repurposed local, restore it too
    699                    }
    700          #endif//MINIMAL_HAL
    701          #endif // BOOTLOADER_OPEN
    702          
    703                   #ifndef CORTEXM3_EM35X_GEN4 // HW bug fixed in GEN4
    704                    //Save the value of the SLEEPTMR_CNT register immediately after
    705                    //waking up from a real sleep.  For FogBugz 11909/11920 workaround.
    706                    wakeupSleepTmrCnt = SLEEPTMR_CNTH<<16;
    707                    wakeupSleepTmrCnt |= SLEEPTMR_CNTL;
    708                   #endif//CORTEXM3_EM35X_GEN4 // HW bug fixed in GEN4
    709                  } else {
    710                    //Record the fact that we skipped sleep
    711                    halInternalWakeEvent.events.internal.bits.SleepSkipped = true;
   \                     ??halInternalSleep_22: (+1)
   \   00000282   0x78F0             LDRB     R0,[R6, #+3]
   \   00000284   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000288   0x70F0             STRB     R0,[R6, #+3]
    712                    //If this was a true deep sleep, we would have executed cstartup and
    713                    //PRIMASK would be set right now.  If we skipped sleep, PRIMASK is not
    714                    //set so we explicitely set it to guarantee the powerup sequence
    715                    //works cleanly and consistently with respect to interrupt
    716                    //dispatching and enabling.
    717                    _setPriMask();
   \   0000028A   0x.... 0x....      BL       _setPriMask
    718                  }
    719                  //[[
    720                  SLEEP_TRACE_1SEC_DELAY(1);
    721                  //]]
    722          
    723                  //[[
    724                  SLEEP_TRACE_ADD_MARKER('a');
    725                  //]]
    726          
    727                  #ifdef PERIPHERAL_DISABLE
    728                    //Re-disabling peripherals immediately after sleep helps save
    729                    //a little more power.
    730                    PERIPHERAL_DISABLE = PERIPHERAL_DISABLE_SAVED;
   \                     ??halInternalSleep_23: (+1)
   \   0000028E   0x9804             LDR      R0,[SP, #+16]
   \   00000290   0xF8CA 0x0034      STR      R0,[R10, #+52]
    731                  #endif
    732          
    733                  //Clear the interrupt flags for all wake sources.  This
    734                  //is necessary because if we don't execute an actual deep sleep cycle
    735                  //the interrupt flags will never be cleared.  By clearing the flags,
    736                  //we always mimick a real deep sleep as closely as possible and
    737                  //guard against any accidental interrupt triggering coming out
    738                  //of deep sleep.  (The interrupt dispatch code coming out of sleep
    739                  //is responsible for translating wake events into interrupt events,
    740                  //and if we don't clear interrupt flags here it's possible for an
    741                  //interrupt to trigger even if it wasn't the true wake event.)
    742                  INT_SLEEPTMRFLAG = (INT_SLEEPTMRCMPA |
    743                                      INT_SLEEPTMRCMPB |
    744                                      INT_SLEEPTMRWRAP);
   \   00000294   0x2007             MOVS     R0,#+7
   \   00000296   0x6038             STR      R0,[R7, #+0]
    745                  INT_GPIOFLAG = (INT_IRQAFLAG |
    746                                  INT_IRQBFLAG |
    747                                  INT_IRQCFLAG |
    748                                  INT_IRQDFLAG);
   \   00000298   0x200F             MOVS     R0,#+15
   \   0000029A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    749          
    750                  //immediately restore the registers we saved before sleeping
    751                  //so IRQ and SleepTMR capture can be reenabled as quickly as possible
    752                  //this is safe because our global interrupts are still disabled
    753                  //other registers will be restored later
    754                  //[[-(superphy)
    755                  #if ( ! (defined(MINIMAL_HAL) || defined(BOOTLOADER_OPEN)) )
    756                  //The minimal HAL (and therefore the SuperPHY release) doesn't
    757                  //use the MPU, and neither does app-bootloader-open.
    758                  halInternalEnableMPU();
   \   0000029E   0x.... 0x....      BL       halInternalEnableMPU
    759                  #endif //MINIMAL_HAL
    760                  //]] (superphy)
    761                  SLEEPTMR_CLKEN_REG = SLEEPTMR_CLKEN_SAVED;
   \   000002A2   0x9810             LDR      R0,[SP, #+64]
   \   000002A4   0x....             LDR.N    R1,??DataTable5_9  ;; 0xe000e100
   \   000002A6   0x6060             STR      R0,[R4, #+4]
    762                  INT_SLEEPTMRCFG_REG = INT_SLEEPTMRCFG_SAVED;
   \   000002A8   0x980E             LDR      R0,[SP, #+56]
   \   000002AA   0x6438             STR      R0,[R7, #+64]
    763                  INT_MGMTCFG_REG = INT_MGMTCFG_SAVED;
   \   000002AC   0x980D             LDR      R0,[SP, #+52]
   \   000002AE   0x6478             STR      R0,[R7, #+68]
    764                  GPIO_INTCFGA_REG = GPIO_INTCFGA_SAVED;
   \   000002B0   0x980C             LDR      R0,[SP, #+48]
   \   000002B2   0xF8C8 0x004C      STR      R0,[R8, #+76]
    765                  GPIO_INTCFGB_REG = GPIO_INTCFGB_SAVED;
   \   000002B6   0x980B             LDR      R0,[SP, #+44]
   \   000002B8   0xF8C8 0x0050      STR      R0,[R8, #+80]
    766                  GPIO_INTCFGC_REG = GPIO_INTCFGC_SAVED;
   \   000002BC   0x980A             LDR      R0,[SP, #+40]
   \   000002BE   0xF8C8 0x0054      STR      R0,[R8, #+84]
    767                  GPIO_INTCFGD_REG = GPIO_INTCFGD_SAVED;
   \   000002C2   0x9809             LDR      R0,[SP, #+36]
   \   000002C4   0xF8C8 0x0058      STR      R0,[R8, #+88]
    768                  OSC24M_BIASTRIM_REG = OSC24M_BIASTRIM_SAVED;
   \   000002C8   0x9808             LDR      R0,[SP, #+32]
   \   000002CA   0xF8CA 0x0000      STR      R0,[R10, #+0]
    769                  OSCHF_TUNE_REG = OSCHF_TUNE_SAVED;
   \   000002CE   0x9807             LDR      R0,[SP, #+28]
   \   000002D0   0xF8CA 0x0004      STR      R0,[R10, #+4]
    770                  DITHER_DIS_REG = DITHER_DIS_SAVED;
   \   000002D4   0x9806             LDR      R0,[SP, #+24]
   \   000002D6   0xF8CA 0x0014      STR      R0,[R10, #+20]
    771                  PCTRACE_SEL_REG = PCTRACE_SEL_SAVED;
   \   000002DA   0x9805             LDR      R0,[SP, #+20]
   \   000002DC   0xF8CA 0x0024      STR      R0,[R10, #+36]
    772                  #if !defined(CORTEXM3_EM35X_GEN4)
    773                    MEM_PROT_0_REG = MEM_PROT_0_SAVED;
    774                    MEM_PROT_1_REG = MEM_PROT_1_SAVED;
    775                    MEM_PROT_2_REG = MEM_PROT_2_SAVED;
    776                    MEM_PROT_3_REG = MEM_PROT_3_SAVED;
    777                    MEM_PROT_4_REG = MEM_PROT_4_SAVED;
    778                    MEM_PROT_5_REG = MEM_PROT_5_SAVED;
    779                    MEM_PROT_6_REG = MEM_PROT_6_SAVED;
    780                    MEM_PROT_7_REG = MEM_PROT_7_SAVED;
    781                    MEM_PROT_EN_REG = MEM_PROT_EN_SAVED;
    782                  #endif //!defined(CORTEXM3_EM35X_GEN4)
    783                  INT_CFGSET_REG = INT_CFGSET_SAVED;
   \   000002E0   0x9802             LDR      R0,[SP, #+8]
   \   000002E2   0x6008             STR      R0,[R1, #+0]
    784                  SCS_VTOR_REG = SCS_VTOR_SAVED;
   \   000002E4   0x....             LDR.N    R1,??DataTable5_8  ;; 0xe000ed08
   \   000002E6   0x9803             LDR      R0,[SP, #+12]
   \   000002E8   0x6008             STR      R0,[R1, #+0]
    785          
    786                  //WAKE_CORE/INT_DEBUG and INT_IRQx is cleared by INT_PENDCLR below
    787                  INT_PENDCLR = 0xFFFFFFFF;
   \   000002EA   0xF04F 0x30FF      MOV      R0,#-1
   \   000002EE   0x....             LDR.N    R1,??DataTable5_14  ;; 0xe000e280
   \   000002F0   0x6008             STR      R0,[R1, #+0]
    788          
    789                  //Now that we're awake, normal interrupts are operational again
    790                  //Take a snapshot of the new GPIO state and the EVENT register to
    791                  //record our wake event
    792                  halInternalWakeEvent.events.portA = GPIO_PAIN;
   \   000002F2   0x....             LDR.N    R0,??DataTable5_10  ;; 0x4000b008
   \   000002F4   0x6800             LDR      R0,[R0, #+0]
   \   000002F6   0x7030             STRB     R0,[R6, #+0]
    793                  halInternalWakeEvent.events.portB = GPIO_PBIN;
   \   000002F8   0x....             LDR.N    R0,??DataTable5_11  ;; 0x4000b208
   \   000002FA   0x6800             LDR      R0,[R0, #+0]
   \   000002FC   0x7070             STRB     R0,[R6, #+1]
    794                  halInternalWakeEvent.events.portC = GPIO_PCIN;
   \   000002FE   0x....             LDR.N    R0,??DataTable5_12  ;; 0x4000b408
   \   00000300   0x6800             LDR      R0,[R0, #+0]
   \   00000302   0x70B0             STRB     R0,[R6, #+2]
    795                #ifdef EMBER_MICRO_PORT_D_GPIO
    796                  halInternalWakeEvent.events.portD = GPIO_PDIN;
    797                #endif
    798                #ifdef EMBER_MICRO_PORT_E_GPIO
    799                  halInternalWakeEvent.events.portE = GPIO_PEIN;
    800                #endif
    801                #ifdef EMBER_MICRO_PORT_F_GPIO
    802                  halInternalWakeEvent.events.portF = GPIO_PFIN;
    803                #endif
    804                  //Only operate on power up events that are also wake events.  Power
    805                  //up events will always trigger like an interrupt flag, so we have
    806                  //to check them against events that are enabled for waking. (This is
    807                  //a two step process because we're accessing two volatile values.)
    808                  uint64_t powerUpEvents = PWRUP_EVENT;
   \   00000304   0x6A62             LDR      R2,[R4, #+36]
    809                         powerUpEvents &= WAKE_SEL;
   \   00000306   0x69E0             LDR      R0,[R4, #+28]
   \   00000308   0x4010             ANDS     R0,R2,R0
    810          
    811                  halInternalWakeEvent.eventflags ^= GPIO_IN_SAVED.eventflags;
    812                  halInternalWakeEvent.eventflags &= gpioWakeSel ;
    813                  //PWRUP_SC1 is PB2 which is bit 10
    814                  halInternalWakeEvent.eventflags |= ((powerUpEvents&PWRUP_SC1)?1:0)<<((1*8)+2);
    815                  //PWRUP_SC2 is PA2 which is bit 2
    816                  halInternalWakeEvent.eventflags |= ((powerUpEvents&PWRUP_SC2)?1:0)<<((0*8)+2);
    817                  //PWRUP_IRQD is chosen by GPIO_IRQDSEL
    818                  halInternalWakeEvent.eventflags |= ((powerUpEvents&PWRUP_IRQD)?1:0)<<(GPIO_IRQDSEL);
   \   0000030A   0x69EA             LDR      R2,[R5, #+28]
    819                  halInternalWakeEvent.eventflags |= (( powerUpEvents &
    820                                                        ( PWRUP_CSYSPWRUPREQ_MASK  |
    821                                                          PWRUP_CDBGPWRUPREQ_MASK  |
    822                                                          PWRUP_WAKECORE_MASK      |
    823                                                          PWRUP_SLEEPTMRWRAP_MASK  |
    824                                                          PWRUP_SLEEPTMRCOMPB_MASK |
    825                                                          PWRUP_SLEEPTMRCOMPA_MASK ) )
    826                                                      << INTERNAL_WAKE_EVENT_BIT_SHIFT);
   \   0000030C   0x6833             LDR      R3,[R6, #+0]
   \   0000030E   0x9901             LDR      R1,[SP, #+4]
   \   00000310   0x404B             EORS     R3,R1,R3
   \   00000312   0x9900             LDR      R1,[SP, #+0]
   \   00000314   0x400B             ANDS     R3,R1,R3
   \   00000316   0x0601             LSLS     R1,R0,#+24
   \   00000318   0x0E49             LSRS     R1,R1,#+25
   \   0000031A   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000031E   0xEA43 0x2381      ORR      R3,R3,R1, LSL #+10
   \   00000322   0x0601             LSLS     R1,R0,#+24
   \   00000324   0x0E89             LSRS     R1,R1,#+26
   \   00000326   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000032A   0xEA43 0x0381      ORR      R3,R3,R1, LSL #+2
   \   0000032E   0x0601             LSLS     R1,R0,#+24
   \   00000330   0x0EC9             LSRS     R1,R1,#+27
   \   00000332   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000336   0xFA01 0xF202      LSL      R2,R1,R2
   \   0000033A   0x431A             ORRS     R2,R2,R3
   \   0000033C   0xF400 0x707C      AND      R0,R0,#0x3F0
   \   00000340   0xEA42 0x5000      ORR      R0,R2,R0, LSL #+20
   \   00000344   0x6030             STR      R0,[R6, #+0]
    827                  //at this point wake events are fully captured and interrupts have
    828                  //taken over handling all new events
    829          
    830                  //[[
    831                  SLEEP_TRACE_1SEC_DELAY(2);
    832                  SLEEP_TRACE_ADD_MARKER('b');
    833                  //]]
    834          
    835                  //Bring limited interrupts back online.  INTERRUPTS_OFF will use
    836                  //BASEPRI to disable all interrupts except fault handlers.
    837                  //PRIMASK is still set though (global interrupt disable) so we need
    838                  //to clear that next.
    839                  INTERRUPTS_OFF();
   \   00000346   0x.... 0x....      BL       _disableBasePri
    840          
    841                  //[[
    842                  SLEEP_TRACE_ADD_MARKER('c');
    843                  //]]
    844          
    845                  //Now that BASEPRI has taken control of interrupt enable/disable,
    846                  //we can clear PRIMASK to reenable global interrupt operation.
    847                  _clearPriMask();
   \   0000034A   0x.... 0x....      BL       _clearPriMask
    848          
    849                  //[[
    850                  SLEEP_TRACE_ADD_MARKER('d');
    851                  //]]
    852          
    853                  //wake events are saved and interrupts are back on track,
    854                  //disable gpio freeze
    855                  EVENT_CTRL = EVENT_CTRL_RESET;
   \   0000034E   0x2000             MOVS     R0,#+0
   \   00000350   0x6020             STR      R0,[R4, #+0]
    856          
    857                  //restart watchdog if it was running when we entered sleep
    858                  //do this before dispatching interrupts while we still have tight
    859                  //control of code execution
    860                  if(restoreWatchdog) {
   \   00000352   0xF89D 0x003C      LDRB     R0,[SP, #+60]
   \   00000356   0xB108             CBZ.N    R0,??halInternalSleep_24
    861                    halInternalEnableWatchDog();
   \   00000358   0x.... 0x....      BL       halInternalEnableWatchDog
    862                  }
    863          
    864                  //[[
    865                  SLEEP_TRACE_ADD_MARKER('e');
    866                  //]]
    867          
    868                  //Pend any interrupts associated with deep sleep wake sources.  The
    869                  //restoration of INT_CFGSET above and the changing of BASEPRI below
    870                  //is responsible for proper dispatching of interrupts at the end of
    871                  //halSleep.
    872                  //
    873                  //
    874                  //The WAKE_CORE wake source triggers a Debug Interrupt.  If INT_DEBUG
    875                  //interrupt is enabled and WAKE_CORE is a wake event, then pend the
    876                  //Debug interrupt (using the wake_core bit).
    877                  if( (INT_CFGSET&INT_DEBUG) &&
    878                      (halInternalWakeEvent.events.internal.bits.WAKE_CORE_B) ) {
   \                     ??halInternalSleep_24: (+1)
   \   0000035C   0x78F0             LDRB     R0,[R6, #+3]
   \   0000035E   0x....             LDR.N    R1,??DataTable5_9  ;; 0xe000e100
   \   00000360   0x6809             LDR      R1,[R1, #+0]
   \   00000362   0x03C9             LSLS     R1,R1,#+15
   \   00000364   0xD504             BPL.N    ??halInternalSleep_25
   \   00000366   0xF3C0 0x01C0      UBFX     R1,R0,#+3,#+1
   \   0000036A   0xB109             CBZ.N    R1,??halInternalSleep_25
    879                    WAKE_CORE = WAKE_CORE_FIELD;
   \   0000036C   0x2120             MOVS     R1,#+32
   \   0000036E   0x6221             STR      R1,[R4, #+32]
    880                    //[[
    881                    SLEEP_TRACE_ADD_MARKER('g');
    882                    //]]
    883                  }
    884                  //
    885                  //
    886                  //The SleepTMR CMPA is linked to a real ISR.  If the SleepTMR CMPA
    887                  //interrupt is enabled and CMPA is a wake event, then pend the CMPA
    888                  //interrupt (force the second level interrupt).
    889                  if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) &&
    890                      (halInternalWakeEvent.events.internal.bits.TIMER_WAKE_COMPA) ) {
   \                     ??halInternalSleep_25: (+1)
   \   00000370   0x6C39             LDR      R1,[R7, #+64]
   \   00000372   0x0789             LSLS     R1,R1,#+30
   \   00000374   0xD503             BPL.N    ??halInternalSleep_26
   \   00000376   0x07C1             LSLS     R1,R0,#+31
   \   00000378   0xBF44             ITT      MI 
   \   0000037A   0x2102             MOVMI    R1,#+2
   \   0000037C   0x60F9             STRMI    R1,[R7, #+12]
    891                    INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPA;
    892                    //[[
    893                    SLEEP_TRACE_ADD_MARKER('h');
    894                    //]]
    895                  }
    896                  //
    897                  //The SleepTMR CMPB is linked to a real ISR.  If the SleepTMR CMPB
    898                  //interrupt is enabled and CMPB is a wake event, then pend the CMPB
    899                  //interrupt (force the second level interrupt).
    900                  if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPB) &&
    901                      (halInternalWakeEvent.events.internal.bits.TIMER_WAKE_COMPB) ) {
   \                     ??halInternalSleep_26: (+1)
   \   0000037E   0x6C39             LDR      R1,[R7, #+64]
   \   00000380   0x0749             LSLS     R1,R1,#+29
   \   00000382   0xD504             BPL.N    ??halInternalSleep_27
   \   00000384   0xF3C0 0x0140      UBFX     R1,R0,#+1,#+1
   \   00000388   0xB109             CBZ.N    R1,??halInternalSleep_27
    902                    INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPB;
   \   0000038A   0x2104             MOVS     R1,#+4
   \   0000038C   0x60F9             STR      R1,[R7, #+12]
    903                    //[[
    904                    SLEEP_TRACE_ADD_MARKER('i');
    905                    //]]
    906                  }
    907                  //
    908                  //The SleepTMR WRAP is linked to a real ISR.  If the SleepTMR WRAP
    909                  //interrupt is enabled and WRAP is a wake event, then pend the WRAP
    910                  //interrupt (force the second level interrupt).
    911                  if( (INT_SLEEPTMRCFG&INT_SLEEPTMRWRAP) &&
    912                      (halInternalWakeEvent.events.internal.bits.TIMER_WAKE_WRAP) ) {
   \                     ??halInternalSleep_27: (+1)
   \   0000038E   0x6C39             LDR      R1,[R7, #+64]
   \   00000390   0x07C9             LSLS     R1,R1,#+31
   \   00000392   0xD504             BPL.N    ??halInternalSleep_28
   \   00000394   0xF3C0 0x0180      UBFX     R1,R0,#+2,#+1
   \   00000398   0xB109             CBZ.N    R1,??halInternalSleep_28
    913                    INT_SLEEPTMRFORCE = INT_SLEEPTMRWRAP;
   \   0000039A   0x2101             MOVS     R1,#+1
   \   0000039C   0x60F9             STR      R1,[R7, #+12]
    914                    //[[
    915                    SLEEP_TRACE_ADD_MARKER('j');
    916                    //]]
    917                  }
    918                  //
    919                  //
    920                  //The four IRQs are linked to a real ISR.  If any of the four IRQs
    921                  //triggered, then pend their ISR
    922                  //
    923                  //If the IRQA interrupt mode is enabled and IRQA (PB0) is wake
    924                  //event, then pend the interrupt.
    925                  if( ((GPIO_INTCFGA&GPIO_INTMOD)!=0) &&
    926                      (halInternalWakeEvent.eventflags&BIT(PORTB_PIN(0))) ) {
   \                     ??halInternalSleep_28: (+1)
   \   0000039E   0x6831             LDR      R1,[R6, #+0]
   \   000003A0   0xF8D8 0x204C      LDR      R2,[R8, #+76]
   \   000003A4   0xF012 0x0FE0      TST      R2,#0xE0
   \   000003A8   0xD005             BEQ.N    ??halInternalSleep_29
   \   000003AA   0x05CA             LSLS     R2,R1,#+23
   \   000003AC   0xD503             BPL.N    ??halInternalSleep_29
    927                    INT_PENDSET = INT_IRQA;
   \   000003AE   0x....             LDR.N    R3,??DataTable5_13  ;; 0xe000e200
   \   000003B0   0xF44F 0x5280      MOV      R2,#+4096
   \   000003B4   0x601A             STR      R2,[R3, #+0]
    928                    //[[
    929                    SLEEP_TRACE_ADD_MARKER('k');
    930                    //]]
    931                  }
    932                  //If the IRQB interrupt mode is enabled and IRQB (PB6) is wake
    933                  //event, then pend the interrupt.
    934                  if( ((GPIO_INTCFGB&GPIO_INTMOD)!=0) &&
    935                      (halInternalWakeEvent.eventflags&BIT(PORTB_PIN(6))) ) {
   \                     ??halInternalSleep_29: (+1)
   \   000003B6   0xF8D8 0x2050      LDR      R2,[R8, #+80]
   \   000003BA   0xF012 0x0FE0      TST      R2,#0xE0
   \   000003BE   0xD005             BEQ.N    ??halInternalSleep_30
   \   000003C0   0x044A             LSLS     R2,R1,#+17
   \   000003C2   0xD503             BPL.N    ??halInternalSleep_30
    936                    INT_PENDSET = INT_IRQB;
   \   000003C4   0x....             LDR.N    R3,??DataTable5_13  ;; 0xe000e200
   \   000003C6   0xF44F 0x5200      MOV      R2,#+8192
   \   000003CA   0x601A             STR      R2,[R3, #+0]
    937                    //[[
    938                    SLEEP_TRACE_ADD_MARKER('l');
    939                    //]]
    940                  }
    941                  //If the IRQC interrupt mode is enabled and IRQC (GPIO_IRQCSEL) is wake
    942                  //event, then pend the interrupt.
    943                  if( ((GPIO_INTCFGC&GPIO_INTMOD)!=0) &&
    944                      (halInternalWakeEvent.eventflags&BIT(GPIO_IRQCSEL)) ) {
   \                     ??halInternalSleep_30: (+1)
   \   000003CC   0xF8D8 0x2054      LDR      R2,[R8, #+84]
   \   000003D0   0xF012 0x0FE0      TST      R2,#0xE0
   \   000003D4   0xD008             BEQ.N    ??halInternalSleep_31
   \   000003D6   0x69AA             LDR      R2,[R5, #+24]
   \   000003D8   0xFA21 0xF202      LSR      R2,R1,R2
   \   000003DC   0x07D2             LSLS     R2,R2,#+31
   \   000003DE   0xD503             BPL.N    ??halInternalSleep_31
    945                    INT_PENDSET = INT_IRQC;
   \   000003E0   0x....             LDR.N    R3,??DataTable5_13  ;; 0xe000e200
   \   000003E2   0xF44F 0x4280      MOV      R2,#+16384
   \   000003E6   0x601A             STR      R2,[R3, #+0]
    946                    //[[
    947                    SLEEP_TRACE_ADD_MARKER('m');
    948                    //]]
    949                  }
    950                  //If the IRQD interrupt mode is enabled and IRQD (GPIO_IRQDSEL) is wake
    951                  //event, then pend the interrupt.
    952                  if( ((GPIO_INTCFGD&GPIO_INTMOD)!=0) &&
    953                      (halInternalWakeEvent.eventflags&BIT(GPIO_IRQDSEL)) ) {
   \                     ??halInternalSleep_31: (+1)
   \   000003E8   0xF8D8 0x2058      LDR      R2,[R8, #+88]
   \   000003EC   0xF012 0x0FE0      TST      R2,#0xE0
   \   000003F0   0xD007             BEQ.N    ??halInternalSleep_32
   \   000003F2   0x69EA             LDR      R2,[R5, #+28]
   \   000003F4   0x40D1             LSRS     R1,R1,R2
   \   000003F6   0x07C9             LSLS     R1,R1,#+31
   \   000003F8   0xD503             BPL.N    ??halInternalSleep_32
    954                    INT_PENDSET = INT_IRQD;
   \   000003FA   0x....             LDR.N    R2,??DataTable5_13  ;; 0xe000e200
   \   000003FC   0xF44F 0x4100      MOV      R1,#+32768
   \   00000400   0x6011             STR      R1,[R2, #+0]
    955                    //[[
    956                    SLEEP_TRACE_ADD_MARKER('n');
    957                    //]]
    958                  }
    959          
    960                 #ifndef CORTEXM3_EM35X_GEN4 // HW bug fixed in GEN4
    961                  //Due to FogBugz 11909/11920, SLEEPTMR_CNT may not have updated yet so
    962                  //we must ensure that the CNT register updates before returning.  It's
    963                  //only necessary to wait for the CNT to update when we've gone to
    964                  //sleep, the SLEEPTMR is enabled, and the sleep mode used a timer.
    965                  //This code could delay for up to 1ms, but will return as soon as it
    966                  //can.  In the situation where the chip slept for a known amount of
    967                  //time, this code will not delay and instead the system timer will
    968                  //report a fake, but accurate time.
    969                  if((!skipSleep) &&
    970                     (SLEEPTMR_CFG&SLEEPTMR_ENABLE) &&
    971                     (SLEEPTMR_CLKEN&SLEEPTMR_CLK10KEN) &&
    972                     (sleepMode!=SLEEPMODE_NOTIMER)) {
    973                    uint32_t currSleepTmrCnt;
    974          
    975                    #ifdef BUG11909_WORKAROUND_C
    976                    //THIS WORKAROUND IS NOT PROVEN 100% RELIABLE.  THIS SHOULD NOT BE
    977                    //USED UNTIL IT IS PROVEN PERFECTLY RELIABLE.
    978                    //This workaround attempts to force the SLEEPTMR_CNT to tick sooner
    979                    //than normal.  It does so by toggling between the clock sources
    980                    //to get the CNT to increment.  There is a chance the SLEEPTMR_CNT
    981                    //could become random doing this!
    982                    {
    983                      currSleepTmrCnt = SLEEPTMR_CNTH<<16;
    984                      currSleepTmrCnt |= SLEEPTMR_CNTL;
    985                      if(currSleepTmrCnt == wakeupSleepTmrCnt) {
    986                        uint32_t GPIO_PCOUT_SAVED = GPIO_PCOUT;
    987                        uint32_t GPIO_PCCFGH_SAVED = GPIO_PCCFGH;
    988                        uint32_t SLEEPTMR_CFG_SAVED = SLEEPTMR_CFG;
    989                        //It is not necessary to do anything with SLEEPTMR_CLKEN.
    990                        GPIO_PCSET = PC7;
    991                        SET_REG_FIELD(GPIO_PCCFGH, PC7_CFG, GPIOCFG_OUT);
    992                        do {
    993                          //Toggling between RC/XTAL will produce a clock edge
    994                          //into the timer and cause CNT to increment.
    995                          SLEEPTMR_CFG ^= SLEEPTMR_CLKSEL;
    996                          currSleepTmrCnt = SLEEPTMR_CNTH<<16;
    997                          currSleepTmrCnt |= SLEEPTMR_CNTL;
    998                        } while(currSleepTmrCnt == wakeupSleepTmrCnt);
    999                        GPIO_PCOUT = GPIO_PCOUT_SAVED;
   1000                        GPIO_PCCFGH = GPIO_PCCFGH_SAVED;
   1001                        SLEEPTMR_CFG = SLEEPTMR_CFG_SAVED;
   1002                        forceSleepTmrCnt = false;
   1003                      }
   1004                    }
   1005                    #endif //BUG11909_WORKAROUND_C
   1006          
   1007                    //Knowing that halSleepTimerIsr is about to be taken (when
   1008                    //interrupts get enabled) tells us that the chip woke up due
   1009                    //to the timer and therefore sleepTmrArtificalCnt is valid
   1010                    //and needs to be forced.  This allows us to bypass delaying
   1011                    //for SLEEPTMR_CNT to tick forward.  For FogBugz 11909/11920
   1012                    //workaround.
   1013                    if((INT_CFGSET&INT_SLEEPTMR) && (INT_PENDSET&INT_SLEEPTMR)) {
   1014                      //sleepTmrArtificalCnt was set before sleeping
   1015                      //by halSleepForQuarterSeconds
   1016                      forceSleepTmrCnt = true;
   1017                    } else {
   1018                      uint32_t ticks = MAC_TIMER_TICKS(1000); // 1 millisecond
   1019                      uint32_t beginTime;
   1020                      forceSleepTmrCnt = false;
   1021                      //It is possible to be in a situation where the SLEEPTMR is no
   1022                      //longer ticking (32k XTAL issues).  To guard against getting
   1023                      //stuck in this loop, use the MAC Timer to timeout after 1ms (since
   1024                      //that is the maximum time this loop would normally delay for).
   1025                      MAC_TIMER_CTRL |= MAC_TIMER_CTRL_MAC_TIMER_EN;
   1026                      beginTime = MAC_TIMER;
   1027                      do{
   1028                        currSleepTmrCnt = SLEEPTMR_CNTH<<16;
   1029                        currSleepTmrCnt |= SLEEPTMR_CNTL;
   1030                      }while((currSleepTmrCnt == wakeupSleepTmrCnt) &&
   1031                             (((MAC_TIMER-beginTime)&MAC_TIMER_MAC_TIMER_MASK) < ticks));
   1032                    }
   1033                  }
   1034                 #endif//CORTEXM3_EM35X_GEN4 // HW bug fixed in GEN4
   1035                }
   1036          
   1037                //[[
   1038                SLEEP_TRACE_1SEC_DELAY(3);
   1039                SLEEP_TRACE_ADD_MARKER('o');
   1040                //]]
   1041          
   1042                //Mark the wake events valid just before exiting
   1043                halInternalWakeEvent.events.internal.bits.WakeInfoValid = true;
   \                     ??halInternalSleep_32: (+1)
   \   00000402   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000406   0x70F0             STRB     R0,[R6, #+3]
   1044          
   1045                //We are now reconfigured, appropriate ISRs are pended, and ready to go,
   1046                //so enable interrupts!
   1047                INTERRUPTS_ON();
   \   00000408   0xB011             ADD      SP,SP,#+68
   \   0000040A   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000040E   0x.... 0x....      B.W      _enableBasePri
   \                     ??halInternalSleep_21: (+1)
   \   00000412   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000416   0xF47F 0xAF34      BNE.W    ??halInternalSleep_22
   \   0000041A   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   0000041E   0x....             LDR.N    R1,??DataTable5_8  ;; 0xe000ed08
   \   00000420   0x.... 0x....      LDR.W    R11,??DataTable5_15
   \   00000424   0x0840             LSRS     R0,R0,#+1
   \   00000426   0x0040             LSLS     R0,R0,#+1
   \   00000428   0xF8CA 0x0018      STR      R0,[R10, #+24]
   \   0000042C   0x....             LDR.N    R0,??DataTable5_8  ;; 0xe000ed08
   \   0000042E   0x6880             LDR      R0,[R0, #+8]
   \   00000430   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000434   0x6088             STR      R0,[R1, #+8]
   \   00000436   0xF240 0x2107      MOVW     R1,#+519
   \   0000043A   0xF8BB 0x0000      LDRH     R0,[R11, #+0]
   \   0000043E   0x4288             CMP      R0,R1
   \   00000440   0xBF02             ITTT     EQ 
   \   00000442   0xF8BB 0x0002      LDRHEQ   R0,[R11, #+2]
   \   00000446   0xF24F 0x010F      MOVWEQ   R1,#+61455
   \   0000044A   0x4288             CMPEQ    R0,R1
   \   0000044C   0xD105             BNE.N    ??halInternalSleep_33
   \   0000044E   0xF24C 0x303C      MOVW     R0,#+49980
   \   00000452   0xF8AB 0x0002      STRH     R0,[R11, #+2]
   \   00000456   0xF04F 0x0901      MOV      R9,#+1
   \                     ??halInternalSleep_33: (+1)
   \   0000045A   0x2001             MOVS     R0,#+1
   \   0000045C   0x.... 0x....      BL       halInternalContextSaveRestore
   \   00000460   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000464   0xD003             BEQ.N    ??halInternalSleep_34
   \   00000466   0xF24F 0x000F      MOVW     R0,#+61455
   \   0000046A   0xF8AB 0x0002      STRH     R0,[R11, #+2]
   \                     ??halInternalSleep_34: (+1)
   \   0000046E   0xE70E             B.N      ??halInternalSleep_23
   1048          
   1049                //[[
   1050                SLEEP_TRACE_ADD_MARKER('p');
   1051                //]]
   1052          
   1053                break; //and deep sleeping is done!
   1054          
   1055              case SLEEPMODE_IDLE:
   1056                //Only the CPU is idled.  The rest of the chip continues runing
   1057                //normally.  The chip will wake from any interrupt.
   1058                {
   1059                  bool restoreWatchdog = halInternalWatchDogEnabled();
   \                     ??halInternalSleep_4: (+1)
   \   00000470   0x.... 0x....      BL       halInternalWatchDogEnabled
   \   00000474   0x4604             MOV      R4,R0
   1060                  //disable watchdog while sleeping (since we can't reset it asleep)
   1061                  halInternalDisableWatchDog(MICRO_DISABLE_WATCH_DOG_KEY);
   \   00000476   0x20A5             MOVS     R0,#+165
   \   00000478   0x.... 0x....      BL       halInternalDisableWatchDog
   1062                  //Normal ATOMIC/INTERRUPTS_OFF/INTERRUPTS_ON uses the BASEPRI mask
   1063                  //to juggle priority levels so that the fault handlers can always
   1064                  //be serviced.  But, the WFI instruction is only capable of
   1065                  //working with the PRIMASK bit.  Therefore, we have to switch from
   1066                  //using BASEPRI to PRIMASK to keep interrupts disabled so that the
   1067                  //WFI can return on an interrupt
   1068                  //Globally disable interrupts with PRIMASK
   1069                  _setPriMask();
   \   0000047C   0x.... 0x....      BL       _setPriMask
   1070                  //Bring the BASEPRI up to 0 to allow interrupts (but still disabled
   1071                  //with PRIMASK)
   1072                  INTERRUPTS_ON();
   \   00000480   0x.... 0x....      BL       _enableBasePri
   1073                  //an internal function call is made here instead of injecting the
   1074                  //"WFI" assembly instruction because injecting assembly code will
   1075                  //cause the compiler's optimizer to reduce efficiency.
   1076                  #ifdef FLASH_ACCESS_FLASH_LP
   1077                  BYPASS_MPU(
   1078                    uint32_t FLASH_ACCESS_SAVED = FLASH_ACCESS;
   1079                    FLASH_ACCESS &= ~FLASH_ACCESS_FLASH_LP;
   1080                    halInternalIdleSleep();
   1081                    FLASH_ACCESS = FLASH_ACCESS_SAVED;
   1082                  )
   \   00000484   0x....             LDR.N    R5,??DataTable5_16  ;; 0xe000ed94
   \   00000486   0x682E             LDR      R6,[R5, #+0]
   \   00000488   0x6828             LDR      R0,[R5, #+0]
   \   0000048A   0x0840             LSRS     R0,R0,#+1
   \   0000048C   0x0040             LSLS     R0,R0,#+1
   \   0000048E   0x6028             STR      R0,[R5, #+0]
   \   00000490   0x.... 0x....      BL       _executeBarrierInstructions
   \   00000494   0x....             LDR.N    R7,??DataTable5_17  ;; 0x40008000
   \   00000496   0xF8D7 0x8000      LDR      R8,[R7, #+0]
   \   0000049A   0x6838             LDR      R0,[R7, #+0]
   \   0000049C   0xF020 0x0040      BIC      R0,R0,#0x40
   \   000004A0   0x6038             STR      R0,[R7, #+0]
   \   000004A2   0x.... 0x....      BL       halInternalIdleSleep
   \   000004A6   0xF8C7 0x8000      STR      R8,[R7, #+0]
   \   000004AA   0x602E             STR      R6,[R5, #+0]
   \   000004AC   0x.... 0x....      BL       _executeBarrierInstructions
   1083                  #else //FLASH_ACCESS_FLASH_LP
   1084                  halInternalIdleSleep();
   1085                  #endif //FLASH_ACCESS_FLASH_LP
   1086                  //restart watchdog if it was running when we entered sleep
   1087                  if(restoreWatchdog)
   \   000004B0   0xB10C             CBZ.N    R4,??halInternalSleep_35
   1088                    halInternalEnableWatchDog();
   \   000004B2   0x.... 0x....      BL       halInternalEnableWatchDog
   1089                  //The WFI instruction does not actually clear the PRIMASK bit, it
   1090                  //only allows the PRIMASK bit to be bypassed.  Therefore, we must
   1091                  //manually clear PRIMASK to reenable all interrupts.
   1092                  _clearPriMask();
   \                     ??halInternalSleep_35: (+1)
   \   000004B6   0xB011             ADD      SP,SP,#+68
   \   000004B8   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000004BC   0x.... 0x....      B.W      _clearPriMask
   1093                }
   1094                break;
   1095          
   1096              default:
   1097                //Oops!  Invalid sleepMode parameter.
   1098                assert(0);
   \                     ??halInternalSleep_5: (+1)
   \   000004C0   0xB011             ADD      SP,SP,#+68
   \   000004C2   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000004C6   0xF240 0x414A      MOVW     R1,#+1098
   \   000004CA   0x.... 0x....      ADR.W    R0,?_0
   \   000004CE   0x.... 0x....      B.W      halInternalAssertFailed
   1099            }
   1100          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable5_13  ;; 0xe000e200
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0x4770             BX       LR
   1101          
   1102          

   \                                 In section .text, align 2, keep-with-next
   1103          void halSleepWithOptions(SleepModes sleepMode, WakeMask wakeMask)
   1104          {
   1105            //configure all GPIO wake sources when given a valid wakeMask
   1106            if(wakeMask != WAKE_MASK_INVALID) {
   \                     halSleepWithOptions: (+1)
   \   00000000   0xF111 0x0F01      CMN      R1,#+1
   \   00000004   0x....             LDR.N    R2,??DataTable5_2  ;; 0x4000bc08
   \   00000006   0xD007             BEQ.N    ??halSleepWithOptions_0
   1107              GPIO_PAWAKE = (wakeMask>>0)&EMBER_MICRO_PORT_A_GPIO;
   \   00000008   0xB2CB             UXTB     R3,R1
   \   0000000A   0x6013             STR      R3,[R2, #+0]
   1108              GPIO_PBWAKE = (wakeMask>>8)&EMBER_MICRO_PORT_B_GPIO;
   \   0000000C   0xF3C1 0x2307      UBFX     R3,R1,#+8,#+8
   \   00000010   0x6053             STR      R3,[R2, #+4]
   1109              GPIO_PCWAKE = (wakeMask>>16)&EMBER_MICRO_PORT_C_GPIO;
   \   00000012   0xF3C1 0x4107      UBFX     R1,R1,#+16,#+8
   \   00000016   0x6091             STR      R1,[R2, #+8]
   1110          
   1111              #ifdef EMBER_MICRO_PORT_D_GPIO
   1112              GPIO_PDWAKE = (wakeMask>>24)&EMBER_MICRO_PORT_D_GPIO;
   1113              #endif
   1114              #ifdef EMBER_MICRO_PORT_E_GPIO
   1115              GPIO_PEWAKE = (wakeMask>>32)&EMBER_MICRO_PORT_E_GPIO;
   1116              #endif
   1117              #ifdef EMBER_MICRO_PORT_F_GPIO
   1118              GPIO_PFWAKE = (wakeMask>>40)&EMBER_MICRO_PORT_F_GPIO;
   1119              #endif
   1120            }
   1121          
   1122            //use the defines found in the board file to choose our wakeup source(s)
   1123            WAKE_SEL = 0;  //start with no wake sources
   \                     ??halSleepWithOptions_0: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable5_18  ;; 0x40000020
   \   0000001C   0x600B             STR      R3,[R1, #+0]
   1124          
   1125            //if any of the GPIO wakeup monitor bits are set, enable the top level
   1126            //GPIO wakeup monitor
   1127            if( (GPIO_PAWAKE) ||
   1128                (GPIO_PBWAKE) ||
   1129                (GPIO_PCWAKE) 
   1130                #ifdef EMBER_MICRO_PORT_D_GPIO
   1131                || (GPIO_PDWAKE)
   1132                #endif
   1133                #ifdef EMBER_MICRO_PORT_E_GPIO
   1134                || (GPIO_PEWAKE) 
   1135                #endif
   1136                #ifdef EMBER_MICRO_PORT_F_GPIO
   1137                || (GPIO_PFWAKE) 
   1138                #endif
   1139                ) {
   \   0000001E   0x6813             LDR      R3,[R2, #+0]
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xBF04             ITT      EQ 
   \   00000024   0x6853             LDREQ    R3,[R2, #+4]
   \   00000026   0x2B00             CMPEQ    R3,#+0
   \   00000028   0xD101             BNE.N    ??halSleepWithOptions_1
   \   0000002A   0x6892             LDR      R2,[R2, #+8]
   \   0000002C   0xB11A             CBZ.N    R2,??halSleepWithOptions_2
   1140              WAKE_SEL |= GPIO_WAKE;
   \                     ??halSleepWithOptions_1: (+1)
   \   0000002E   0x680A             LDR      R2,[R1, #+0]
   \   00000030   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000034   0x600A             STR      R2,[R1, #+0]
   1141            }
   1142          
   1143            //NOTE: The use of WAKE_CDBGPWRUPREQ should not be necessary since asserting
   1144            //CDBGPWRUPREQ will bring the chip to DS0 where the debug components are
   1145            //maintained but it's not necessary to completely wake to the running state.
   1146          
   1147            //always wakeup when the debugger attempts to access the chip
   1148            WAKE_SEL |= WAKE_CSYSPWRUPREQ;
   \                     ??halSleepWithOptions_2: (+1)
   \   00000036   0x680A             LDR      R2,[R1, #+0]
   \   00000038   0xF442 0x7200      ORR      R2,R2,#0x200
   \   0000003C   0x600A             STR      R2,[R1, #+0]
   1149          
   1150            //always wakeup when the debug channel attempts to access the chip
   1151            WAKE_SEL |= WAKE_WAKE_CORE;
   \   0000003E   0x680A             LDR      R2,[R1, #+0]
   \   00000040   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000044   0x600A             STR      R2,[R1, #+0]
   1152            //the timer wakeup sources are enabled below in POWERSAVE, if needed
   1153          
   1154            //wake sources are configured so do the actual sleeping
   1155            halInternalSleep(sleepMode);
   \   00000046   0x....             B.N      halInternalSleep
   1156          }
   1157          

   \                                 In section .text, align 2, keep-with-next
   1158          void halSleep(SleepModes sleepMode)
   1159          {
   1160            //configure all GPIO wake sources
   1161            WakeMask gpioWakeBitMask  = (EMBER_WAKE_PORT_A << 0) |
   1162                                        (EMBER_WAKE_PORT_B << 8) |
   1163                                        (EMBER_WAKE_PORT_C << 16)
   1164                                      #ifdef EMBER_WAKE_PORT_D
   1165                                        |(EMBER_WAKE_PORT_D << 24)
   1166                                      #endif
   1167                                      #ifdef EMBER_WAKE_PORT_E
   1168                                        |( (uint64_t) EMBER_WAKE_PORT_E << 32)
   1169                                      #endif
   1170                                      #ifdef EMBER_WAKE_PORT_F
   1171                                        |( (uint64_t) EMBER_WAKE_PORT_F << 40)
   1172                                      #endif
   1173                                        ;
   1174          
   1175            halSleepWithOptions(sleepMode, gpioWakeBitMask);
   \                     halSleep: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_19  ;; 0x404000
   \   00000002   0x....             B.N      halSleepWithOptions
   1176          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     halInternalWakeEvent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40000004         DC32     0x40000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x4000BC08         DC32     0x4000bc08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x4000A014         DC32     0x4000a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     SIZEOF(UNRETAINED_RAM)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40004004         DC32     0x40004004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x08080798         DC32     0x8080798

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x4000A814         DC32     0x4000a814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x4000B008         DC32     0x4000b008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x4000B208         DC32     0x4000b208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x4000B408         DC32     0x4000b408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     halResetInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0xE000ED94         DC32     0xe000ed94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x40000020         DC32     0x40000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x00404000         DC32     0x404000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x73 0x6C          DC8 "sleep.c"
   \              0x65 0x65    
   \              0x70 0x2E    
   \              0x63 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   halGetWakeInfo
       0   halInternalMimickLvReset
     104   halInternalSleep
         0   -> _clearPriMask
       104   -> _clearPriMask
       104   -> _disableBasePri
         0   -> _enableBasePri
       104   -> _enableBasePri
       104   -> _executeBarrierInstructions
       104   -> _setPriMask
         0   -> halInternalAssertFailed
       104   -> halInternalContextSaveRestore
       104   -> halInternalDisableWatchDog
       104   -> halInternalEnableMPU
       104   -> halInternalEnableWatchDog
       104   -> halInternalIdleSleep
       104   -> halInternalWatchDogEnabled
       0   halSleep
         0   -> halSleepWithOptions
       0   halSleepWithOptions
         0   -> halInternalSleep


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       6  ?Subroutine0
       8  ?_0
       8  halGetWakeInfo
       2  halInternalMimickLvReset
    1234  halInternalSleep
       4  halInternalWakeEvent
       4  halSleep
      72  halSleepWithOptions

 
     4 bytes in section .bss
 1 414 bytes in section .text
 
 1 414 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
