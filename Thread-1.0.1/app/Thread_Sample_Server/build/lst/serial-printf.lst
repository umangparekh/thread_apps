###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  13:29:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\serial-printf.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\serial-printf.c -D APP_BTL
#        -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D PHY_EM3XX -D
#        "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"serial-printf.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\serial-printf.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\serial-printf.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\app\util\serial\serial-printf.c
      1          /**
      2           * File: serial-printf.c
      3           * 
      4           * A simple printf() implementation
      5           * Supported format specifiers are:
      6           *  %% - percent sign
      7           *  %c - single byte character
      8           *  %s - ram string
      9           *  %p - flash string  (non-standard)
     10           *  %u - 2-byte unsigned decimal
     11           *  %d - 2-byte signed decimal
     12           *  %l or %ld 4-byte signed decimal
     13           *  %lu 4-byte unsigned decimal
     14           *  %x %2x %4x - 1, 2, 4 BYTE hex value (always 0 padded) (non-standard)
     15           *    Non-standard behavior: Normally a number after a % is interpreted to be
     16           *    a minimum character width, and the value is not zero padded unless
     17           *    there is a zero before the minimum width value.
     18           *    i.e. '%2x' for the uint16_t value 0xb prints " b", while '%02x' would print
     19           *    "0b".
     20           *    Ember assumes the number after the % and before the 'x' to be the number
     21           *    of BYTES, and all hex values are left-justified zero padded.
     22           * 
     23           * Copyright 2012 by Silicon Laboratories. All rights reserved.             *80*
     24           */
     25          
     26          #include PLATFORM_HEADER
     27          #include "stack/include/ember-types.h"
     28          #include "stack/include/error.h"
     29          #include "hal/hal.h"
     30          #include "serial.h"
     31          

   \                                 In section .text, align 4, keep-with-next
     32          static PGM uint32_t powers10[9] = {
   \                     powers10:
   \   00000000   0x3B9ACA00         DC32 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100
   \              0x05F5E100   
   \              0x00989680   
   \              0x000F4240   
   \              0x000186A0   
   \              0x00002710   
   \              0x000003E8   
   \              0x00000064   
   \   00000020   0x0000000A         DC32 10
     33            1000000000,
     34            100000000,
     35            10000000,
     36            1000000,
     37            100000,
     38            10000,
     39            1000,
     40            100,
     41            10
     42          };
     43          
     44          // A few macros and a function help make this readable:
     45          //   - flush the local buffer to the output
     46          //   - ensure that there is some room in the local buffer
     47          //   - add a single byte to the local buffer
     48          //   - convert a nibble to its ascii hex character
     49          //   - convert an uint16_t to a decimal string
     50          // Most of these only work within the emPrintfInternal() function.
     51          
     52          // Current champion is %4x which writes 8 bytes.  (%s and %p can write
     53          // more, but they do their own overflow checks).
     54          #define LOCAL_BUFFER_SIZE 16
     55          #define MAX_SINGLE_COMMAND_BYTES 8
     56          
     57          #define flushBuffer() \
     58          do { count = localBufferPointer - localBuffer;     \
     59               if (flushHandler(port, localBuffer, count) != EMBER_SUCCESS) \
     60                 goto fail;                                  \
     61               total += count;                               \
     62               localBufferPointer = localBuffer;             \
     63               (void)localBufferPointer;                     \
     64          } while (false)                                           
     65          
     66          #define addByte(byte) \
     67          do { *(localBufferPointer++) = (byte); } while (false)
     68          

   \                                 In section .text, align 2, keep-with-next
     69          uint8_t *emWriteHexInternal(uint8_t *charBuffer, uint16_t value, uint8_t charCount)
     70          {
   \                     emWriteHexInternal: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     71            uint8_t c = charCount;
   \   00000002   0x4613             MOV      R3,R2
     72            charBuffer += charCount;
   \   00000004   0x1810             ADDS     R0,R2,R0
   \   00000006   0xE002             B.N      ??emWriteHexInternal_0
     73            for (; c; c--) {
     74              uint8_t n = value & 0x0F;
     75              value = value >> 4;
     76              *(--charBuffer) = n + (n < 10
     77                                     ? '0'
     78                                     : 'A' - 10);
   \                     ??emWriteHexInternal_1: (+1)
   \   00000008   0x19A4             ADDS     R4,R4,R6
   \   0000000A   0x702C             STRB     R4,[R5, #+0]
   \   0000000C   0x1E5B             SUBS     R3,R3,#+1
   \                     ??emWriteHexInternal_0: (+1)
   \   0000000E   0xB2DB             UXTB     R3,R3
   \   00000010   0xB14B             CBZ.N    R3,??emWriteHexInternal_2
   \   00000012   0xF001 0x060F      AND      R6,R1,#0xF
   \   00000016   0x0909             LSRS     R1,R1,#+4
   \   00000018   0x1E45             SUBS     R5,R0,#+1
   \   0000001A   0x2E0A             CMP      R6,#+10
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0xBFB4             ITE      LT 
   \   00000020   0x2430             MOVLT    R4,#+48
   \   00000022   0x2437             MOVGE    R4,#+55
   \   00000024   0xE7F0             B.N      ??emWriteHexInternal_1
     79            }
     80            return charBuffer + charCount;
   \                     ??emWriteHexInternal_2: (+1)
   \   00000026   0x1810             ADDS     R0,R2,R0
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
     81          }
     82          
     83          // This function will write a decimal ASCII string to buffer 
     84          // containing the passed 'value'.  Includes negative sign, if applicable.
     85          // Returns the number of bytes written.
     86          

   \                                 In section .text, align 2, keep-with-next
     87          uint8_t emDecimalStringWrite(uint32_t value, 
     88                                     bool signedValue, 
     89                                     uint8_t* buffer)
     90          {
   \                     emDecimalStringWrite: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
     91            uint8_t length = 0;
   \   00000002   0x2300             MOVS     R3,#+0
     92            if (signedValue && (value & 0x80000000L)) {
   \   00000004   0xB141             CBZ.N    R1,??emDecimalStringWrite_0
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD506             BPL.N    ??emDecimalStringWrite_0
     93              buffer[length++] = '-';
   \   0000000A   0x212D             MOVS     R1,#+45
   \   0000000C   0x2301             MOVS     R3,#+1
     94              // Take the absolute value.  We have already determined
     95              // whether the value is signed.  So we don't care 
     96              // about the high bits anymore.
     97              // The range of 16-bit signed value is -32,768 <-> 32,767,
     98              // and for 32-bit it is -2147483648 <-> 2147483647,
     99              // so we must make an exception for -32,768 and -2147483648
    100              // which don't have a signed equivalent.
    101              if (value != 0x80000000L) {
   \   0000000E   0xF1B0 0x4F00      CMP      R0,#-2147483648
   \   00000012   0x7011             STRB     R1,[R2, #+0]
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x4240             RSBNE    R0,R0,#+0
    102                value = (uint32_t) (- ((int32_t) value));
    103              }
    104            }
    105          
    106            {
    107              uint8_t i;
    108              bool printedLeadingNonZeroValue = false;
   \                     ??emDecimalStringWrite_0: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
    109              // To prevent using 32-bit divide or modulus, 
    110              // since those operations are expensive on a 16-bit processor,
    111              // we use subtraction and a constant array with powers of 10.
    112              for (i = 0; i < 9; i++) {
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x.... 0x....      ADR.W    R5,powers10
    113                uint8_t digit = 0;
   \                     ??emDecimalStringWrite_1: (+1)
   \   00000020   0xF855 0x7024      LDR      R7,[R5, R4, LSL #+2]
   \   00000024   0x2600             MOVS     R6,#+0
   \   00000026   0xE001             B.N      ??emDecimalStringWrite_2
    114                while (value >= powers10[i]) {
    115                  value -= powers10[i];
   \                     ??emDecimalStringWrite_3: (+1)
   \   00000028   0x1BC0             SUBS     R0,R0,R7
    116                  digit++;
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
    117                }
   \                     ??emDecimalStringWrite_2: (+1)
   \   0000002C   0x42B8             CMP      R0,R7
   \   0000002E   0xD2FB             BCS.N    ??emDecimalStringWrite_3
    118                if (digit != 0 || printedLeadingNonZeroValue) {
   \   00000030   0xB2F6             UXTB     R6,R6
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xBF08             IT       EQ 
   \   00000036   0x2900             CMPEQ    R1,#+0
   \   00000038   0xD005             BEQ.N    ??emDecimalStringWrite_4
    119                  buffer[length++] = '0' + digit;
   \   0000003A   0xB2DB             UXTB     R3,R3
   \   0000003C   0xF106 0x0130      ADD      R1,R6,#+48
   \   00000040   0x5499             STRB     R1,[R3, R2]
   \   00000042   0x1C5B             ADDS     R3,R3,#+1
    120                  printedLeadingNonZeroValue = true;
   \   00000044   0x2101             MOVS     R1,#+1
    121                }
    122              }
   \                     ??emDecimalStringWrite_4: (+1)
   \   00000046   0x1C64             ADDS     R4,R4,#+1
   \   00000048   0x2C09             CMP      R4,#+9
   \   0000004A   0xDBE9             BLT.N    ??emDecimalStringWrite_1
    123              buffer[length++] = '0' + value;
   \   0000004C   0xB2DB             UXTB     R3,R3
   \   0000004E   0x3030             ADDS     R0,R0,#+48
   \   00000050   0x5498             STRB     R0,[R3, R2]
    124            }
    125          
    126            return length;
   \   00000052   0x1C58             ADDS     R0,R3,#+1
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0xBDF0             POP      {R4-R7,PC}       ;; return
    127          }
    128          
    129          // Returns number of characters written

   \                                 In section .text, align 2, keep-with-next
    130          uint8_t emPrintfInternal(emPrintfFlushHandler flushHandler, 
    131                                 uint8_t port,
    132                                 PGM_P string, 
    133                                 va_list args)
    134          {
   \                     emPrintfInternal: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4680             MOV      R8,R0
    135            uint8_t localBuffer[LOCAL_BUFFER_SIZE + MAX_SINGLE_COMMAND_BYTES];
    136            uint8_t *localBufferPointer = localBuffer;
    137            uint8_t *localBufferLimit = localBuffer + LOCAL_BUFFER_SIZE;
    138            uint8_t count;
    139            uint8_t total = 0;
   \   00000008   0xA801             ADD      R0,SP,#+4
   \   0000000A   0x4689             MOV      R9,R1
   \   0000000C   0x4614             MOV      R4,R2
   \   0000000E   0x469A             MOV      R10,R3
   \   00000010   0xAD01             ADD      R5,SP,#+4
   \   00000012   0x2700             MOVS     R7,#+0
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000018   0xE019             B.N      ??emPrintfInternal_0
    140          
    141            for (; *string; string++) {
    142              uint8_t next = *string;
    143              if (next != '%')
    144                addByte(next);
    145              else {
    146                string += 1;
    147                switch (*string) {
    148                case '%':
    149                  // escape for printing "%"
    150                  addByte('%');
    151                  break;
    152                case 'c':
    153                  // character
    154                  addByte(va_arg(args, unsigned int) & 0xFF);
    155                  break;
    156                case 'p': 
    157                  // only avr needs to special-case the pgm handling, all other current
    158                  //  platforms fall through to standard string handling.
    159                  #ifdef AVR_ATMEGA
    160                    {
    161                    // flash string
    162                    PGM_P arg = va_arg(args, PGM_P);
    163                    while (true) {
    164                      uint8_t ch = *arg++;
    165                      if (ch == '\0')
    166                        break;
    167                      *(localBufferPointer++) = ch;
    168                      if (localBufferLimit <= localBufferPointer)
    169                        flushBuffer();
    170                    }
    171                    break;
    172                  }
    173                  #endif
    174                case 's': {
    175                  // string
    176                  uint16_t len;
    177                  uint8_t *arg = va_arg(args, uint8_t *);
    178          
    179                  if (arg == NULL) {
    180                    arg = "(null)";
    181                  }
    182          
    183                  flushBuffer();
    184                  for (len=0; arg[len] != '\0'; len++) {};
    185          
    186                  if (flushHandler(port, arg, len) != EMBER_SUCCESS) {
    187                    goto fail;
    188                  }
    189                  total += len;
    190                  break;
    191                }
    192                case 'l':         // 4-byte, %l and %ld = signed, %lu = unsigned
    193                case 'u':         // unsigned 2-byte
    194                case 'd': {       // signed 2-byte
    195                  uint32_t value;
    196                  bool signedValue;
    197                  if (*string == 'l') {
    198                    value = va_arg(args, long int);
    199                    signedValue = (string[1] != 'u');
    200                    if (string[1] == 'u' || string[1] == 'd') {
    201                      string += 1;
    202                    }
    203                  } else if (*string == 'u') { // Need when sizeof(int) != sizeof(uint16_t)
    204                    value = va_arg(args, unsigned int);
    205                    signedValue = false;
    206                  } else {
    207                    value = va_arg(args, int);
    208                    signedValue = true;
    209                  }
    210                  localBufferPointer += emDecimalStringWrite(value,
    211                                                             signedValue,
    212                                                             localBufferPointer);
    213                  break;
    214                }
    215                case 'x':
    216                case 'X': {
    217                  // single hex byte (always prints 2 chars, ex: 0A)
    218                  uint8_t data = va_arg(args, int);
    219                 
    220                  localBufferPointer = emWriteHexInternal(localBufferPointer, data, 2);
    221                  break; }
    222                case '2':
    223                  // %2x only, 2 hex bytes (always prints 4 chars)
    224                case '4':
    225                  // %4x only, 4 hex bytes (always prints 8 chars)
    226                  string += 1;
    227                  if (*string != 'x' && *string != 'X') {
    228                    string -= 1;
    229                  } else if (*(string - 1) == '2') {
    230                    uint16_t data = va_arg(args, int);
    231                    localBufferPointer = emWriteHexInternal(localBufferPointer, data, 4);
    232                  } else {
    233                    uint32_t data = va_arg(args, uint32_t);
   \                     ??emPrintfInternal_1: (+1)
   \   0000001A   0xF85A 0x6B04      LDR      R6,[R10], #+4
    234                    // On the AVR at least, the code size is smaller if we limit the
    235                    // emWriteHexInternal() code to 16-bit numbers and call it twice in
    236                    // this case.  Other processors may have a different tradeoff.
    237                    localBufferPointer = emWriteHexInternal(localBufferPointer, 
    238                                                        (uint16_t) (data >> 16), 
    239                                                        4);
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0x0C31             LSRS     R1,R6,#+16
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       emWriteHexInternal
    240                    localBufferPointer = emWriteHexInternal(localBufferPointer, 
    241                                                        (uint16_t) data, 
    242                                                        4);
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0xB2B1             UXTH     R1,R6
   \                     ??emPrintfInternal_2: (+1)
   \   0000002C   0x.... 0x....      BL       emWriteHexInternal
   \   00000030   0x4605             MOV      R5,R0
    243                  }
    244                  break;
    245                case '\0':
    246                  goto done;
    247                default: {
    248                }
    249                } //close switch.
    250              }
    251              if (localBufferLimit <= localBufferPointer)
   \                     ??emPrintfInternal_3: (+1)
   \   00000032   0xA805             ADD      R0,SP,#+20
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xD309             BCC.N    ??emPrintfInternal_4
    252                flushBuffer();
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x1A2E             SUBS     R6,R5,R0
   \   0000003E   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD136             BNE.N    ??emPrintfInternal_5
   \   00000046   0x19F7             ADDS     R7,R6,R7
   \   00000048   0xB2FF             UXTB     R7,R7
   \   0000004A   0xAD01             ADD      R5,SP,#+4
   \                     ??emPrintfInternal_4: (+1)
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
   \                     ??emPrintfInternal_0: (+1)
   \   0000004E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000052   0x1A2E             SUBS     R6,R5,R0
   \   00000054   0x7820             LDRB     R0,[R4, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD070             BEQ.N    ??emPrintfInternal_6
   \   0000005A   0x2825             CMP      R0,#+37
   \   0000005C   0xD002             BEQ.N    ??emPrintfInternal_7
   \                     ??emPrintfInternal_8: (+1)
   \   0000005E   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   00000062   0xE7E6             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_7: (+1)
   \   00000064   0xF814 0x0F01      LDRB     R0,[R4, #+1]!
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD067             BEQ.N    ??emPrintfInternal_6
   \   0000006C   0x2825             CMP      R0,#+37
   \   0000006E   0xD0F6             BEQ.N    ??emPrintfInternal_8
   \   00000070   0x2832             CMP      R0,#+50
   \   00000072   0xBF18             IT       NE 
   \   00000074   0x2834             CMPNE    R0,#+52
   \   00000076   0xD050             BEQ.N    ??emPrintfInternal_9
   \   00000078   0x2858             CMP      R0,#+88
   \   0000007A   0xD048             BEQ.N    ??emPrintfInternal_10
   \   0000007C   0x2863             CMP      R0,#+99
   \   0000007E   0xD00C             BEQ.N    ??emPrintfInternal_11
   \   00000080   0x2864             CMP      R0,#+100
   \   00000082   0xBF18             IT       NE 
   \   00000084   0x286C             CMPNE    R0,#+108
   \   00000086   0xD02A             BEQ.N    ??emPrintfInternal_12
   \   00000088   0x2870             CMP      R0,#+112
   \   0000008A   0xBF18             IT       NE 
   \   0000008C   0x2873             CMPNE    R0,#+115
   \   0000008E   0xD007             BEQ.N    ??emPrintfInternal_13
   \   00000090   0x2875             CMP      R0,#+117
   \   00000092   0xD024             BEQ.N    ??emPrintfInternal_12
   \   00000094   0x2878             CMP      R0,#+120
   \   00000096   0xD03A             BEQ.N    ??emPrintfInternal_10
   \   00000098   0xE7CB             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_11: (+1)
   \   0000009A   0xF85A 0x0B04      LDR      R0,[R10], #+4
   \   0000009E   0xE7DE             B.N      ??emPrintfInternal_8
   \                     ??emPrintfInternal_13: (+1)
   \   000000A0   0xF85A 0xBB04      LDR      R11,[R10], #+4
   \   000000A4   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000A8   0xBF08             IT       EQ 
   \   000000AA   0x.... 0x....      ADREQ.W  R11,?_0
   \   000000AE   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000B2   0x2800             CMP      R0,#+0
   \                     ??emPrintfInternal_5: (+1)
   \   000000B4   0xD148             BNE.N    ??emPrintfInternal_14
   \   000000B6   0x19F7             ADDS     R7,R6,R7
   \   000000B8   0xB2FF             UXTB     R7,R7
   \   000000BA   0xAD01             ADD      R5,SP,#+4
   \   000000BC   0x2600             MOVS     R6,#+0
   \   000000BE   0xE000             B.N      ??emPrintfInternal_15
   \                     ??emPrintfInternal_16: (+1)
   \   000000C0   0x1C76             ADDS     R6,R6,#+1
   \                     ??emPrintfInternal_15: (+1)
   \   000000C2   0xB2B6             UXTH     R6,R6
   \   000000C4   0xF816 0x000B      LDRB     R0,[R6, R11]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD1F9             BNE.N    ??emPrintfInternal_16
   \   000000CC   0xB2F2             UXTB     R2,R6
   \   000000CE   0x4659             MOV      R1,R11
   \   000000D0   0x4648             MOV      R0,R9
   \   000000D2   0x47C0             BLX      R8
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD137             BNE.N    ??emPrintfInternal_14
   \   000000D8   0x19F7             ADDS     R7,R6,R7
   \   000000DA   0xB2FF             UXTB     R7,R7
   \   000000DC   0xE7A9             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_12: (+1)
   \   000000DE   0x286C             CMP      R0,#+108
   \   000000E0   0xD10A             BNE.N    ??emPrintfInternal_17
   \   000000E2   0x7862             LDRB     R2,[R4, #+1]
   \   000000E4   0xF85A 0x0B04      LDR      R0,[R10], #+4
   \   000000E8   0x2A75             CMP      R2,#+117
   \   000000EA   0xBF0E             ITEE     EQ 
   \   000000EC   0x2100             MOVEQ    R1,#+0
   \   000000EE   0x2101             MOVNE    R1,#+1
   \   000000F0   0x2A64             CMPNE    R2,#+100
   \   000000F2   0xD107             BNE.N    ??emPrintfInternal_18
   \   000000F4   0x1C64             ADDS     R4,R4,#+1
   \   000000F6   0xE005             B.N      ??emPrintfInternal_18
   \                     ??emPrintfInternal_17: (+1)
   \   000000F8   0x2875             CMP      R0,#+117
   \   000000FA   0xF85A 0x0B04      LDR      R0,[R10], #+4
   \   000000FE   0xBF0C             ITE      EQ 
   \   00000100   0x2100             MOVEQ    R1,#+0
   \   00000102   0x2101             MOVNE    R1,#+1
   \                     ??emPrintfInternal_18: (+1)
   \   00000104   0x462A             MOV      R2,R5
   \   00000106   0x.... 0x....      BL       emDecimalStringWrite
   \   0000010A   0x1945             ADDS     R5,R0,R5
   \   0000010C   0xE791             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_10: (+1)
   \   0000010E   0xF85A 0x1B04      LDR      R1,[R10], #+4
   \   00000112   0x2202             MOVS     R2,#+2
   \   00000114   0xB2C9             UXTB     R1,R1
   \                     ??emPrintfInternal_19: (+1)
   \   00000116   0x4628             MOV      R0,R5
   \   00000118   0xE788             B.N      ??emPrintfInternal_2
   \                     ??emPrintfInternal_9: (+1)
   \   0000011A   0xF814 0x0F01      LDRB     R0,[R4, #+1]!
   \   0000011E   0x2878             CMP      R0,#+120
   \   00000120   0xBF1C             ITT      NE 
   \   00000122   0x2858             CMPNE    R0,#+88
   \   00000124   0x1E64             SUBNE    R4,R4,#+1
   \   00000126   0xD184             BNE.N    ??emPrintfInternal_3
   \   00000128   0xF814 0x0C01      LDRB     R0,[R4, #-1]
   \   0000012C   0x2832             CMP      R0,#+50
   \   0000012E   0xF47F 0xAF74      BNE.W    ??emPrintfInternal_1
   \   00000132   0xF85A 0x1B04      LDR      R1,[R10], #+4
   \   00000136   0x2204             MOVS     R2,#+4
   \   00000138   0xB289             UXTH     R1,R1
   \   0000013A   0xE7EC             B.N      ??emPrintfInternal_19
    253            }
    254            
    255           done:
    256            flushBuffer();
   \                     ??emPrintfInternal_6: (+1)
   \   0000013C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000140   0xB910             CBNZ.N   R0,??emPrintfInternal_14
    257            return total;
   \   00000142   0x19F0             ADDS     R0,R6,R7
   \   00000144   0xB2C0             UXTB     R0,R0
   \   00000146   0xE000             B.N      ??emPrintfInternal_20
    258          
    259           fail:
    260            return 0;
   \                     ??emPrintfInternal_14: (+1)
   \   00000148   0x2000             MOVS     R0,#+0
   \                     ??emPrintfInternal_20: (+1)
   \   0000014A   0xB007             ADD      SP,SP,#+28
   \   0000014C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    261          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xB2F2             UXTB     R2,R6
   \   00000002   0xA901             ADD      R1,SP,#+4
   \   00000004   0x4648             MOV      R0,R9
   \   00000006   0x4740             BX       R8
    262          
    263          //------------------------------------------------------------------------------
    264          

   \                                 In section .text, align 2, keep-with-next
    265          EmberStatus emberSerialWriteByte(uint8_t port, uint8_t dataByte)
    266          {
   \                     emberSerialWriteByte: (+1)
   \   00000000   0xB502             PUSH     {R1,LR}
    267            return emberSerialWriteData(port, &dataByte, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       emberSerialWriteData
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    268          }
    269          

   \                                 In section .text, align 2, keep-with-next
    270          EmberStatus emberSerialWriteHex(uint8_t port, uint8_t dataByte)
    271          {
   \                     emberSerialWriteHex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    272            uint8_t hex[2];
    273            emWriteHexInternal(hex, dataByte, 2);
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      BL       emWriteHexInternal
    274            return emberSerialWriteData(port, hex, 2);
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       emberSerialWriteData
   \   00000018   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          EmberStatus emberSerialPrintBytes(uint8_t port,
    278                                            PGM_P prefix,
    279                                            uint8_t *bytes,
    280                                            uint16_t count)
    281          {
   \                     emberSerialPrintBytes: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461E             MOV      R6,R3
    282            EmberStatus status;
    283            uint16_t i;
    284            status = emberSerialWriteString(port, prefix);
   \   0000000A   0x.... 0x....      BL       emberSerialWriteString
    285            if (status != EMBER_SUCCESS) {
   \   0000000E   0xB9B0             CBNZ.N   R0,??emberSerialPrintBytes_0
    286              return status;
    287            }
    288            for (i = 0; i < count; i++) {
   \   00000010   0x2700             MOVS     R7,#+0
   \   00000012   0x.... 0x....      ADR.W    R8,?_1
   \   00000016   0x....             ADR.N    R4,??DataTable6  ;; ""
   \   00000018   0x.... 0x....      ADR.W    R10,??DataTable6_1  ;; " "
   \   0000001C   0xE001             B.N      ??emberSerialPrintBytes_1
   \                     ??emberSerialPrintBytes_2: (+1)
   \   0000001E   0x1C7F             ADDS     R7,R7,#+1
   \   00000020   0xB2BF             UXTH     R7,R7
   \                     ??emberSerialPrintBytes_1: (+1)
   \   00000022   0x42B7             CMP      R7,R6
   \   00000024   0xDA0B             BGE.N    ??emberSerialPrintBytes_0
    289              status = emberSerialPrintf(port,
    290                                         "%x%s",
    291                                         bytes[i],
    292                                         (i < count - 1
    293                                          ? " "
    294                                          : ""));
   \   00000026   0x1E70             SUBS     R0,R6,#+1
   \   00000028   0x4287             CMP      R7,R0
   \   0000002A   0x5D7A             LDRB     R2,[R7, R5]
   \   0000002C   0xBFB4             ITE      LT 
   \   0000002E   0x4653             MOVLT    R3,R10
   \   00000030   0x4623             MOVGE    R3,R4
   \   00000032   0x4641             MOV      R1,R8
   \   00000034   0x4648             MOV      R0,R9
   \   00000036   0x.... 0x....      BL       emberSerialPrintf
    295              if (status != EMBER_SUCCESS) {
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0EF             BEQ.N    ??emberSerialPrintBytes_2
    296                return status;
    297              }
    298            }
    299            return status;
   \                     ??emberSerialPrintBytes_0: (+1)
   \   0000003E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    300          }
    301          

   \                                 In section .text, align 4, keep-with-next
    302          EmberStatus emberSerialPrintCarriageReturn(uint8_t port)
    303          {
    304            return emberSerialPrintf(port, "\r\n");
   \                     emberSerialPrintCarriageReturn: (+1)
   \   00000000   0xA100             ADR.N    R1,??emberSerialPrintCarriageReturn_0  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000002   0xE001             B.N      ??emberSerialPrintCarriageReturn_1
   \                     ??emberSerialPrintCarriageReturn_0:
   \   00000004   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    
   \                     ??emberSerialPrintCarriageReturn_1: (+1)
   \   00000008                      REQUIRE emberSerialPrintf
   \   00000008                      ;; // Fall through to label emberSerialPrintf
    305          }
    306          

   \                                 In section .text, align 2, keep-with-next
    307          EmberStatus emberSerialPrintf(uint8_t port, PGM_P formatString, ...)
    308          {
   \                     emberSerialPrintf: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    309            EmberStatus stat;
    310            va_list ap;
    311            va_start (ap, formatString);
   \   00000004   0xAA02             ADD      R2,SP,#+8
    312            stat = emberSerialPrintfVarArg(port, formatString, ap);
    313            va_end (ap);
    314            return stat;
   \   00000006   0x.... 0x....      BL       emberSerialPrintfVarArg
   \   0000000A   0xBC02             POP      {R1}
   \   0000000C   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    315          }
    316          

   \                                 In section .text, align 2, keep-with-next
    317          EmberStatus emberSerialPrintfLine(uint8_t port, PGM_P formatString, ...)
    318          {
   \                     emberSerialPrintfLine: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4604             MOV      R4,R0
    319            EmberStatus stat;
    320            va_list ap;
    321            va_start (ap, formatString);
   \   00000006   0xAA04             ADD      R2,SP,#+16
    322            stat = emberSerialPrintfVarArg(port, formatString, ap);
   \   00000008   0x.... 0x....      BL       emberSerialPrintfVarArg
   \   0000000C   0x4605             MOV      R5,R0
    323            va_end (ap);
    324            emberSerialPrintCarriageReturn(port);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       emberSerialPrintCarriageReturn
    325            return stat;
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0xBC32             POP      {R1,R4,R5}
   \   00000018   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    326          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_2:
   \   00000000   0x20 0x00          DC8 " "

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_3:
   \   00000000   0x00               DC8 ""

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x28 0x6E          DC8 "(null)"
   \              0x75 0x6C    
   \              0x6C 0x29    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x25 0x78          DC8 "%x%s"
   \              0x25 0x73    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      20   emDecimalStringWrite
      64   emPrintfInternal
        64   -- Indirect call
        64   -> emDecimalStringWrite
        64   -> emWriteHexInternal
      16   emWriteHexInternal
      32   emberSerialPrintBytes
        32   -> emberSerialPrintf
        32   -> emberSerialWriteString
       0   emberSerialPrintCarriageReturn
         0   -> emberSerialPrintf
      16   emberSerialPrintf
        16   -> emberSerialPrintfVarArg
      24   emberSerialPrintfLine
        24   -> emberSerialPrintCarriageReturn
        24   -> emberSerialPrintfVarArg
       8   emberSerialWriteByte
         8   -> emberSerialWriteData
      16   emberSerialWriteHex
        16   -> emWriteHexInternal
        16   -> emberSerialWriteData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       8  ?Subroutine0
       8  ?_0
       8  ?_1
       2  ?_2
       1  ?_3
       4  ?_4
      88  emDecimalStringWrite
     336  emPrintfInternal
      42  emWriteHexInternal
      66  emberSerialPrintBytes
       8  emberSerialPrintCarriageReturn
      16  emberSerialPrintf
      28  emberSerialPrintfLine
      12  emberSerialWriteByte
      26  emberSerialWriteHex
      36  powers10

 
   7 bytes in section .rodata
 690 bytes in section .text
 
 690 bytes of CODE  memory
   7 bytes of CONST memory

Errors: none
Warnings: none
