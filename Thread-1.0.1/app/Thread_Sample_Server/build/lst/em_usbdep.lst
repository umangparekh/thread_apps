###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  13:29:26
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\usb\em_usbdep.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\usb\em_usbdep.c -D
#        APP_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D
#        PHY_EM3XX -D "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"em_usbdep.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\usb\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\em_usbdep.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\em_usbdep.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\usb\em_usbdep.c
      1          /**************************************************************************//**
      2           * @file
      3           * @brief USB protocol stack library, USB device endpoint handlers.
      4           * @author Nathaniel Ting
      5           * @version 3.20.3
      6           * <!-- Copyright 2013 by Silicon Laboratories. All rights reserved.     *80*-->
      7           *****************************************************************************/
      8          
      9          #include PLATFORM_HEADER
     10          #include "stack/include/ember.h"
     11          #include "hal/hal.h"
     12          
     13          #if defined(CORTEXM3_EM35X_USB)
     14          #include "em_usb.h"
     15          #include "em_usbhal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USBDHAL_StartEp0Setup(struct <unnamed> *)
   \                     USBDHAL_StartEp0Setup: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x1034      STRB     R1,[R0, #+52]
   \   00000006   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x1D01             ADDS     R1,R0,#+4
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USBDHAL_ReenableEp0Setup(struct <unnamed> *)
   \                     USBDHAL_ReenableEp0Setup: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp enum <unnamed> USBDHAL_StallEp(struct <unnamed> *)
   \                     USBDHAL_StallEp: (+1)
   \   00000000   0x7882             LDRB     R2,[R0, #+2]
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable4  ;; 0x40011054
   \   0000000A   0xB118             CBZ.N    R0,??USBDHAL_StallEp_0
   \   0000000C   0x6810             LDR      R0,[R2, #+0]
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0x6010             STR      R0,[R2, #+0]
   \   00000012   0xE002             B.N      ??USBDHAL_StallEp_1
   \                     ??USBDHAL_StallEp_0: (+1)
   \   00000014   0x6850             LDR      R0,[R2, #+4]
   \   00000016   0x4308             ORRS     R0,R1,R0
   \   00000018   0x6050             STR      R0,[R2, #+4]
   \                     ??USBDHAL_StallEp_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
     16          #include "em_usbtypes.h"
     17          #include "em_usbd.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USBD_ArmEp(struct <unnamed> *)
   \                     USBD_ArmEp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x78A0             LDRB     R0,[R4, #+2]
   \   00000006   0xB918             CBNZ.N   R0,??USBD_ArmEp_0
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000000E   0x....             B.N      USBD_ArmEp0
   \                     ??USBD_ArmEp_0: (+1)
   \   00000010   0x7821             LDRB     R1,[R4, #+0]
   \   00000012   0xB309             CBZ.N    R1,??USBD_ArmEp_1
   \   00000014   0x6921             LDR      R1,[R4, #+16]
   \   00000016   0x89A5             LDRH     R5,[R4, #+12]
   \   00000018   0x428D             CMP      R5,R1
   \   0000001A   0xBF88             IT       HI 
   \   0000001C   0x460D             MOVHI    R5,R1
   \   0000001E   0x1B49             SUBS     R1,R1,R5
   \   00000020   0x6121             STR      R1,[R4, #+16]
   \   00000022   0x6961             LDR      R1,[R4, #+20]
   \   00000024   0x1869             ADDS     R1,R5,R1
   \   00000026   0x6161             STR      R1,[R4, #+20]
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xBF1C             ITT      NE 
   \   0000002C   0x68A1             LDRNE    R1,[R4, #+8]
   \   0000002E   0x2900             CMPNE    R1,#+0
   \   00000030   0xD005             BEQ.N    ??USBD_ArmEp_2
   \   00000032   0x....             LDR.N    R3,??DataTable4_1
   \   00000034   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \   00000038   0xB2EA             UXTB     R2,R5
   \   0000003A   0x.... 0x....      BL       halCommonMemMove
   \                     ??USBD_ArmEp_2: (+1)
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x1828             ADDS     R0,R5,R0
   \   00000042   0x60A0             STR      R0,[R4, #+8]
   \   00000044   0x78A1             LDRB     R1,[R4, #+2]
   \   00000046   0x....             LDR.N    R0,??DataTable4_2
   \   00000048   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000004C   0x6005             STR      R5,[R0, #+0]
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x78A1             LDRB     R1,[R4, #+2]
   \   00000052   0x4088             LSLS     R0,R0,R1
   \   00000054   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40011008
   \   00000056   0x6008             STR      R0,[R1, #+0]
   \                     ??USBD_ArmEp_1: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USBD_ArmEp0(struct <unnamed> *)
   \                     USBD_ArmEp0: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xB1A0             CBZ.N    R0,??USBD_ArmEp0_0
   \   00000008   0x6920             LDR      R0,[R4, #+16]
   \   0000000A   0x89A5             LDRH     R5,[R4, #+12]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xBF88             IT       HI 
   \   00000010   0x4605             MOVHI    R5,R0
   \   00000012   0x1B40             SUBS     R0,R0,R5
   \   00000014   0x6120             STR      R0,[R4, #+16]
   \   00000016   0xB12D             CBZ.N    R5,??USBD_ArmEp0_1
   \   00000018   0x....             LDR.N    R0,??DataTable4_1
   \   0000001A   0x68A1             LDR      R1,[R4, #+8]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xB2EA             UXTB     R2,R5
   \   00000020   0x.... 0x....      BL       halCommonMemMove
   \                     ??USBD_ArmEp0_1: (+1)
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x1828             ADDS     R0,R5,R0
   \   00000028   0x60A0             STR      R0,[R4, #+8]
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40011008
   \   0000002E   0x6085             STR      R5,[R0, #+8]
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \                     ??USBD_ArmEp0_0: (+1)
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USBD_ReArmEp0(struct <unnamed> *)
   \                     USBD_ReArmEp0: (+1)
   \   00000000   0x....             B.N      USBD_ArmEp0
     18          
     19          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
     20          
     21          /*
     22           * USBDEP_Ep0Handler() is called each time a packet has been transmitted
     23           * or recieved on the default endpoint.
     24           * A state machine navigate us through the phases of a control transfer
     25           * according to "chapter 9" in the USB spec.
     26           */

   \                                 In section .text, align 2, keep-with-next
     27          void USBDEP_Ep0Handler( USBD_Device_TypeDef *device )
     28          {
   \                     USBDEP_Ep0Handler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
     29            int status;
     30            USBD_Ep_TypeDef *ep;
     31            static bool statusIn;
     32            static uint32_t xferred;
     33            static USB_XferCompleteCb_TypeDef callback;
     34            ep = &device->ep[ 0 ];
   \   00000004   0xF106 0x0434      ADD      R4,R6,#+52
     35            
     36            #ifdef USB_DEBUG_EP0
     37            DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "ep->state = ");
     38            #endif
     39           
     40          
     41            switch ( ep->state )
   \   00000008   0x....             LDR.N    R5,??DataTable4_4
   \   0000000A   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   0000000E   0x68AF             LDR      R7,[R5, #+8]
   \   00000010   0xB130             CBZ.N    R0,??USBDEP_Ep0Handler_0
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD041             BEQ.N    ??USBDEP_Ep0Handler_1
   \   00000016   0xD366             BCC.N    ??USBDEP_Ep0Handler_2
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xF000 0x8084      BEQ.W    ??USBDEP_Ep0Handler_3
   \                     ??USBDEP_Ep0Handler_4: (+1)
   \   0000001E   0xBDF1             POP      {R0,R4-R7,PC}
     42            {
     43              case D_EP_IDLE:
     44                ep->remaining = 0;
   \                     ??USBDEP_Ep0Handler_0: (+1)
   \   00000020   0x6120             STR      R0,[R4, #+16]
     45                ep->zlp = 0;
   \   00000022   0x7060             STRB     R0,[R4, #+1]
     46                callback = NULL;
   \   00000024   0x60A8             STR      R0,[R5, #+8]
     47                statusIn = false;
   \   00000026   0x7028             STRB     R0,[R5, #+0]
     48                #ifdef USB_DEBUG_EP0
     49                DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "IDLE\r\n");
     50                #endif
     51          
     52                if (*EPOUTBUFSIZE[0] == 0)
   \   00000028   0x....             LDR.N    R0,??DataTable4_5
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD0F5             BEQ.N    ??USBDEP_Ep0Handler_4
     53                {
     54          
     55                  #ifdef USB_DEBUG_EP0
     56                  DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "0 byte ack\r\n");
     57                  #endif
     58                  break;
     59                }
     60                status = USBDCH9_SetupCmd( device );
     61          
     62                if ( status == USB_STATUS_REQ_ERR )
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       USBDCH9_SetupCmd
   \   00000038   0xF110 0x0F01      CMN      R0,#+1
   \   0000003C   0xD107             BNE.N    ??USBDEP_Ep0Handler_5
     63                {
     64                  // ignore error for now since this can be triggered by requests we don't
     65                  // need to handle
     66                  ep->in = true;
   \   0000003E   0x.... 0x....      BL       ?Subroutine1
     67                  USBDHAL_StallEp( ep );              /* Stall Ep0 IN                 */
     68                  ep->in = false;                     /* OUT for next SETUP           */
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7020             STRB     R0,[R4, #+0]
     69                  // USBDHAL_StallEp( ep );              /* Stall Ep0 OUT                */
     70                  USBDHAL_ReenableEp0Setup( device ); /* Prepare for next SETUP packet*/
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000004C   0x....             B.N      USBDHAL_ReenableEp0Setup
     71                }
     72                else /* ( Status == USB_STATUS_OK ) */
     73                {
     74                  if ( (ep->state == D_EP_RECEIVING) || (ep->state == D_EP_TRANSMITTING) )
   \                     ??USBDEP_Ep0Handler_5: (+1)
   \   0000004E   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000052   0x2802             CMP      R0,#+2
   \   00000054   0xBF12             ITEE     NE 
   \   00000056   0x2801             CMPNE    R0,#+1
   \   00000058   0x6A60             LDREQ    R0,[R4, #+36]
   \   0000005A   0x60A8             STREQ    R0,[R5, #+8]
     75                  {
     76                    callback = ep->xferCompleteCb;
     77                  }
     78          
     79                  if ( ep->state != D_EP_RECEIVING )
   \   0000005C   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD06E             BEQ.N    ??USBDEP_Ep0Handler_6
     80                  {
     81                    // enable with care. since setup involves lots of transfers, the debug
     82                    // buffer will fill up very quickly.
     83                    // #ifdef USB_DEBUG_EP0
     84                    // DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "ep->remaining = %d\r\n",ep->remaining);
     85                    // #endif
     86          
     87                    if ( ep->remaining )
   \   00000064   0x6920             LDR      R0,[R4, #+16]
   \   00000066   0xB160             CBZ.N    R0,??USBDEP_Ep0Handler_7
     88                    {
     89                      /* Data will be sent to host, check if a ZLP must be appended */
     90                      if ( ( ep->remaining < device->setup->wLength ) &&
     91                           ( ep->remaining % ep->packetSize == 0    )    )
   \   00000068   0x6831             LDR      R1,[R6, #+0]
   \   0000006A   0x88C9             LDRH     R1,[R1, #+6]
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD268             BCS.N    ??USBDEP_Ep0Handler_6
   \   00000070   0x89A1             LDRH     R1,[R4, #+12]
   \   00000072   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000076   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD161             BNE.N    ??USBDEP_Ep0Handler_6
     92                      {
     93                        ep->zlp = 1;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE044             B.N      ??USBDEP_Ep0Handler_8
     94                      }
     95                    }
     96                    else
     97                    {
     98                      /* Prepare for next SETUP packet*/
     99                      USBDHAL_ReenableEp0Setup( device );
   \                     ??USBDEP_Ep0Handler_7: (+1)
   \   00000082   0x4630             MOV      R0,R6
   \   00000084   0x.... 0x....      BL       USBDHAL_ReenableEp0Setup
    100          
    101                      /* No data stage, a ZLP may have been sent. If not, send one */
    102                      if ( ep->zlp == 0 )
   \   00000088   0x7860             LDRB     R0,[R4, #+1]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD156             BNE.N    ??USBDEP_Ep0Handler_9
    103                      {
    104                        #ifdef USB_DEBUG_EP0
    105                        DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "no ack\r\n");
    106                        #endif
    107                        ep->state = D_EP_IDLE;
    108                        USBD_Write( 0, NULL, 0, NULL );             /* ACK to host */
   \   0000008E   0x2200             MOVS     R2,#+0
   \   00000090   0xF884 0x0020      STRB     R0,[R4, #+32]
   \   00000094   0x2300             MOVS     R3,#+0
   \   00000096   0x4611             MOV      R1,R2
   \   00000098   0xE022             B.N      ??USBDEP_Ep0Handler_10
    109                        ep->state = D_EP_STATUS;
    110                      }
    111                      else
    112                      {
    113                        ep->state = D_EP_IDLE;
    114                        ep->in = false;                      /* OUT for next SETUP */
    115                      }
    116                    }
    117                  }
    118                }
    119                break; //D_EP_IDLE
    120              case D_EP_RECEIVING:
    121                if ( ep->remaining )
   \                     ??USBDEP_Ep0Handler_1: (+1)
   \   0000009A   0x6920             LDR      R0,[R4, #+16]
   \   0000009C   0xB110             CBZ.N    R0,??USBDEP_Ep0Handler_11
    122                {
    123                  ep->in = false;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x7020             STRB     R0,[R4, #+0]
    124                  USBD_ReArmEp0( ep );
   \   000000A2   0xE022             B.N      ??USBDEP_Ep0Handler_12
    125                }
    126                else
    127                {
    128                  status = USB_STATUS_OK;
    129                  if ( callback != NULL )
   \                     ??USBDEP_Ep0Handler_11: (+1)
   \   000000A4   0x0038             MOVS     R0,R7
   \   000000A6   0x....             LDR.N    R6,??DataTable4_6
   \   000000A8   0xD012             BEQ.N    ??USBDEP_Ep0Handler_13
    130                  {
    131                    status = callback( USB_STATUS_OK, ep->xferred, 0 );
   \   000000AA   0x6961             LDR      R1,[R4, #+20]
   \   000000AC   0x2200             MOVS     R2,#+0
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x47B8             BLX      R7
    132                    callback = NULL;
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0x60A9             STR      R1,[R5, #+8]
    133                  }
    134          
    135                  if ( status != USB_STATUS_OK )
   \   000000B6   0xB158             CBZ.N    R0,??USBDEP_Ep0Handler_13
    136                  {
    137                    ep->in = true;
   \   000000B8   0x.... 0x....      BL       ?Subroutine1
    138                    USBDHAL_StallEp( ep );              /* Stall Ep0 IN                */
    139                    ep->in = false;                     /* OUT for next SETUP          */
   \                     ??CrossCallReturnLabel_0: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7020             STRB     R0,[R4, #+0]
    140                    USBDHAL_StallEp( ep );              /* Stall Ep0 OUT               */
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       USBDHAL_StallEp
    141                    USBDHAL_StartEp0Setup( dev );       /* Prepare for next SETUP pkt. */
   \   000000C6   0x6830             LDR      R0,[R6, #+0]
   \   000000C8   0x.... 0x....      BL       USBDHAL_StartEp0Setup
    142                    ep->state = D_EP_IDLE;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xE027             B.N      ??USBDEP_Ep0Handler_14
    143                  }
    144                  else
    145                  {
    146          
    147                    USBDHAL_StartEp0Setup( dev );      /* Prepare for next SETUP packet*/
   \                     ??USBDEP_Ep0Handler_13: (+1)
   \   000000D0   0x6830             LDR      R0,[R6, #+0]
   \   000000D2   0x.... 0x....      BL       USBDHAL_StartEp0Setup
    148                    ep->state = D_EP_IDLE;             /* USBD_Write() sets state back */
   \   000000D6   0x.... 0x....      BL       ?Subroutine2
    149                                                       /* to EP_TRANSMITTING           */
    150                    USBD_Write( 0, NULL, 0, NULL );
   \                     ??CrossCallReturnLabel_2: (+1)
   \   000000DA   0x2300             MOVS     R3,#+0
   \   000000DC   0x4602             MOV      R2,R0
   \   000000DE   0x4601             MOV      R1,R0
   \                     ??USBDEP_Ep0Handler_10: (+1)
   \   000000E0   0x.... 0x....      BL       USBD_Write
    151                    ep->state = D_EP_STATUS;
   \   000000E4   0xE01B             B.N      ??USBDEP_Ep0Handler_15
    152                  }
    153                }
    154                break;
    155              case D_EP_TRANSMITTING:
    156                #ifdef USB_DEBUG_EP0
    157                DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "TX\r\n");
    158                #endif
    159                if ( ep->remaining )
   \                     ??USBDEP_Ep0Handler_2: (+1)
   \   000000E6   0x6920             LDR      R0,[R4, #+16]
   \   000000E8   0xB118             CBZ.N    R0,??USBDEP_Ep0Handler_16
    160                {
    161                  /* There is more data to transmit */
    162                  USBD_ReArmEp0( ep );
   \                     ??USBDEP_Ep0Handler_12: (+1)
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000F0   0x....             B.N      USBD_ReArmEp0
    163          
    164          
    165                  // enable with care. since setup involves lots of transfers, the debug
    166                  // buffer will fill up very quickly.
    167                  // #ifdef USB_DEBUG_EP0
    168                  // DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "ep->remaining = %d\r\n",ep->remaining);
    169                  // #endif
    170                }
    171                else
    172                {
    173                  #ifdef USB_DEBUG_EP0
    174                  DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "TX done\r\n");
    175                  #endif
    176                  /* All data transferred, is a ZLP packet needed ? */
    177                  if ( ep->zlp == 1 )
   \                     ??USBDEP_Ep0Handler_16: (+1)
   \   000000F2   0x7860             LDRB     R0,[R4, #+1]
   \   000000F4   0x2801             CMP      R0,#+1
   \   000000F6   0xD10B             BNE.N    ??USBDEP_Ep0Handler_17
    178                  {
    179                    #ifdef USB_DEBUG_EP0
    180                    DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"ack\r\n");
    181                    #endif
    182                    xferred   = ep->xferred;
   \   000000F8   0x6960             LDR      R0,[R4, #+20]
   \   000000FA   0x6068             STR      R0,[R5, #+4]
    183                    ep->state = D_EP_IDLE;          /* USBD_Write() sets state back */
    184                                                    /* to EP_TRANSMITTING           */
    185                    USBD_Write( 0, NULL, 0, NULL ); /* Send ZLP                     */
   \   000000FC   0x2300             MOVS     R3,#+0
   \   000000FE   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000102   0x4602             MOV      R2,R0
   \   00000104   0x4601             MOV      R1,R0
   \   00000106   0x.... 0x....      BL       USBD_Write
    186                    ep->zlp = 2;
   \   0000010A   0x2002             MOVS     R0,#+2
   \                     ??USBDEP_Ep0Handler_8: (+1)
   \   0000010C   0x7060             STRB     R0,[R4, #+1]
   \   0000010E   0xBDF1             POP      {R0,R4-R7,PC}
    187                  }
    188                  else
    189                  {
    190                    if ( ep->zlp == 0 )
   \                     ??USBDEP_Ep0Handler_17: (+1)
   \   00000110   0xB918             CBNZ.N   R0,??USBDEP_Ep0Handler_18
    191                    {
    192                      xferred = ep->xferred;
   \   00000112   0x6960             LDR      R0,[R4, #+20]
   \   00000114   0x6068             STR      R0,[R5, #+4]
    193                      ep->zlp = 1;
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0x7060             STRB     R0,[R4, #+1]
    194                    }
    195          
    196          
    197                    // host will send ack, which will be handled by hardware
    198                    // ep->state = D_EP_IDLE;
    199                    // USBD_Read( 0, NULL, 0, NULL );  /* Get ZLP packet (ACK) from host */
    200                    statusIn = true;
   \                     ??USBDEP_Ep0Handler_18: (+1)
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0x7028             STRB     R0,[R5, #+0]
    201                    ep->state = D_EP_STATUS;
   \                     ??USBDEP_Ep0Handler_15: (+1)
   \   0000011E   0x2003             MOVS     R0,#+3
   \                     ??USBDEP_Ep0Handler_14: (+1)
   \   00000120   0xF884 0x0020      STRB     R0,[R4, #+32]
   \   00000124   0xBDF1             POP      {R0,R4-R7,PC}
    202                  }
    203                }
    204                break;
    205              case D_EP_STATUS:
    206                #ifdef USB_DEBUG_EP0
    207                DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "STATUS\r\n");
    208                #endif
    209                if ( statusIn )
   \                     ??USBDEP_Ep0Handler_3: (+1)
   \   00000126   0x7828             LDRB     R0,[R5, #+0]
   \   00000128   0xB110             CBZ.N    R0,??USBDEP_Ep0Handler_19
    210                {
    211                  USBDHAL_ReenableEp0Setup( device );
   \   0000012A   0x4630             MOV      R0,R6
   \   0000012C   0x.... 0x....      BL       USBDHAL_ReenableEp0Setup
    212                }
    213          
    214                if ( callback != NULL )
   \                     ??USBDEP_Ep0Handler_19: (+1)
   \   00000130   0x0038             MOVS     R0,R7
   \   00000132   0xD003             BEQ.N    ??USBDEP_Ep0Handler_9
    215                {
    216                  callback( USB_STATUS_OK, xferred, 0 );
   \   00000134   0x6869             LDR      R1,[R5, #+4]
   \   00000136   0x2200             MOVS     R2,#+0
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x47B8             BLX      R7
    217                }
    218          
    219                ep->state = D_EP_IDLE;
   \                     ??USBDEP_Ep0Handler_9: (+1)
   \   0000013C   0x.... 0x....      BL       ?Subroutine2
    220                ep->in = false;                     /* OUT for next SETUP */
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000140   0x7020             STRB     R0,[R4, #+0]
    221                break;
    222              }
    223          }
   \                     ??USBDEP_Ep0Handler_6: (+1)
   \   00000142   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x7020             STRB     R0,[R4, #+0]
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x....             B.N      USBDHAL_StallEp

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xF884 0x0020      STRB     R0,[R4, #+32]
   \   00000006   0x4770             BX       LR

   \                                 In section .bss, align 4
   \                     ??statusIn:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 4
   \   00000008                      DS8 4
    224          

   \                                 In section .text, align 2, keep-with-next
    225          void USBDEP_EpHandler( uint8_t epAddr )
    226          {
   \                     USBDEP_EpHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    227            USB_XferCompleteCb_TypeDef callback;
    228            
    229            USBD_Ep_TypeDef *ep = USBD_GetEpFromAddr( epAddr );
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x0601             LSLS     R1,R0,#+24
   \   00000006   0x....             LDR.N    R1,??DataTable4_6
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF000 0x020F      AND      R2,R0,#0xF
   \   0000000E   0xBF47             ITTEE    MI 
   \   00000010   0x1851             ADDMI    R1,R2,R1
   \   00000012   0xF891 0x10D4      LDRBMI   R1,[R1, #+212]
   \   00000016   0x1851             ADDPL    R1,R2,R1
   \   00000018   0xF891 0x10E1      LDRBPL   R1,[R1, #+225]
   \   0000001C   0xB129             CBZ.N    R1,??USBDEP_EpHandler_0
   \   0000001E   0x....             LDR.N    R0,??DataTable4_6
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2228             MOVS     R2,#+40
   \   00000024   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000028   0xE004             B.N      ??USBDEP_EpHandler_1
   \                     ??USBDEP_EpHandler_0: (+1)
   \   0000002A   0x210F             MOVS     R1,#+15
   \   0000002C   0x4208             TST      R0,R1
   \   0000002E   0xD103             BNE.N    ??USBDEP_EpHandler_2
   \   00000030   0x....             LDR.N    R0,??DataTable4_6
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \                     ??USBDEP_EpHandler_1: (+1)
   \   00000034   0xF100 0x0434      ADD      R4,R0,#+52
    230          
    231            #if defined(USB_DEBUG_READ) || defined(USB_DEBUG_WRITE) || defined(USB_DEBUG_EP)
    232            DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "EP%dHandler\tep->state = %d\r\n",ep->num,ep->state);
    233            #endif
    234          
    235          
    236            if ( ep->state == D_EP_TRANSMITTING ) 
   \                     ??USBDEP_EpHandler_2: (+1)
   \   00000038   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD114             BNE.N    ??USBDEP_EpHandler_3
    237            {
    238              #ifdef USB_DEBUG_EP
    239              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "ep->xferred=%d \tep->remaining = %d\r\n",ep->xferred, ep->remaining);
    240              #endif
    241              if ( ep->remaining )
   \   00000040   0x6920             LDR      R0,[R4, #+16]
   \   00000042   0xB118             CBZ.N    R0,??USBDEP_EpHandler_4
    242              {
    243                // uint8_t txSize = (ep->remaining > ep->packetSize) ? ep->packetSize : ep->remaining;
    244                /* There is more data to transmit */
    245                USBD_ArmEp( ep );
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000004A   0x....             B.N      USBD_ArmEp
    246                // ep->buf += ep->xferred;
    247                // ep->buf += txSize;
    248              }
    249              else // Done transmitting
    250              {
    251                // Put ep back into idle state
    252                ep->state = D_EP_IDLE;
   \                     ??USBDEP_EpHandler_4: (+1)
   \   0000004C   0xF884 0x0020      STRB     R0,[R4, #+32]
    253          
    254                // If there's a callback, call it
    255                if ( ep->xferCompleteCb )
   \   00000050   0x6A63             LDR      R3,[R4, #+36]
   \   00000052   0x0018             MOVS     R0,R3
   \   00000054   0xD004             BEQ.N    ??USBDEP_EpHandler_5
    256                {
    257                  callback = ep->xferCompleteCb;
    258                  ep->xferCompleteCb = NULL;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6260             STR      R0,[R4, #+36]
    259                  callback( USB_STATUS_OK, ep->xferred, ep->remaining );
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x6961             LDR      R1,[R4, #+20]
   \   0000005E   0x4798             BLX      R3
    260                }
    261                #if EM_SERIAL3_ENABLED
    262                  halInternalStartUartTx(3);
   \                     ??USBDEP_EpHandler_5: (+1)
   \   00000060   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x.... 0x....      B.W      halInternalStartUartTx
    263                #endif
    264              }
    265            }
    266            else if ( ep->state == D_EP_RECEIVING )
   \                     ??USBDEP_EpHandler_3: (+1)
   \   0000006A   0x2802             CMP      R0,#+2
   \   0000006C   0xD129             BNE.N    ??USBDEP_EpHandler_6
    267            {
    268              #ifdef USB_DEBUG_EP
    269              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "ep->remaining = %d\r\n",ep->remaining);
    270              #endif
    271          
    272              if ( ep->remaining )
   \   0000006E   0x6922             LDR      R2,[R4, #+16]
   \   00000070   0xB1DA             CBZ.N    R2,??USBDEP_EpHandler_7
    273              {
    274                /* Short Packet */
    275                if (ep->packetSize>(ep->remaining + *EPOUTBUFSIZE[ep->num]))
   \   00000072   0x....             LDR.N    R5,??DataTable4_5
   \   00000074   0x78A0             LDRB     R0,[R4, #+2]
   \   00000076   0xF855 0x0020      LDR      R0,[R5, R0, LSL #+2]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x89A1             LDRH     R1,[R4, #+12]
   \   0000007E   0x1880             ADDS     R0,R0,R2
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD207             BCS.N    ??USBDEP_EpHandler_8
    276                {
    277                  
    278                  
    279                  if ( ep->xferCompleteCb )
   \   00000084   0x6A63             LDR      R3,[R4, #+36]
   \   00000086   0x0018             MOVS     R0,R3
   \   00000088   0xD01B             BEQ.N    ??USBDEP_EpHandler_6
    280                  {
    281                    callback = ep->xferCompleteCb;
    282                    ep->xferCompleteCb = NULL;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x6260             STR      R0,[R4, #+36]
    283                    callback( USB_STATUS_TIMEOUT, ep->xferred, ep->remaining );
   \   0000008E   0xF06F 0x000B      MVN      R0,#+11
   \   00000092   0xE011             B.N      ??USBDEP_EpHandler_9
    284                  }
    285                }
    286                else
    287                {
    288                  /* There is more data to transmit */
    289                  USBD_ArmEp( ep );
   \                     ??USBDEP_EpHandler_8: (+1)
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       USBD_ArmEp
    290                  ep->buf += *EPOUTBUFSIZE[ep->num];  // move buffer pointer
   \   0000009A   0x78A1             LDRB     R1,[R4, #+2]
   \   0000009C   0xF855 0x1021      LDR      R1,[R5, R1, LSL #+2]
   \   000000A0   0x68A0             LDR      R0,[R4, #+8]
   \   000000A2   0x6809             LDR      R1,[R1, #+0]
   \   000000A4   0x1808             ADDS     R0,R1,R0
   \   000000A6   0x60A0             STR      R0,[R4, #+8]
   \   000000A8   0xBD31             POP      {R0,R4,R5,PC}
    291                }
    292                
    293              }
    294              
    295              else
    296              {
    297                // Put ep back into idle state
    298                ep->state = D_EP_IDLE;
   \                     ??USBDEP_EpHandler_7: (+1)
   \   000000AA   0x.... 0x....      BL       ?Subroutine2
    299                // If there's a callback, call it
    300                if ( ep->xferCompleteCb )
   \                     ??CrossCallReturnLabel_5: (+1)
   \   000000AE   0x6A63             LDR      R3,[R4, #+36]
   \   000000B0   0x0018             MOVS     R0,R3
   \   000000B2   0xD006             BEQ.N    ??USBDEP_EpHandler_6
    301                {
    302                  callback = ep->xferCompleteCb;
    303                  ep->xferCompleteCb = NULL;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x6260             STR      R0,[R4, #+36]
    304                  callback( USB_STATUS_OK, ep->xferred, ep->remaining );
   \                     ??USBDEP_EpHandler_9: (+1)
   \   000000B8   0x6961             LDR      R1,[R4, #+20]
   \   000000BA   0xB001             ADD      SP,SP,#+4
   \   000000BC   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   000000C0   0x4718             BX       R3
    305                }
    306              }
    307            }
    308            else
    309            {
    310              // EpHandler should only be called if the endpoint is in use
    311              // ep->state set in read/write
    312              // assert( 0 );
    313            }
    314          }
   \                     ??USBDEP_EpHandler_6: (+1)
   \   000000C2   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40011054         DC32     0x40011054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     EPINBUF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     EPINBUFSIZE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40011008         DC32     0x40011008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     ??statusIn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     EPOUTBUFSIZE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     dev
    315          
    316          /** @endcond */
    317          
    318          #endif //CORTEXM3_EM35X_USB
    319          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USBDEP_Ep0Handler
        24   -- Indirect call
        24   -> USBDCH9_SetupCmd
         0   -> USBDHAL_ReenableEp0Setup
        24   -> USBDHAL_ReenableEp0Setup
        24   -> USBDHAL_StallEp
        24   -> USBDHAL_StartEp0Setup
         0   -> USBD_ReArmEp0
        24   -> USBD_Write
      16   USBDEP_EpHandler
         0   -- Indirect call
        16   -- Indirect call
         0   -> USBD_ArmEp
        16   -> USBD_ArmEp
         0   -> halInternalStartUartTx
       0   USBDHAL_ReenableEp0Setup
       0   USBDHAL_StallEp
       0   USBDHAL_StartEp0Setup
      16   USBD_ArmEp
         0   -> USBD_ArmEp0
        16   -> halCommonMemMove
      16   USBD_ArmEp0
        16   -> halCommonMemMove
       0   USBD_ReArmEp0
         0   -> USBD_ArmEp0


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       6  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
     324  USBDEP_Ep0Handler
     196  USBDEP_EpHandler
       2  USBDHAL_ReenableEp0Setup
      30  USBDHAL_StallEp
       8  USBDHAL_StartEp0Setup
      90  USBD_ArmEp
      52  USBD_ArmEp0
       2  USBD_ReArmEp0
      12  statusIn
          xferred
          callback

 
  12 bytes in section .bss
 754 bytes in section .text
 
 754 bytes of CODE memory
  12 bytes of DATA memory

Errors: none
Warnings: none
