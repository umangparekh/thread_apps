###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  13:29:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\SiliconLabs\Thread-1.0.1\app\util\serial\serial.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\serial.c -D APP_BTL -D
#        CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D PHY_EM3XX -D
#        "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"serial.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\serial.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\serial.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\app\util\serial\serial.c
      1          /**
      2           * File: serial.c
      3           * Description: High Level Serial Communications
      4           *
      5           * Culprit(s):  Lee Taylor (lee@ember.com)
      6           *              Richard Kelsey (kelsey@ember.com)
      7           *              Jeff Mathews (jeff@ember.com)
      8           *
      9           * Copyright 2004 by Ember Corporation.  All rights reserved.               *80*
     10           */
     11          
     12          #include PLATFORM_HEADER
     13          #include "stack/include/ember-types.h"
     14          #include "stack/include/error.h"
     15          #include "hal/hal.h"
     16          #include "serial.h"
     17          
     18          #include <stdarg.h>
     19          
     20          #if defined(EMBER_SERIAL_USE_STDIO)
     21            #include <stdio.h>
     22          #elif defined(EMBER_STACK_COBRA)
     23            #include "hal_types.h"
     24            #include "hal_board.h"
     25            #include "hal/micro/c8051/cobra/uart-cobra.h"
     26            #define EMBER_SERIAL_USE_STDIO
     27          #endif
     28          
     29          //Documentary comments:
     30          // To conserve precious flash, there is very little validity checking
     31          //  on the given parameters.  Be sure not to use an invalid port number
     32          //  or a port that is unused.
     33          // Blocking routines will always wait for room (but not buffers - if buffers
     34          //  cannot be allocated, no part of the message will be sent)
     35          // Non-blocking routines will never wait for room, and may cause partial
     36          //  messages to be sent.  If a contiguous message needs to be sent, available
     37          //  space should be checked _before_ calling the appropriate write API.
     38          
     39          
     40          //------------------------------------------------------
     41          // Determine if blocking code needs to be enabled
     42          #if defined(EMBER_SERIAL0_BLOCKING) || \
     43              defined(EMBER_SERIAL1_BLOCKING) || \
     44              defined(EMBER_SERIAL2_BLOCKING) || \
     45              defined(EMBER_SERIAL3_BLOCKING) || \
     46              defined(EMBER_SERIAL4_BLOCKING)
     47            #define EM_ENABLE_SERIAL_BLOCKING
     48          #endif
     49          #ifdef EMBER_SERIAL0_BLOCKING
     50            #define EM_SERIAL0_BLOCKSTATE true
     51          #else
     52            #define EM_SERIAL0_BLOCKSTATE false
     53          #endif
     54          #ifdef EMBER_SERIAL1_BLOCKING
     55            #define EM_SERIAL1_BLOCKSTATE true
     56          #else
     57            #define EM_SERIAL1_BLOCKSTATE false
     58          #endif
     59          #ifdef EMBER_SERIAL2_BLOCKING
     60            #define EM_SERIAL2_BLOCKSTATE true
     61          #else
     62            #define EM_SERIAL2_BLOCKSTATE false
     63          #endif
     64          #ifdef EMBER_SERIAL3_BLOCKING
     65            #define EM_SERIAL3_BLOCKSTATE true
     66          #else
     67            #define EM_SERIAL3_BLOCKSTATE false
     68          #endif
     69          #ifdef EMBER_SERIAL4_BLOCKING
     70            #define EM_SERIAL4_BLOCKSTATE true
     71          #else
     72            #define EM_SERIAL4_BLOCKSTATE false
     73          #endif
     74          
     75          #ifndef EMBER_SERIAL_USE_STDIO
     76          //------------------------------------------------------
     77          // Memory allocations for Queue data structures
     78          
     79          //Macros to define fifo and buffer queues, can't use a typedef becuase the size
     80          // of the fifo array in the queues can change
     81          #define DEFINE_FIFO_QUEUE(qSize, qName)             \
     82            static struct {                                   \
     83              /*! Indexes of next byte to send*/              \
     84              uint16_t head;                                     \
     85              /*! Index of where to enqueue next message*/    \
     86              uint16_t tail;                                     \
     87              /*! Number of bytes queued*/                    \
     88              volatile uint16_t used;                            \
     89              /*! FIFO of queue data*/                        \
     90              uint8_t fifo[qSize];                              \
     91            } qName;
     92          
     93          #define DEFINE_BUFFER_QUEUE(qSize, qName)           \
     94            static struct {                                   \
     95              /*! Indexes of next message to send*/           \
     96              uint8_t head;                                     \
     97              /*! Index of where to enqueue next message*/    \
     98              uint8_t tail;                                     \
     99              /*! Number of messages queued*/                 \
    100              volatile uint8_t used;                            \
    101              uint8_t dead;                                     \
    102              EmberMessageBuffer currentBuffer;               \
    103              uint8_t *nextByte, *lastByte;                     \
    104              /*! FIFO of messages*/                          \
    105              EmSerialBufferQueueEntry fifo[qSize];           \
    106            } qName;
    107          
    108          
    109          // Allocate Appropriate TX Queue for port 0
    110          #if EMBER_SERIAL0_MODE == EMBER_SERIAL_FIFO

   \                                 In section .bss, align 4
    111            DEFINE_FIFO_QUEUE(EMBER_SERIAL0_TX_QUEUE_SIZE,emSerial0TxQueue)
   \                     emSerial0TxQueue:
   \   00000000                      DS8 136
    112            #define EM_SERIAL0_TX_QUEUE_ADDR (&emSerial0TxQueue)
    113          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_BUFFER
    114            DEFINE_BUFFER_QUEUE(EMBER_SERIAL0_TX_QUEUE_SIZE,emSerial0TxQueue)
    115            #define EM_SERIAL0_TX_QUEUE_ADDR (&emSerial0TxQueue)
    116          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED || \
    117                EMBER_SERIAL0_MODE == EMBER_SERIAL_LOWLEVEL
    118            #define EM_SERIAL0_TX_QUEUE_ADDR (NULL)
    119            #define EMBER_SERIAL0_TX_QUEUE_SIZE 0
    120            #define EMBER_SERIAL0_RX_QUEUE_SIZE 0
    121          #endif
    122          
    123          // Allocate Appropriate TX Queue for port 1
    124          #if EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO

   \                                 In section .bss, align 4
    125            DEFINE_FIFO_QUEUE(EMBER_SERIAL1_TX_QUEUE_SIZE,emSerial1TxQueue)
   \                     emSerial1TxQueue:
   \   00000000                      DS8 136
    126            #define EM_SERIAL1_TX_QUEUE_ADDR (&emSerial1TxQueue)
    127          #elif EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER
    128            DEFINE_BUFFER_QUEUE(EMBER_SERIAL1_TX_QUEUE_SIZE,emSerial1TxQueue)
    129            #define EM_SERIAL1_TX_QUEUE_ADDR (&emSerial1TxQueue)
    130          #elif EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED || \
    131                EMBER_SERIAL1_MODE == EMBER_SERIAL_LOWLEVEL 
    132            #define EM_SERIAL1_TX_QUEUE_ADDR (NULL)
    133            #define EMBER_SERIAL1_TX_QUEUE_SIZE 0
    134            #define EMBER_SERIAL1_RX_QUEUE_SIZE 0
    135          #endif
    136          
    137          // Allocate Appropriate TX Queue for port 2
    138          #if EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO
    139            DEFINE_FIFO_QUEUE(EMBER_SERIAL2_TX_QUEUE_SIZE,emSerial2TxQueue)
    140            #define EM_SERIAL2_TX_QUEUE_ADDR (&emSerial2TxQueue)
    141          #elif EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER
    142            DEFINE_BUFFER_QUEUE(EMBER_SERIAL2_TX_QUEUE_SIZE,emSerial2TxQueue)
    143            #define EM_SERIAL2_TX_QUEUE_ADDR (&emSerial2TxQueue)
    144          #elif EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED || \
    145                EMBER_SERIAL2_MODE == EMBER_SERIAL_LOWLEVEL 
    146            #define EM_SERIAL2_TX_QUEUE_ADDR (NULL)
    147            #define EMBER_SERIAL2_TX_QUEUE_SIZE 0
    148            #define EMBER_SERIAL2_RX_QUEUE_SIZE 0
    149          #endif
    150          
    151          // Allocate Appropriate TX Queue for port 3
    152          #if EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO

   \                                 In section .bss, align 4
    153            DEFINE_FIFO_QUEUE(EMBER_SERIAL3_TX_QUEUE_SIZE,emSerial3TxQueue)
   \                     emSerial3TxQueue:
   \   00000000                      DS8 136
    154            #define EM_SERIAL3_TX_QUEUE_ADDR (&emSerial3TxQueue)
    155          #elif EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER
    156            DEFINE_BUFFER_QUEUE(EMBER_SERIAL3_TX_QUEUE_SIZE,emSerial3TxQueue)
    157            #define EM_SERIAL3_TX_QUEUE_ADDR (&emSerial3TxQueue)
    158          #elif EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED || \
    159                EMBER_SERIAL3_MODE == EMBER_SERIAL_LOWLEVEL 
    160            #define EM_SERIAL3_TX_QUEUE_ADDR (NULL)
    161            #define EMBER_SERIAL3_TX_QUEUE_SIZE 0
    162            #define EMBER_SERIAL3_RX_QUEUE_SIZE 0
    163          #endif
    164          
    165          // Allocate Appropriate TX Queue for port 4
    166          #if EMBER_SERIAL4_MODE == EMBER_SERIAL_FIFO
    167            DEFINE_FIFO_QUEUE(EMBER_SERIAL4_TX_QUEUE_SIZE,emSerial4TxQueue)
    168            #define EM_SERIAL4_TX_QUEUE_ADDR (&emSerial4TxQueue)
    169          #elif EMBER_SERIAL4_MODE == EMBER_SERIAL_BUFFER
    170            DEFINE_BUFFER_QUEUE(EMBER_SERIAL4_TX_QUEUE_SIZE,emSerial4TxQueue)
    171            #define EM_SERIAL4_TX_QUEUE_ADDR (&emSerial4TxQueue)
    172          #elif EMBER_SERIAL4_MODE == EMBER_SERIAL_UNUSED || \
    173                EMBER_SERIAL4_MODE == EMBER_SERIAL_LOWLEVEL 
    174            #define EM_SERIAL4_TX_QUEUE_ADDR (NULL)
    175            #define EMBER_SERIAL4_TX_QUEUE_SIZE 0
    176            #define EMBER_SERIAL4_RX_QUEUE_SIZE 0
    177          #endif
    178          
    179          // Allocate RX Queues (Always FIFOs)
    180          #if EMBER_SERIAL0_MODE != EMBER_SERIAL_UNUSED

   \                                 In section .bss, align 4
    181            DEFINE_FIFO_QUEUE(EMBER_SERIAL0_RX_QUEUE_SIZE,emSerial0RxQueue)
   \                     emSerial0RxQueue:
   \   00000000                      DS8 136
    182            #define EM_SERIAL0_RX_QUEUE_ADDR (&emSerial0RxQueue)
    183          #else
    184            #define EM_SERIAL0_RX_QUEUE_ADDR (NULL)
    185          #endif
    186          
    187          #if EMBER_SERIAL1_MODE != EMBER_SERIAL_UNUSED

   \                                 In section .bss, align 4
    188            DEFINE_FIFO_QUEUE(EMBER_SERIAL1_RX_QUEUE_SIZE,emSerial1RxQueue)
   \                     emSerial1RxQueue:
   \   00000000                      DS8 136
    189            #define EM_SERIAL1_RX_QUEUE_ADDR (&emSerial1RxQueue)
    190          #else
    191            #define EM_SERIAL1_RX_QUEUE_ADDR (NULL)
    192            #define emSerial1RxQueue (NULL)
    193          #endif
    194          
    195          #if EMBER_SERIAL2_MODE != EMBER_SERIAL_UNUSED
    196            DEFINE_FIFO_QUEUE(EMBER_SERIAL2_RX_QUEUE_SIZE,emSerial2RxQueue)
    197            #define EM_SERIAL2_RX_QUEUE_ADDR (&emSerial2RxQueue)
    198          #else
    199            #define EM_SERIAL2_RX_QUEUE_ADDR (NULL)
    200            #define emSerial2RxQueue (NULL)
    201          #endif
    202          
    203          #if EMBER_SERIAL3_MODE != EMBER_SERIAL_UNUSED

   \                                 In section .bss, align 4
    204            DEFINE_FIFO_QUEUE(EMBER_SERIAL3_RX_QUEUE_SIZE,emSerial3RxQueue)
   \                     emSerial3RxQueue:
   \   00000000                      DS8 136
    205            #define EM_SERIAL3_RX_QUEUE_ADDR (&emSerial3RxQueue)
    206          #else
    207            #define EM_SERIAL3_RX_QUEUE_ADDR (NULL)
    208            #define emSerial3RxQueue (NULL)
    209          #endif
    210          
    211          #if EMBER_SERIAL4_MODE != EMBER_SERIAL_UNUSED
    212            DEFINE_FIFO_QUEUE(EMBER_SERIAL4_RX_QUEUE_SIZE,emSerial4RxQueue)
    213            #define EM_SERIAL4_RX_QUEUE_ADDR (&emSerial4RxQueue)
    214          #else
    215            #define EM_SERIAL4_RX_QUEUE_ADDR (NULL)
    216            #define emSerial4RxQueue (NULL)
    217          #endif
    218          
    219          //------------------------------------------------------
    220          // Easy access to data structures for a particular port
    221          
    222          // The FOR_EACH_PORT(CAST,PREFIX_,_SUFFIX) macro will expand in to something like:
    223          //    CAST(PREFIX_0_SUFFIX),
    224          //    CAST(PREFIX_1_SUFFIX)
    225          // with a line & number for each port of EM_NUM_SERIAL_PORTS
    226          
    227          // Data structure for referencing TX Queues
    228          //  (allows for different modes and queue sizes)
    229          void *emSerialTxQueues[EM_NUM_SERIAL_PORTS] = 
    230            { FOR_EACH_PORT( (void *),EM_SERIAL,_TX_QUEUE_ADDR ) };
    231          

   \                                 In section .text, align 4, keep-with-next
    232          uint16_t PGM emSerialTxQueueSizes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueSizes:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 128
   \              0x0000 0x0080
    233            { FOR_EACH_PORT( (uint16_t),EMBER_SERIAL,_TX_QUEUE_SIZE ) };
    234          

   \                                 In section .rodata, align 4, keep-with-next
    235          uint16_t PGM emSerialTxQueueMasks[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueMasks:
   \   00000000   0x007F 0x007F      DC16 127, 127, 65535, 127
   \              0xFFFF 0x007F

   \                                 In section .data, align 4
   \                     emSerialTxQueues:
   \   00000000   0x........         DC32 emSerial0TxQueue, emSerial1TxQueue, 0H, emSerial3TxQueue
   \              0x........   
   \              0x00000000   
   \              0x........   
    236            { FOR_EACH_PORT( (uint16_t),EMBER_SERIAL,_TX_QUEUE_SIZE-1 ) };
    237          
    238          // Data structure for referencing RX Queues
    239          //  (allows for different queue sizes)
    240          EmSerialFifoQueue *emSerialRxQueues[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialRxQueues:
   \   00000010   0x........         DC32 emSerial0RxQueue, emSerial1RxQueue, 0H, emSerial3RxQueue
   \              0x........   
   \              0x00000000   
   \              0x........   
    241            { FOR_EACH_PORT( (EmSerialFifoQueue *),EM_SERIAL,_RX_QUEUE_ADDR ) };
    242          

   \                                 In section .rodata, align 4, keep-with-next
    243          uint16_t PGM emSerialRxQueueSizes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialRxQueueSizes:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 128
   \              0x0000 0x0080
    244            { FOR_EACH_PORT( (uint16_t),EMBER_SERIAL,_RX_QUEUE_SIZE ) };
    245          
    246          // In-flash data structure for determined port mode

   \                                 In section .text, align 4, keep-with-next
    247          uint8_t PGM emSerialPortModes[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialPortModes:
   \   00000000   0x01 0x01          DC8 1, 1, 0, 1
   \              0x00 0x01    
    248            { FOR_EACH_PORT( (uint8_t),EMBER_SERIAL,_MODE ) };
    249          
    250          //Compatibility code for the AVR Atmega
    251          //If an AVR Atmega is used, then emSerialTx(/Rx)QueueWraps map to
    252          //emSerialTx(/Rx)QueueMasks, otherwise they map to emSerialTx(/Rx)QueueSizes
    253          #ifdef AVR_ATMEGA
    254          uint8_t PGM emSerialTxQueueWraps[EM_NUM_SERIAL_PORTS] = 
    255            { FOR_EACH_PORT( (uint8_t), EMBER_SERIAL,_TX_QUEUE_SIZE-1 ) };
    256          uint8_t PGM emSerialRxQueueWraps[EM_NUM_SERIAL_PORTS] = 
    257            { FOR_EACH_PORT( (uint8_t), EMBER_SERIAL,_RX_QUEUE_SIZE-1 ) };
    258          #else

   \                                 In section .text, align 4, keep-with-next
    259          uint16_t PGM emSerialTxQueueWraps[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialTxQueueWraps:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 128
   \              0x0000 0x0080
    260            { FOR_EACH_PORT( (uint16_t), EMBER_SERIAL,_TX_QUEUE_SIZE ) };

   \                                 In section .text, align 4, keep-with-next
    261          uint16_t PGM emSerialRxQueueWraps[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialRxQueueWraps:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 128
   \              0x0000 0x0080
    262            { FOR_EACH_PORT( (uint16_t), EMBER_SERIAL,_RX_QUEUE_SIZE ) };
    263          #endif
    264          
    265          #ifdef EM_ENABLE_SERIAL_BLOCKING
    266          // In-flash data structure for blocking mode

   \                                 In section .text, align 4, keep-with-next
    267          bool PGM emSerialBlocking[EM_NUM_SERIAL_PORTS] =
   \                     emSerialBlocking:
   \   00000000   0x01 0x01          DC8 1, 1, 0, 1
   \              0x00 0x01    
    268            { FOR_EACH_PORT( (bool),EM_SERIAL,_BLOCKSTATE ) };
    269          #endif
    270          

   \                                 In section .bss, align 4
    271          uint8_t emSerialRxError[EM_NUM_SERIAL_PORTS] = {EMBER_SUCCESS,};
   \                     emSerialRxError:
   \   00000000                      DS8 4
    272          uint16_t emSerialRxErrorIndex[EM_NUM_SERIAL_PORTS] = {0,};
   \                     emSerialRxErrorIndex:
   \   00000004                      DS8 8
    273          #endif //EMBER_SERIAL_USE_STDIO
    274          
    275          //------------------------------------------------------
    276          // Buffered Serial utility APIs
    277          
    278          #ifdef EM_ENABLE_SERIAL_BUFFER
    279          // always executed in interrupt context
    280          void emSerialBufferNextMessageIsr(EmSerialBufferQueue *q) 
    281          {
    282            EmSerialBufferQueueEntry *e = &q->fifo[q->tail];
    283          
    284            q->currentBuffer = e->buffer;
    285            q->nextByte = emberLinkedBufferContents(q->currentBuffer) + e->startIndex;
    286            if((e->length + e->startIndex) > PACKET_BUFFER_SIZE) {
    287              q->lastByte = q->nextByte + ((PACKET_BUFFER_SIZE-1) - e->startIndex);
    288              e->length -= PACKET_BUFFER_SIZE - e->startIndex;
    289            } else {
    290              q->lastByte = q->nextByte + e->length - 1;
    291              e->length = 0;
    292            }
    293          }
    294          #endif
    295          
    296          #ifdef EM_ENABLE_SERIAL_BUFFER
    297          // always executed in interrupt context
    298          void emSerialBufferNextBlockIsr(EmSerialBufferQueue *q, uint8_t port)
    299          {
    300            EmSerialBufferQueueEntry *e = &q->fifo[q->tail];
    301            
    302            if(e->length != 0) {
    303              q->currentBuffer = emberStackBufferLink(q->currentBuffer);
    304              q->nextByte = emberLinkedBufferContents(q->currentBuffer);
    305              if(e->length > PACKET_BUFFER_SIZE) {
    306                q->lastByte = q->nextByte + 31;
    307                e->length -= PACKET_BUFFER_SIZE;
    308              } else {
    309                q->lastByte = q->nextByte + e->length - 1;
    310                e->length = 0;
    311              }
    312            } else {
    313              #ifdef AVR_ATMEGA
    314                //If we are using an AVR host, non power-of-2 queue sizes are NOT
    315                //supported and therefore we use a mask    
    316                q->tail = ((q->tail+1) & emSerialTxQueueMasks[port]);
    317              #else // AVR_ATMEGA
    318                //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
    319                //supported and therefore we use a mod with the queue size
    320                q->tail = ((q->tail+1) % emSerialTxQueueSizes[port]);
    321              #endif // !AVR_ATMEGA
    322              q->dead++;
    323              q->used--;
    324              if(q->used)
    325                emSerialBufferNextMessageIsr(q);
    326              else
    327                q->nextByte = NULL;
    328            }
    329          }
    330          #endif
    331          
    332          //------------------------------------------------------
    333          // Serial initialization
    334          

   \                                 In section .text, align 2, keep-with-next
    335          EmberStatus emberSerialInit(uint8_t port, 
    336                                      SerialBaudRate rate,
    337                                      SerialParity parity,
    338                                      uint8_t stopBits)
    339          {
   \                     emberSerialInit: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x469A             MOV      R10,R3
    340          #ifdef EMBER_SERIAL_USE_STDIO
    341            //When using stdio, bypass the serial library initialization
    342            //and just initialize the low level UART driver.
    343            return halInternalUartInit(port, rate, parity, stopBits);
    344          #else //EMBER_SERIAL_USE_STDIO
    345            EmSerialFifoQueue *rq;
    346          
    347            if (emberSerialUnused(port)) return EMBER_SERIAL_INVALID_PORT;
   \   0000000C   0x.... 0x....      BL       emberSerialUnused
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xBF01             ITTTT    EQ 
   \   00000014   0x4625             MOVEQ    R5,R4
   \   00000016   0x.... 0x....      ADREQ.W  R0,emSerialPortModes
   \   0000001A   0x5C28             LDRBEQ   R0,[R5, R0]
   \   0000001C   0x2801             CMPEQ    R0,#+1
    348          
    349            switch(emSerialPortModes[port]) {
   \   0000001E   0xD123             BNE.N    ??emberSerialInit_0
    350          #ifdef EM_ENABLE_SERIAL_FIFO
    351            case EMBER_SERIAL_FIFO: {
    352              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable18_1
   \   00000024   0xF856 0x7025      LDR      R7,[R6, R5, LSL #+2]
    353              ATOMIC_LITE(
    354                q->used = 0;
    355                q->head = 0;
    356                q->tail = 0;
    357              )
   \   00000028   0x.... 0x....      BL       _disableBasePri
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x80B9             STRH     R1,[R7, #+4]
   \   00000030   0x8039             STRH     R1,[R7, #+0]
   \   00000032   0x8079             STRH     R1,[R7, #+2]
   \   00000034   0x.... 0x....      BL       _writeBasePri
    358              break; }
    359          #endif
    360          #ifdef EM_ENABLE_SERIAL_BUFFER
    361            case EMBER_SERIAL_BUFFER: {
    362              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    363              ATOMIC_LITE(
    364                q->used = 0;
    365                q->head = 0;
    366                q->tail = 0;
    367                q->dead = 0;
    368                q->currentBuffer = EMBER_NULL_MESSAGE_BUFFER;
    369                q->nextByte = NULL;
    370                q->lastByte = NULL;
    371              )
    372              break; }
    373          #endif
    374            default:
    375              return EMBER_SERIAL_INVALID_PORT;
    376              //break;  //statement is unreachable
    377            }
    378          
    379            rq = emSerialRxQueues[port];
   \   00000038   0xEB06 0x0085      ADD      R0,R6,R5, LSL #+2
   \   0000003C   0x6906             LDR      R6,[R0, #+16]
    380            ATOMIC_LITE(
    381              rq->used = 0;
    382              rq->head = 0;
    383              rq->tail = 0;
    384              emSerialRxError[port] = EMBER_SUCCESS;
    385            )
   \   0000003E   0x.... 0x....      BL       _disableBasePri
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x80B1             STRH     R1,[R6, #+4]
   \   0000004A   0x8031             STRH     R1,[R6, #+0]
   \   0000004C   0x8071             STRH     R1,[R6, #+2]
   \   0000004E   0x54A9             STRB     R1,[R5, R2]
   \   00000050   0x.... 0x....      BL       _writeBasePri
    386          
    387            halInternalRestartUart();
   \   00000054   0x.... 0x....      BL       halInternalRestartUart
    388          
    389            return halInternalUartInit(port, rate, parity, stopBits);
   \   00000058   0x4653             MOV      R3,R10
   \   0000005A   0x464A             MOV      R2,R9
   \   0000005C   0x4641             MOV      R1,R8
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   00000064   0x.... 0x....      B.W      halInternalUartInit
   \                     ??emberSerialInit_0: (+1)
   \   00000068   0x2021             MOVS     R0,#+33
   \   0000006A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    390          #endif //EMBER_SERIAL_USE_STDIO
    391          }
    392          
    393          //------------------------------------------------------
    394          // Serial Input
    395          
    396          // returns # bytes available for reading

   \                                 In section .text, align 2, keep-with-next
    397          uint16_t emberSerialReadAvailable(uint8_t port)  
    398          {
   \                     emberSerialReadAvailable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    399          #ifdef EMBER_SERIAL_USE_STDIO
    400            return halInternalPrintfReadAvailable();
    401          #else //EMBER_SERIAL_USE_STDIO
    402            halInternalUartRxPump(port);
   \   00000004   0x.... 0x....      BL       halInternalUartRxPump
    403            return emSerialRxQueues[port]->used;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000000C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000010   0x6900             LDR      R0,[R0, #+16]
   \   00000012   0x8880             LDRH     R0,[R0, #+4]
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    404          #endif //EMBER_SERIAL_USE_STDIO
    405          }
    406          

   \                                 In section .text, align 2, keep-with-next
    407          EmberStatus emberSerialReadByte(uint8_t port, uint8_t *dataByte)
    408          {
   \                     emberSerialReadByte: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
    409          #ifdef EMBER_SERIAL_USE_STDIO
    410            int ch=-1;
    411            ch = getchar();
    412            if(ch<0) {
    413              return EMBER_SERIAL_RX_EMPTY;
    414            }
    415            *dataByte = (uint8_t)ch;
    416            return EMBER_SUCCESS;
    417          #else //EMBER_SERIAL_USE_STDIO
    418            uint8_t retval;
    419            EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000006   0x464C             MOV      R4,R9
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000000C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000010   0x4688             MOV      R8,R1
   \   00000012   0x6906             LDR      R6,[R0, #+16]
    420          
    421            if (emberSerialUnused(port)) {
   \   00000014   0x4648             MOV      R0,R9
   \   00000016   0x.... 0x....      BL       emberSerialUnused
   \   0000001A   0xB108             CBZ.N    R0,??emberSerialReadByte_0
    422              return EMBER_ERR_FATAL;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE037             B.N      ??emberSerialReadByte_1
    423            }
    424          
    425            if(emSerialRxError[port] != EMBER_SUCCESS) {
   \                     ??emberSerialReadByte_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R5,??DataTable18_2
   \   00000024   0x5D60             LDRB     R0,[R4, R5]
   \   00000026   0xEB05 0x0744      ADD      R7,R5,R4, LSL #+1
   \   0000002A   0xB160             CBZ.N    R0,??emberSerialReadByte_2
    426              if(emSerialRxErrorIndex[port] == q->tail) {
   \   0000002C   0x88B8             LDRH     R0,[R7, #+4]
   \   0000002E   0x8871             LDRH     R1,[R6, #+2]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD108             BNE.N    ??emberSerialReadByte_2
    427                ATOMIC_LITE(
    428                  retval = emSerialRxError[port];
    429                  emSerialRxError[port] = EMBER_SUCCESS;
    430                )
   \   00000034   0x.... 0x....      BL       _disableBasePri
   \   00000038   0x5D66             LDRB     R6,[R4, R5]
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x5561             STRB     R1,[R4, R5]
   \   0000003E   0x.... 0x....      BL       _writeBasePri
    431                return retval;
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0xE024             B.N      ??emberSerialReadByte_1
    432              }
    433            }
    434            
    435            halInternalUartRxPump(port);
   \                     ??emberSerialReadByte_2: (+1)
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x.... 0x....      BL       halInternalUartRxPump
    436            halInternalUartFlowControl(port);
    437            
    438            if(q->used > 0) {
   \   0000004C   0x88B0             LDRH     R0,[R6, #+4]
   \   0000004E   0xB1F0             CBZ.N    R0,??emberSerialReadByte_3
    439              ATOMIC_LITE(
    440                *dataByte = FIFO_DEQUEUE(q,emSerialRxQueueWraps[port]);
    441              )
   \   00000050   0x.... 0x....      BL       _disableBasePri
   \   00000054   0x8871             LDRH     R1,[R6, #+2]
   \   00000056   0x.... 0x....      ADR.W    R2,emSerialRxQueueWraps
   \   0000005A   0x1989             ADDS     R1,R1,R6
   \   0000005C   0x7989             LDRB     R1,[R1, #+6]
   \   0000005E   0xF888 0x1000      STRB     R1,[R8, #+0]
   \   00000062   0xF64F 0x78FF      MOVW     R8,#+65535
   \   00000066   0x8871             LDRH     R1,[R6, #+2]
   \   00000068   0xF832 0x2014      LDRH     R2,[R2, R4, LSL #+1]
   \   0000006C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000070   0x8071             STRH     R1,[R6, #+2]
   \   00000072   0x88B1             LDRH     R1,[R6, #+4]
   \   00000074   0x4441             ADD      R1,R8,R1
   \   00000076   0x80B1             STRH     R1,[R6, #+4]
   \   00000078   0x.... 0x....      BL       _writeBasePri
    442              if(emSerialRxError[port] != EMBER_SUCCESS) {
   \   0000007C   0x5D60             LDRB     R0,[R4, R5]
   \   0000007E   0xB120             CBZ.N    R0,??emberSerialReadByte_4
    443                //This index is used when there is an error when the FIFO is full.
    444                if(emSerialRxErrorIndex[port] == RX_FIFO_FULL) {
   \   00000080   0x88B8             LDRH     R0,[R7, #+4]
   \   00000082   0x4540             CMP      R0,R8
   \   00000084   0xBF04             ITT      EQ 
   \   00000086   0x8830             LDRHEQ   R0,[R6, #+0]
   \   00000088   0x80B8             STRHEQ   R0,[R7, #+4]
    445                  //q->tail has advanced by one, we can now mark the head as the error
    446                  emSerialRxErrorIndex[port] = q->head;
    447                }
    448              }
    449              return EMBER_SUCCESS;
   \                     ??emberSerialReadByte_4: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE000             B.N      ??emberSerialReadByte_1
    450            } else {
    451              return EMBER_SERIAL_RX_EMPTY;
   \                     ??emberSerialReadByte_3: (+1)
   \   0000008E   0x2026             MOVS     R0,#+38
   \                     ??emberSerialReadByte_1: (+1)
   \   00000090   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    452            }
    453          #endif //EMBER_SERIAL_USE_STDIO
    454          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x1C49             ADDS     R1,R1,#+1
   \   00000002   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   00000006   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   0000000A   0x4770             BX       LR
    455          

   \                                 In section .text, align 2, keep-with-next
    456          EmberStatus emberSerialReadData(uint8_t port,
    457                                          uint8_t *data,
    458                                          uint16_t length,
    459                                          uint16_t *bytesRead)
    460          {
   \                     emberSerialReadData: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
    461            uint16_t bytesReadInternal = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE001             B.N      ??emberSerialReadData_0
    462            EmberStatus status;
    463          
    464            while (bytesReadInternal < length) {
    465              status = emberSerialReadByte(port, data);
    466          
    467              switch (status) {
    468                case EMBER_SUCCESS:
    469                  ++data;
   \                     ??emberSerialReadData_1: (+1)
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
    470                  ++bytesReadInternal;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    471                  break;
   \                     ??emberSerialReadData_0: (+1)
   \   00000014   0xB2B6             UXTH     R6,R6
   \   00000016   0x4546             CMP      R6,R8
   \   00000018   0xD20A             BCS.N    ??emberSerialReadData_2
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSerialReadByte
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0xD0F4             BEQ.N    ??emberSerialReadData_1
   \   00000026   0x2826             CMP      R0,#+38
   \   00000028   0xD0F4             BEQ.N    ??emberSerialReadData_0
    472          
    473                case EMBER_SERIAL_RX_EMPTY:
    474                  // empty queue is not an error for us, we just want to keep waiting
    475                  break;
    476          
    477                default:
    478                  // only store number of bytes read if the caller provided a non-NULL pointer
    479                  if (bytesRead) {
   \   0000002A   0xB127             CBZ.N    R7,??emberSerialReadData_3
    480                    *bytesRead = bytesReadInternal;
   \   0000002C   0x803E             STRH     R6,[R7, #+0]
    481                  }
    482                  return status;
   \   0000002E   0xE002             B.N      ??emberSerialReadData_3
    483              }
    484            }
    485          
    486            // only store number of bytes read if the caller provided a non-NULL pointer
    487            if (bytesRead) {
   \                     ??emberSerialReadData_2: (+1)
   \   00000030   0xB107             CBZ.N    R7,??emberSerialReadData_4
    488              *bytesRead = bytesReadInternal;
   \   00000032   0x803E             STRH     R6,[R7, #+0]
    489            }
    490          
    491            return EMBER_SUCCESS;
   \                     ??emberSerialReadData_4: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??emberSerialReadData_3: (+1)
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    492          }
    493          
    494          #ifndef EMBER_TEST

   \                                 In section .text, align 2, keep-with-next
    495          EmberStatus emberSerialReadDataTimeout(uint8_t port,
    496                                                 uint8_t *data,
    497                                                 uint16_t length,
    498                                                 uint16_t *bytesRead,
    499                                                 uint16_t firstByteTimeout,
    500                                                 uint16_t subsequentByteTimeout)
    501          {
   \                     emberSerialReadDataTimeout: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    502            uint16_t bytesReadInternal = 0;
    503            EmberStatus status;
    504            uint16_t timeout = firstByteTimeout;
   \   00000004   0x9D0A             LDR      R5,[SP, #+40]
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4692             MOV      R10,R2
   \   0000000C   0x461E             MOV      R6,R3
   \   0000000E   0x2700             MOVS     R7,#+0
    505            uint16_t startTime = halCommonGetInt16uMillisecondTick();
   \   00000010   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000014   0x9C0B             LDR      R4,[SP, #+44]
   \   00000016   0x4683             MOV      R11,R0
   \   00000018   0xE006             B.N      ??emberSerialReadDataTimeout_0
    506          
    507            // loop until we read the max number of bytes or the timeout elapses
    508            while (bytesReadInternal < length
    509                   && halCommonGetInt16uMillisecondTick() - startTime < timeout) {
    510              status = emberSerialReadByte(port, data);
    511          
    512              switch (status) {
    513                case EMBER_SUCCESS:
    514                  ++data;
   \                     ??emberSerialReadDataTimeout_1: (+1)
   \   0000001A   0xF109 0x0901      ADD      R9,R9,#+1
    515                  ++bytesReadInternal;
   \   0000001E   0x1C7F             ADDS     R7,R7,#+1
    516                  // reset timer and timeout for next character
    517                  startTime = halCommonGetInt16uMillisecondTick();
   \   00000020   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000024   0x4683             MOV      R11,R0
    518                  timeout = subsequentByteTimeout;
   \   00000026   0x4625             MOV      R5,R4
    519                  break;
   \                     ??emberSerialReadDataTimeout_0: (+1)
   \   00000028   0xB2BF             UXTH     R7,R7
   \   0000002A   0x4557             CMP      R7,R10
   \   0000002C   0xD210             BCS.N    ??emberSerialReadDataTimeout_2
   \   0000002E   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000032   0xEBA0 0x000B      SUB      R0,R0,R11
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xDA0A             BGE.N    ??emberSerialReadDataTimeout_2
   \   0000003A   0x4649             MOV      R1,R9
   \   0000003C   0x4640             MOV      R0,R8
   \   0000003E   0x.... 0x....      BL       emberSerialReadByte
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0xD0E9             BEQ.N    ??emberSerialReadDataTimeout_1
   \   00000046   0x2826             CMP      R0,#+38
   \   00000048   0xD0EE             BEQ.N    ??emberSerialReadDataTimeout_0
    520          
    521                case EMBER_SERIAL_RX_EMPTY:
    522                  // empty queue is not an error for us, we just want to keep waiting
    523                  break;
    524          
    525                default:
    526                  // only store number of bytes read if the caller provided a non-NULL pointer
    527                  if (bytesRead) {
   \   0000004A   0xB13E             CBZ.N    R6,??emberSerialReadDataTimeout_3
    528                    *bytesRead = bytesReadInternal;
   \   0000004C   0x8037             STRH     R7,[R6, #+0]
    529                  }
    530                  return status;
   \   0000004E   0xE005             B.N      ??emberSerialReadDataTimeout_3
    531              }
    532            }
    533          
    534            // only store number of bytes read if the caller provided a non-NULL pointer
    535            if (bytesRead) {
   \                     ??emberSerialReadDataTimeout_2: (+1)
   \   00000050   0xB106             CBZ.N    R6,??emberSerialReadDataTimeout_4
    536              *bytesRead = bytesReadInternal;
   \   00000052   0x8037             STRH     R7,[R6, #+0]
    537            }
    538          
    539            return bytesReadInternal == length ? EMBER_SUCCESS : EMBER_SERIAL_RX_EMPTY;
   \                     ??emberSerialReadDataTimeout_4: (+1)
   \   00000054   0x4557             CMP      R7,R10
   \   00000056   0xBF0C             ITE      EQ 
   \   00000058   0x2000             MOVEQ    R0,#+0
   \   0000005A   0x2026             MOVNE    R0,#+38
   \                     ??emberSerialReadDataTimeout_3: (+1)
   \   0000005C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    540          }
    541          #endif // EMBER_TEST
    542          

   \                                 In section .text, align 2, keep-with-next
    543          EmberStatus emberSerialReadPartialLine(uint8_t port, char *data, uint8_t max, uint8_t * index)
    544          {
   \                     emberSerialReadPartialLine: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x461F             MOV      R7,R3
   \   00000004   0x4604             MOV      R4,R0
    545            EmberStatus err;
    546            uint8_t ch;
    547          
    548            if (((*index) == 0) || ((*index) >= max))
   \   00000006   0x7838             LDRB     R0,[R7, #+0]
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0xB108             CBZ.N    R0,??emberSerialReadPartialLine_0
   \   0000000E   0x42B0             CMP      R0,R6
   \   00000010   0xD308             BCC.N    ??emberSerialReadPartialLine_1
    549              data[0] = '\0';
   \                     ??emberSerialReadPartialLine_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7028             STRB     R0,[R5, #+0]
   \   00000016   0xE005             B.N      ??emberSerialReadPartialLine_1
    550          
    551            for (;;) {   
    552              err = emberSerialReadByte(port, &ch);
    553          
    554              // no new serial port char?, keep looping
    555              if (err) return err;
    556          
    557              // handle bogus characters
    558              if ( ch > 0x7F ) continue;
    559          
    560              // handle leading newline - fogBUGZ # 584
    561              if (((*index) == 0) &&
    562                  ((ch == '\n') || (ch == 0))) continue;
    563          
    564              // Drop the CR, or NULL that is part of EOL sequence.
    565              if ((*index) >= max) {
    566                *index = 0;
    567                if ((ch == '\r') || (ch == 0)) continue;
    568              }
    569          
    570              // handle backspace
    571              if ( ch == 0x8 ) {
    572                if ( (*index) > 0 ) {
    573                  // delete the last character from our string
    574                  (*index)--;
    575                  data[*index] = '\0';
    576                  // echo backspace
    577                  emberSerialWriteString(port, "\b \b");
    578                }
    579                // don't add or process this character
    580                continue;
    581              }
    582          
    583              //if the string is about to overflow, fake in a CR
    584              if ( (*index) + 2 > max ) {
    585                ch = '\r';
    586              }
    587          
    588              emberSerialWriteByte(port, ch); // term char echo
    589          
    590              //upcase that char
    591              if ( ch>='a' && ch<='z') ch = ch - ('a'-'A');
    592          
    593              // build a string until we press enter
    594              if ( ( ch == '\r' ) || ( ch == '\n' ) ) {
    595                data[*index] = '\0';
    596          
    597                if (ch == '\r') {
    598                  emberSerialWriteByte(port, '\n'); // "append" LF
    599                  *index = 0;                       // Reset for next line; \n next
    600                } else {
    601                  emberSerialWriteByte(port, '\r'); // "append" CR
    602                  *index = max;                     // Reset for next line; \r,\0 next
    603                }
    604          
    605                return EMBER_SUCCESS;
    606              } 
    607                
    608              data[(*index)++] = ch;
   \                     ??emberSerialReadPartialLine_2: (+1)
   \   00000018   0x7838             LDRB     R0,[R7, #+0]
   \   0000001A   0x1C41             ADDS     R1,R0,#+1
   \   0000001C   0x7039             STRB     R1,[R7, #+0]
   \   0000001E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000022   0x5541             STRB     R1,[R0, R5]
   \                     ??emberSerialReadPartialLine_1: (+1)
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       emberSerialReadByte
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD152             BNE.N    ??emberSerialReadPartialLine_3
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x2880             CMP      R0,#+128
   \   00000036   0xDAF5             BGE.N    ??emberSerialReadPartialLine_1
   \   00000038   0x7839             LDRB     R1,[R7, #+0]
   \   0000003A   0xB919             CBNZ.N   R1,??emberSerialReadPartialLine_4
   \   0000003C   0x280A             CMP      R0,#+10
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x2800             CMPNE    R0,#+0
   \   00000042   0xD0EF             BEQ.N    ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_4: (+1)
   \   00000044   0x42B1             CMP      R1,R6
   \   00000046   0xD307             BCC.N    ??emberSerialReadPartialLine_5
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7038             STRB     R0,[R7, #+0]
   \   0000004C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000050   0x280D             CMP      R0,#+13
   \   00000052   0xBF18             IT       NE 
   \   00000054   0x2800             CMPNE    R0,#+0
   \   00000056   0xD0E5             BEQ.N    ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_5: (+1)
   \   00000058   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000005C   0x7838             LDRB     R0,[R7, #+0]
   \   0000005E   0x2908             CMP      R1,#+8
   \   00000060   0xD10B             BNE.N    ??emberSerialReadPartialLine_6
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD0DE             BEQ.N    ??emberSerialReadPartialLine_1
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \   00000068   0x7038             STRB     R0,[R7, #+0]
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xB2C0             UXTB     R0,R0
   \   0000006E   0x5541             STRB     R1,[R0, R5]
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x....             ADR.N    R1,??DataTable18  ;; "\b \b"
   \   00000074   0x.... 0x....      BL       emberSerialWriteString
   \   00000078   0xE7D4             B.N      ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_6: (+1)
   \   0000007A   0x1C80             ADDS     R0,R0,#+2
   \   0000007C   0x4286             CMP      R6,R0
   \   0000007E   0xBFBC             ITT      LT 
   \   00000080   0x200D             MOVLT    R0,#+13
   \   00000082   0xF88D 0x0000      STRBLT   R0,[SP, #+0]
   \   00000086   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       emberSerialWriteByte
   \   00000090   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000094   0x3861             SUBS     R0,R0,#+97
   \   00000096   0x281A             CMP      R0,#+26
   \   00000098   0xD204             BCS.N    ??emberSerialReadPartialLine_7
   \   0000009A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009E   0x3820             SUBS     R0,R0,#+32
   \   000000A0   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??emberSerialReadPartialLine_7: (+1)
   \   000000A4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A8   0x280D             CMP      R0,#+13
   \   000000AA   0xBF18             IT       NE 
   \   000000AC   0x280A             CMPNE    R0,#+10
   \   000000AE   0xD1B3             BNE.N    ??emberSerialReadPartialLine_2
   \   000000B0   0x7839             LDRB     R1,[R7, #+0]
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x5548             STRB     R0,[R1, R5]
   \   000000B6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000BA   0x280D             CMP      R0,#+13
   \   000000BC   0xD105             BNE.N    ??emberSerialReadPartialLine_8
   \   000000BE   0x210A             MOVS     R1,#+10
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       emberSerialWriteByte
   \   000000C6   0x2600             MOVS     R6,#+0
   \   000000C8   0xE003             B.N      ??emberSerialReadPartialLine_9
   \                     ??emberSerialReadPartialLine_8: (+1)
   \   000000CA   0x210D             MOVS     R1,#+13
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       emberSerialWriteByte
   \                     ??emberSerialReadPartialLine_9: (+1)
   \   000000D2   0x703E             STRB     R6,[R7, #+0]
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??emberSerialReadPartialLine_3: (+1)
   \   000000D6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    609            }
    610          }
    611          

   \                                 In section .text, align 2, keep-with-next
    612          EmberStatus emberSerialReadLine(uint8_t port, char *data, uint8_t max)
    613          {
   \                     emberSerialReadLine: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    614            uint8_t index=0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0xE001             B.N      ??emberSerialReadLine_0
    615          
    616            while(emberSerialReadPartialLine(port, data, max, &index) != EMBER_SUCCESS) {
    617              halResetWatchdog();
   \                     ??emberSerialReadLine_1: (+1)
   \   00000012   0x.... 0x....      BL       halInternalResetWatchDog
    618            }
   \                     ??emberSerialReadLine_0: (+1)
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x4632             MOV      R2,R6
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSerialReadPartialLine
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F5             BNE.N    ??emberSerialReadLine_1
    619            return EMBER_SUCCESS;
   \   00000026   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    620          }
    621          
    622          //------------------------------------------------------
    623          // Serial Output
    624          
    625          // returns # bytes (if fifo mode)/messages (if buffer mode) that can be written

   \                                 In section .text, align 2, keep-with-next
    626          uint16_t emberSerialWriteAvailable(uint8_t port)  
    627          {
    628          #ifdef EMBER_SERIAL_USE_STDIO
    629            return halInternalPrintfWriteAvailable();
    630          #else //EMBER_SERIAL_USE_STDIO
    631            switch(emSerialPortModes[port]) {
   \                     emberSerialWriteAvailable: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   00000004   0x5C41             LDRB     R1,[R0, R1]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD10A             BNE.N    ??emberSerialWriteAvailable_0
    632          #ifdef EM_ENABLE_SERIAL_FIFO
    633            case EMBER_SERIAL_FIFO:
    634              return emSerialTxQueueSizes[port] - 
    635                ((EmSerialFifoQueue*)emSerialTxQueues[port])->used;
   \   0000000A   0x.... 0x....      ADR.W    R1,emSerialTxQueueSizes
   \   0000000E   0x....             LDR.N    R2,??DataTable18_1
   \   00000010   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   00000014   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000018   0x8880             LDRH     R0,[R0, #+4]
   \   0000001A   0x1A08             SUBS     R0,R1,R0
   \   0000001C   0xB280             UXTH     R0,R0
   \   0000001E   0x4770             BX       LR
    636          #endif
    637          #ifdef EM_ENABLE_SERIAL_BUFFER
    638            case EMBER_SERIAL_BUFFER: {
    639              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    640              uint8_t elementsUsed;
    641              uint8_t elementsDead; 
    642              ATOMIC_LITE( // To clarify the volatile access.
    643                     elementsUsed = q->used;
    644                     elementsDead = q->dead;
    645                     )
    646              return emSerialTxQueueSizes[port] - (elementsUsed + elementsDead);
    647              }
    648          #endif
    649            default: {
    650            }
    651            }
    652            return 0;
   \                     ??emberSerialWriteAvailable_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    653          #endif //EMBER_SERIAL_USE_STDIO
    654          }
    655          
    656          #ifndef EMBER_SERIAL_USE_STDIO
    657          #ifdef EM_ENABLE_SERIAL_FIFO

   \                                 In section .text, align 2, keep-with-next
    658          static bool getOutputFifoSpace(EmSerialFifoQueue *q,
    659                                            uint8_t port,
    660                                            uint16_t extraByteCount)
    661          {
    662            return (q->used < emSerialTxQueueSizes[port] - extraByteCount);
   \                     getOutputFifoSpace: (+1)
   \   00000000   0x8880             LDRH     R0,[R0, #+4]
   \   00000002   0x.... 0x....      ADR.W    R3,emSerialTxQueueSizes
   \   00000006   0xF833 0x1011      LDRH     R1,[R3, R1, LSL #+1]
   \   0000000A   0x1A89             SUBS     R1,R1,R2
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xDA01             BGE.N    ??getOutputFifoSpace_0
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   \                     ??getOutputFifoSpace_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    663          }
    664          #endif
    665          #endif //EMBER_SERIAL_USE_STDIO
    666          

   \                                 In section .text, align 2, keep-with-next
    667          EmberStatus emberSerialWriteString(uint8_t port, PGM_P string)
    668          {
   \                     emberSerialWriteString: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4682             MOV      R10,R0
    669          #ifdef EMBER_SERIAL_USE_STDIO
    670            while(*string != '\0') {
    671              putchar(*string);
    672              string++;
    673            }
    674            return EMBER_SUCCESS;
    675          #else //EMBER_SERIAL_USE_STDIO
    676            switch(emSerialPortModes[port]) {
   \   00000006   0x4656             MOV      R6,R10
   \   00000008   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000000C   0x5C30             LDRB     R0,[R6, R0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0x460D             MOV      R5,R1
   \   00000012   0xD136             BNE.N    ??emberSerialWriteString_0
    677          #ifdef EM_ENABLE_SERIAL_FIFO
    678            case EMBER_SERIAL_FIFO:
    679              {
    680                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000014   0x....             LDR.N    R0,??DataTable18_1
    681                bool kickStartTx = false;
   \   00000016   0x.... 0x....      ADR.W    R8,emSerialBlocking
   \   0000001A   0xF850 0x7026      LDR      R7,[R0, R6, LSL #+2]
   \   0000001E   0x.... 0x....      ADR.W    R9,emSerialTxQueueWraps
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0xE014             B.N      ??emberSerialWriteString_1
    682          
    683                while(*string != '\0') {
    684                  while (! getOutputFifoSpace(q, port, 0)) {
    685                    if (kickStartTx) {
    686                      halInternalStartUartTx(port);
    687                      kickStartTx = false;
    688                    }
    689                    #ifdef EM_ENABLE_SERIAL_BLOCKING
    690                      if (emSerialBlocking[port]) {
    691                        simulatedSerialTimePasses();
    692                        // Pet the watchdog here?
    693                        continue;
    694                      }
    695                    #endif
    696                    return EMBER_SERIAL_TX_OVERFLOW;
    697                  }
    698                  ATOMIC_LITE(
    699                    if (q->used == 0) {
    700                      kickStartTx = true;
    701                    }
    702                    FIFO_ENQUEUE(q,*string,emSerialTxQueueWraps[port]);
    703                  )
   \                     ??emberSerialWriteString_2: (+1)
   \   00000026   0x.... 0x....      BL       _disableBasePri
   \   0000002A   0x88B9             LDRH     R1,[R7, #+4]
   \   0000002C   0xB901             CBNZ.N   R1,??emberSerialWriteString_3
   \   0000002E   0x2401             MOVS     R4,#+1
   \                     ??emberSerialWriteString_3: (+1)
   \   00000030   0x883A             LDRH     R2,[R7, #+0]
   \   00000032   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   00000036   0x19D2             ADDS     R2,R2,R7
   \   00000038   0x7191             STRB     R1,[R2, #+6]
   \   0000003A   0x8839             LDRH     R1,[R7, #+0]
   \   0000003C   0xF839 0x2016      LDRH     R2,[R9, R6, LSL #+1]
   \   00000040   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000044   0x8039             STRH     R1,[R7, #+0]
   \   00000046   0x88B9             LDRH     R1,[R7, #+4]
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0x80B9             STRH     R1,[R7, #+4]
   \   0000004C   0x.... 0x....      BL       _writeBasePri
    704                  string++;
   \                     ??emberSerialWriteString_1: (+1)
   \   00000050   0x7828             LDRB     R0,[R5, #+0]
   \   00000052   0xB188             CBZ.N    R0,??emberSerialWriteString_4
   \                     ??emberSerialWriteString_5: (+1)
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x4651             MOV      R1,R10
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0x.... 0x....      BL       getOutputFifoSpace
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD1E1             BNE.N    ??emberSerialWriteString_2
   \   00000062   0xB11C             CBZ.N    R4,??emberSerialWriteString_6
   \   00000064   0x4650             MOV      R0,R10
   \   00000066   0x.... 0x....      BL       halInternalStartUartTx
   \   0000006A   0x2400             MOVS     R4,#+0
   \                     ??emberSerialWriteString_6: (+1)
   \   0000006C   0xF816 0x0008      LDRB     R0,[R6, R8]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD1EF             BNE.N    ??emberSerialWriteString_5
   \   00000074   0x2022             MOVS     R0,#+34
   \   00000076   0xE005             B.N      ??emberSerialWriteString_7
    705                }
    706                // make sure the interrupt is enabled so it will be sent
    707                halInternalStartUartTx(port);
   \                     ??emberSerialWriteString_4: (+1)
   \   00000078   0x4650             MOV      R0,R10
   \   0000007A   0x.... 0x....      BL       halInternalStartUartTx
    708                return EMBER_SUCCESS;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??emberSerialWriteString_7
    709              }
    710          #endif
    711          #ifdef EM_ENABLE_SERIAL_BUFFER
    712            case EMBER_SERIAL_BUFFER:
    713              {
    714                EmberMessageBuffer buff = emberAllocateStackBuffer();
    715                if(buff != EMBER_NULL_MESSAGE_BUFFER) {
    716                  EmberStatus stat;
    717                  if((stat=emberAppendPgmStringToLinkedBuffers(buff, string)) 
    718                     == EMBER_SUCCESS) {
    719                    stat = emberSerialWriteBuffer(port, buff, 0, emberMessageBufferLength(buff));
    720                  }
    721                  // Refcounts may be manipulated in ISR if DMA used
    722                  ATOMIC( emberReleaseMessageBuffer(buff); )
    723                  return stat;
    724                }
    725                return EMBER_NO_BUFFERS;
    726              }
    727          #endif
    728            default:
    729              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteString_0: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteString_7: (+1)
   \   00000084   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    730            }
    731          #endif //EMBER_SERIAL_USE_STDIO
    732          }
    733          

   \                                 In section .text, align 2, keep-with-next
    734          EmberStatus emberSerialPrintfVarArg(uint8_t port, PGM_P formatString, va_list ap)
    735          {
   \                     emberSerialPrintfVarArg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    736             EmberStatus stat = EMBER_SUCCESS;
    737             
    738          #ifdef EMBER_SERIAL_USE_STDIO
    739            if(!emPrintfInternal(emberSerialWriteData, port, formatString, ap)) {
    740              stat = EMBER_ERR_FATAL;
    741            }
    742          #else //EMBER_SERIAL_USE_STDIO
    743            
    744            switch(emSerialPortModes[port]) {
   \   00000002   0x.... 0x....      ADR.W    R3,emSerialPortModes
   \   00000006   0x5CC3             LDRB     R3,[R0, R3]
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD108             BNE.N    ??emberSerialPrintfVarArg_0
    745          #ifdef EM_ENABLE_SERIAL_FIFO
    746            case EMBER_SERIAL_FIFO: {
    747              if(!emPrintfInternal(emberSerialWriteData, port, formatString, ap))
   \   0000000E   0x4613             MOV      R3,R2
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x.... 0x....      ADR.W    R0,emberSerialWriteData
   \   00000018   0x.... 0x....      BL       emPrintfInternal
   \   0000001C   0xB900             CBNZ.N   R0,??emberSerialPrintfVarArg_0
    748                stat = EMBER_ERR_FATAL;
   \   0000001E   0x2401             MOVS     R4,#+1
    749              break;
    750            }
    751          #endif
    752          #ifdef EM_ENABLE_SERIAL_BUFFER
    753            case EMBER_SERIAL_BUFFER: {
    754              EmberMessageBuffer buff = emberAllocateStackBuffer();
    755              if(buff == EMBER_NULL_MESSAGE_BUFFER) {
    756                stat = EMBER_NO_BUFFERS;
    757                break;
    758              }
    759              if(emPrintfInternal(emberAppendToLinkedBuffers,
    760                                  buff,
    761                                  formatString,
    762                                  ap)) {
    763                stat = emberSerialWriteBuffer(port,buff,0,emberMessageBufferLength(buff));
    764              } else {
    765                stat = EMBER_NO_BUFFERS;
    766              }
    767              // Refcounts may be manipulated in ISR if DMA used
    768              ATOMIC( emberReleaseMessageBuffer(buff); )
    769          
    770              break;
    771            }
    772          #endif
    773            default: {
    774            }
    775            } //close switch.
    776          #endif //EMBER_SERIAL_USE_STDIO
    777            return stat;
   \                     ??emberSerialPrintfVarArg_0: (+1)
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    778          }
    779          

   \                                 In section .text, align 4, keep-with-next
    780          EmberStatus emberSerialWriteData(uint8_t port, uint8_t *data, uint8_t length)
    781          {
   \                     emberSerialWriteData: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
    782            assert(port < EM_NUM_SERIAL_PORTS);
   \   00000006   0x4647             MOV      R7,R8
   \   00000008   0x2F04             CMP      R7,#+4
   \   0000000A   0x468B             MOV      R11,R1
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0xDB05             BLT.N    ??emberSerialWriteData_0
   \   00000010   0xF240 0x310E      MOVW     R1,#+782
   \   00000014   0x.... 0x....      ADR.W    R0,?_1
   \   00000018   0x.... 0x....      BL       halInternalAssertFailed
    783          #ifdef EMBER_SERIAL_USE_STDIO
    784            while(length--) {
    785              uint8_t c = *data++;
    786              while (putchar(c) != c) {/*empty*/};  // retry until success
    787            }
    788            return EMBER_SUCCESS;
    789          #else //EMBER_SERIAL_USE_STDIO
    790            switch(emSerialPortModes[port]) {
   \                     ??emberSerialWriteData_0: (+1)
   \   0000001C   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   00000020   0x5C38             LDRB     R0,[R7, R0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD138             BNE.N    ??emberSerialWriteData_1
    791          #ifdef EM_ENABLE_SERIAL_FIFO
    792            case EMBER_SERIAL_FIFO:
    793              {
    794                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000026   0x....             LDR.N    R0,??DataTable18_1
    795                bool kickStartTx = false;
   \   00000028   0x.... 0x....      ADR.W    R9,emSerialBlocking
   \   0000002C   0xF850 0x4027      LDR      R4,[R0, R7, LSL #+2]
   \   00000030   0x.... 0x....      ADR.W    R10,emSerialTxQueueWraps
   \   00000034   0x2500             MOVS     R5,#+0
   \   00000036   0xE014             B.N      ??emberSerialWriteData_2
    796          
    797                while(length--) {
    798                  while (! getOutputFifoSpace(q, port, 0)) {
    799                    if (kickStartTx) {
    800                      halInternalStartUartTx(port);
    801                      kickStartTx = false;
    802                    }
    803                    #ifdef EM_ENABLE_SERIAL_BLOCKING
    804                      if (emSerialBlocking[port]) {
    805                        simulatedSerialTimePasses();
    806                        // Pet the watchdog here?
    807                        continue;
    808                      }
    809                    #endif
    810                    return EMBER_SERIAL_TX_OVERFLOW;
    811                  }
    812                  ATOMIC_LITE(
    813                    if (q->used == 0) {
    814                      kickStartTx = true;
    815                    }
    816                    FIFO_ENQUEUE(q,*data,emSerialTxQueueWraps[port]);
    817                  )
   \                     ??emberSerialWriteData_3: (+1)
   \   00000038   0x.... 0x....      BL       _disableBasePri
   \   0000003C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000003E   0xB901             CBNZ.N   R1,??emberSerialWriteData_4
   \   00000040   0x2501             MOVS     R5,#+1
   \                     ??emberSerialWriteData_4: (+1)
   \   00000042   0x8822             LDRH     R2,[R4, #+0]
   \   00000044   0xF81B 0x1B01      LDRB     R1,[R11], #+1
   \   00000048   0x1912             ADDS     R2,R2,R4
   \   0000004A   0x7191             STRB     R1,[R2, #+6]
   \   0000004C   0x8821             LDRH     R1,[R4, #+0]
   \   0000004E   0xF83A 0x2017      LDRH     R2,[R10, R7, LSL #+1]
   \   00000052   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000056   0x8021             STRH     R1,[R4, #+0]
   \   00000058   0x88A1             LDRH     R1,[R4, #+4]
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \   0000005C   0x80A1             STRH     R1,[R4, #+4]
   \   0000005E   0x.... 0x....      BL       _writeBasePri
    818                  data++;
   \                     ??emberSerialWriteData_2: (+1)
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x1E46             SUBS     R6,R0,#+1
   \   00000066   0xB2C0             UXTB     R0,R0
   \   00000068   0xB188             CBZ.N    R0,??emberSerialWriteData_5
   \                     ??emberSerialWriteData_6: (+1)
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x4641             MOV      R1,R8
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       getOutputFifoSpace
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD1DF             BNE.N    ??emberSerialWriteData_3
   \   00000078   0xB11D             CBZ.N    R5,??emberSerialWriteData_7
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x.... 0x....      BL       halInternalStartUartTx
   \   00000080   0x2500             MOVS     R5,#+0
   \                     ??emberSerialWriteData_7: (+1)
   \   00000082   0xF817 0x0009      LDRB     R0,[R7, R9]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD1EF             BNE.N    ??emberSerialWriteData_6
   \   0000008A   0x2022             MOVS     R0,#+34
   \   0000008C   0xE005             B.N      ??emberSerialWriteData_8
    819                }
    820                // make sure the interrupt is enabled so it will be sent
    821                halInternalStartUartTx(port);
   \                     ??emberSerialWriteData_5: (+1)
   \   0000008E   0x4640             MOV      R0,R8
   \   00000090   0x.... 0x....      BL       halInternalStartUartTx
    822                return EMBER_SUCCESS;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE000             B.N      ??emberSerialWriteData_8
    823              }
    824          #endif
    825          #ifdef EM_ENABLE_SERIAL_BUFFER
    826            case EMBER_SERIAL_BUFFER:
    827              {
    828                // Note: We must always copy this, even in buffer mode
    829                //  since it is ram based data and there are no reference counts
    830                //  or indication of when it is actually written out the serial
    831                //  we cannot trust that the data won't be changed after this call
    832                //  but before it was actually written out.
    833                EmberMessageBuffer buff = emberFillLinkedBuffers(data,length);
    834                if(buff != EMBER_NULL_MESSAGE_BUFFER) {
    835                  EmberStatus stat = emberSerialWriteBuffer(port, buff, 0, emberMessageBufferLength(buff));
    836                  // Refcounts may be manipulated in ISR if DMA used
    837                  ATOMIC( emberReleaseMessageBuffer(buff); )
    838                  return stat;
    839                } else 
    840                  return EMBER_NO_BUFFERS;
    841              }
    842          #endif
    843            default:
    844              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteData_1: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteData_8: (+1)
   \   0000009A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    845            }
    846          #endif //EMBER_SERIAL_USE_STDIO
    847          }
    848          
    849          #ifdef EM_ENABLE_SERIAL_BUFFER // TODO: Update to new buffers.
    850          EmberStatus emberSerialWriteBuffer(uint8_t port, 
    851                                             EmberMessageBuffer buffer, 
    852                                             uint8_t start, 
    853                                             uint8_t length)
    854          {
    855          //Host processors do not use Ember Message Buffers.
    856          #if defined(EZSP_HOST) || defined(EMBER_SERIAL_USE_STDIO)
    857            return EMBER_ERR_FATAL;  //This function is invalid.
    858          #else// !EZSP_HOST && !EMBER_SERIAL_USE_STDIO
    859          
    860            if(buffer == EMBER_NULL_MESSAGE_BUFFER)
    861              return EMBER_ERR_FATAL;
    862            if(length == 0)
    863              return EMBER_SUCCESS;
    864          
    865            switch(emSerialPortModes[port]) {
    866          #ifdef   EM_ENABLE_SERIAL_FIFO
    867            case EMBER_SERIAL_FIFO:
    868              {
    869                for(;PACKET_BUFFER_SIZE <= start; start-=PACKET_BUFFER_SIZE)
    870                  buffer = emberStackBufferLink(buffer);
    871                
    872                while (0 < length) {
    873                  uint8_t remainingInBuffer = PACKET_BUFFER_SIZE - start;
    874                  uint8_t bytes = (length < remainingInBuffer
    875                                 ? length
    876                                 : remainingInBuffer);
    877                  emberSerialWriteData(port,
    878                                       emberMessageBufferContents(buffer) + start,
    879                                       bytes);
    880                  length -= bytes;
    881                  start = 0;
    882                  buffer = emberStackBufferLink(buffer);
    883                }
    884                // make sure the interrupt is enabled so it will be sent
    885                halInternalStartUartTx(port);
    886                break;
    887              }
    888          #endif// EM_ENABLE_SERIAL_FIFO
    889          #ifdef   EM_ENABLE_SERIAL_BUFFER
    890            case EMBER_SERIAL_BUFFER:
    891              {
    892                EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    893                EmSerialBufferQueueEntry *e;
    894                uint8_t elementsUsed;
    895                uint8_t elementsDead;
    896          
    897                ATOMIC_LITE( // To clarify volatile access.
    898                       elementsUsed = q->used;
    899                       elementsDead = q->dead;
    900                       )
    901                
    902                #ifdef   EM_ENABLE_SERIAL_BLOCKING
    903                if(emSerialBlocking[port]) {
    904                  while((elementsUsed + elementsDead) >= emSerialTxQueueSizes[port]) {
    905                    emberSerialBufferTick();
    906                    //re-read the element counters after clocking the serial buffers
    907                    ATOMIC_LITE( // To clarify volatile access.
    908                          elementsUsed = q->used;
    909                          elementsDead = q->dead;
    910                          )
    911                  }
    912                } else
    913                #endif// EM_ENABLE_SERIAL_BLOCKING
    914                if((elementsUsed + elementsDead) >= emSerialTxQueueSizes[port]) {
    915                  if(elementsDead)
    916                    emberSerialBufferTick();
    917                  else
    918                    return EMBER_SERIAL_TX_OVERFLOW;
    919                }
    920          
    921                for(;PACKET_BUFFER_SIZE <= start; start-=PACKET_BUFFER_SIZE) {
    922                  buffer = emberStackBufferLink(buffer);
    923                }
    924                emberHoldMessageBuffer(buffer);
    925                
    926                e = &q->fifo[q->head];
    927                e->length = length;
    928                e->buffer = buffer;
    929                e->startIndex = start;
    930                #ifdef AVR_ATMEGA
    931                  //If we are using an AVR host, non power-of-2 queue sizes are NOT
    932                  //supported and therefore we use a mask
    933                  q->head = ((q->head+1) & emSerialTxQueueMasks[port]);
    934                #else // AVR_ATMEGA
    935                  //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
    936                  //supported and therefore we use a mod with the queue size
    937                  q->head = ((q->head+1) % emSerialTxQueueSizes[port]);
    938                #endif // !AVR_ATMEGA
    939                ATOMIC_LITE(
    940                  q->used++;
    941                )
    942                halInternalStartUartTx(port);  
    943                break; 
    944              }
    945          #endif// EM_ENABLE_SERIAL_BUFFER
    946            default:
    947              return EMBER_ERR_FATAL;
    948            }
    949            return EMBER_SUCCESS;
    950          #endif// !EZSP_HOST && !EMBER_SERIAL_USE_STDIO
    951          }
    952          #endif
    953          

   \                                 In section .text, align 2, keep-with-next
    954          EmberStatus emberSerialWaitSend(uint8_t port)  // waits for all byte to be written out of a port
    955          {
   \                     emberSerialWaitSend: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    956          #ifdef EMBER_SERIAL_USE_STDIO
    957            fflush(stdout);
    958          #else //EMBER_SERIAL_USE_STDIO
    959            switch(emSerialPortModes[port]) {
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x.... 0x....      ADR.W    R2,emSerialPortModes
   \   00000008   0x5C8A             LDRB     R2,[R1, R2]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD105             BNE.N    ??emberSerialWaitSend_0
    960          #ifdef EM_ENABLE_SERIAL_FIFO
    961            case EMBER_SERIAL_FIFO: {
    962              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   0000000E   0x....             LDR.N    R2,??DataTable18_1
   \   00000010   0xF852 0x1021      LDR      R1,[R2, R1, LSL #+2]
    963              while(q->used)
   \                     ??emberSerialWaitSend_1: (+1)
   \   00000014   0x888A             LDRH     R2,[R1, #+4]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1FC             BNE.N    ??emberSerialWaitSend_1
    964                simulatedSerialTimePasses();
    965              break; }
    966          #endif
    967          #ifdef EM_ENABLE_SERIAL_BUFFER
    968            case EMBER_SERIAL_BUFFER: {
    969              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    970              while(q->used) {
    971                simulatedSerialTimePasses();
    972              }
    973              break; }
    974          #endif
    975            default: {
    976            }
    977            } // close switch.
    978            halInternalWaitUartTxComplete(port);
   \                     ??emberSerialWaitSend_0: (+1)
   \   0000001A   0x.... 0x....      BL       halInternalWaitUartTxComplete
    979          #endif //EMBER_SERIAL_USE_STDIO
    980            return EMBER_SUCCESS;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
    981          }
    982          
    983          //------------------------------------------------------
    984          // Guaranteed output
    985          
    986          // The _only_ Guaranteed API:  The usage model for this api 
    987          //   Does not require efficiency

   \                                 In section .text, align 2, keep-with-next
    988          EmberStatus emberSerialGuaranteedPrintf(uint8_t port, PGM_P formatString, ...)
    989          {
   \                     emberSerialGuaranteedPrintf: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    990          #ifdef EMBER_SERIAL_USE_STDIO
    991            //TODO: This function might have to break stdio abstraction to operate
    992            //      with interrupts off and guarantee a print.
    993            //NOTE: The following code is the same code found in emberSerialPrintf
    994            EmberStatus stat;
    995            halInternalForcePrintf(true);
    996            va_list ap;
    997            va_start (ap, formatString);
    998            stat = emberSerialPrintfVarArg(port, formatString, ap);
    999            va_end (ap);
   1000            halInternalForcePrintf(false);
   1001            return stat;
   1002          #else //EMBER_SERIAL_USE_STDIO
   1003            va_list ap;
   1004            
   1005            // prevent interrupt driven transmission from intermixing
   1006            halInternalStopUartTx(port);
   \   00000008   0x.... 0x....      BL       halInternalStopUartTx
   1007            va_start(ap, formatString);
   \   0000000C   0xAB04             ADD      R3,SP,#+16
   1008            emPrintfInternal(halInternalForceWriteUartData, port, formatString, ap);
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x....             LDR.N    R0,??DataTable18_3
   \   00000014   0x.... 0x....      BL       emPrintfInternal
   1009            va_end(ap);
   1010          
   1011            // re-enable interrupt driven transmission if needed
   1012            switch(emSerialPortModes[port]) {
   \   00000018   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x5C41             LDRB     R1,[R0, R1]
   \   00000020   0x2901             CMP      R1,#+1
   \   00000022   0xD107             BNE.N    ??emberSerialGuaranteedPrintf_0
   1013          #ifdef EM_ENABLE_SERIAL_FIFO
   1014            case EMBER_SERIAL_FIFO: {
   1015              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   1016              if(q->used)
   \   00000024   0x....             LDR.N    R1,??DataTable18_1
   \   00000026   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000002A   0x8880             LDRH     R0,[R0, #+4]
   \   0000002C   0xB110             CBZ.N    R0,??emberSerialGuaranteedPrintf_0
   1017                halInternalStartUartTx(port);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       halInternalStartUartTx
   1018              break; }
   1019          #endif
   1020          #ifdef EM_ENABLE_SERIAL_BUFFER
   1021            case EMBER_SERIAL_BUFFER: {
   1022              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1023              if(q->used)
   1024                halInternalStartUartTx(port);
   1025              break; }
   1026          #endif
   1027            default: {
   1028            }
   1029            } //close switch.
   1030          
   1031            return EMBER_SUCCESS;
   \                     ??emberSerialGuaranteedPrintf_0: (+1)
   \   00000034   0xBC32             POP      {R1,R4,R5}
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   1032          #endif //EMBER_SERIAL_USE_STDIO
   1033          }
   1034          
   1035          //------------------------------------------------------
   1036          // Serial buffer maintenance

   \                                 In section .text, align 2, keep-with-next
   1037          void emberSerialFlushRx(uint8_t port) 
   1038          {
   \                     emberSerialFlushRx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1039          #ifdef EMBER_SERIAL_USE_STDIO
   1040            ATOMIC(
   1041              while(halInternalPrintfReadAvailable()) {
   1042                (int)getchar();
   1043              }
   1044            )
   1045          #else //EMBER_SERIAL_USE_STDIO
   1046            EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialRxQueues[port];
   \   00000002   0x....             LDR.N    R1,??DataTable18_1
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6904             LDR      R4,[R0, #+16]
   1047          
   1048            ATOMIC_LITE(
   1049               q->used = 0;
   1050               q->head = 0;
   1051               q->tail = 0;
   1052               )
   \   0000000A   0x.... 0x....      BL       _disableBasePri
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x80A1             STRH     R1,[R4, #+4]
   \   00000012   0x8021             STRH     R1,[R4, #+0]
   \   00000014   0x8061             STRH     R1,[R4, #+2]
   \   00000016   0x.... 0x....      BL       _writeBasePri
   1053          
   1054            halInternalRestartUart();
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      halInternalRestartUart
   1055          #endif //EMBER_SERIAL_USE_STDIO
   1056          }
   1057          
   1058          //------------------------------------------------------
   1059          // Serial Buffer Cleanup Tick
   1060          
   1061          #ifdef EM_ENABLE_SERIAL_BUFFER
   1062          //Helper function to calculate deadIndex since ifdefs cannot exist in the 
   1063          //ATOMIC_LITE block
   1064          uint8_t calculateDeadIndex(uint8_t port, uint8_t tail, uint8_t numDead) {
   1065            uint8_t deadIndex;
   1066            
   1067            #ifdef AVR_ATMEGA
   1068              //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1069              //supported and therefore we use a mask
   1070              deadIndex = (tail - numDead) & emSerialTxQueueMasks[port];
   1071            #else // AVR_ATMEGA
   1072              //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1073              //supported and therefore we need to use a conditional to figure
   1074              //out the deadIndex
   1075              if(numDead > tail) {
   1076                //Since subtracting numDead from tail would cause deadIndex to
   1077                //wrap, we add the tail to the queue size and then subtract
   1078                //numDead
   1079                deadIndex = (emSerialTxQueueSizes[port] + tail) - numDead;
   1080              } else {
   1081                deadIndex = tail - numDead;
   1082              }
   1083            #endif // !AVR_ATMEGA
   1084            
   1085            return deadIndex;
   1086          }
   1087          #endif //EM_ENABLE_SERIAL_BUFFER
   1088              

   \                                 In section .text, align 2, keep-with-next
   1089          void emberSerialBufferTick(void)
   1090          {
   1091          #ifdef EM_ENABLE_SERIAL_BUFFER
   1092            uint8_t port;
   1093            EmSerialBufferQueue *q;
   1094            uint8_t numDead, deadIndex;
   1095          
   1096            for(port=0; port<EM_NUM_SERIAL_PORTS; port++) {
   1097              if(emSerialPortModes[port] == EMBER_SERIAL_BUFFER) {
   1098                q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1099          
   1100                if(q->dead) {
   1101                  ATOMIC_LITE(
   1102                    numDead = q->dead;
   1103                    q->dead = 0;
   1104                    deadIndex = calculateDeadIndex(port,q->tail,numDead);
   1105                  )
   1106                  for(;numDead;numDead--) {
   1107                    // Refcounts may be manipulated in ISR if DMA used
   1108                    ATOMIC( emberReleaseMessageBuffer(q->fifo[deadIndex].buffer); )
   1109                    #ifdef AVR_ATMEGA
   1110                      //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1111                      //supported and therefore we use a mask
   1112                      deadIndex = (deadIndex + 1) & emSerialTxQueueMasks[port];
   1113                    #else // AVR_ATMEGA
   1114                      //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1115                      //supported and therefore we use a mod with the queue size
   1116                      deadIndex = (deadIndex + 1) % emSerialTxQueueSizes[port];
   1117                    #endif // !AVR_ATMEGA
   1118                  }
   1119                }
   1120              }
   1121            }
   1122          #endif
   1123          }
   \                     emberSerialBufferTick: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1124          

   \                                 In section .text, align 2, keep-with-next
   1125          bool emberSerialUnused(uint8_t port)
   1126          {
   1127          #ifdef EMBER_SERIAL_USE_STDIO
   1128            return false;
   1129          #else //EMBER_SERIAL_USE_STDIO
   1130            return (EM_NUM_SERIAL_PORTS <= port
   1131                    || emSerialPortModes[port] == EMBER_SERIAL_UNUSED);
   \                     emberSerialUnused: (+1)
   \   00000000   0x2804             CMP      R0,#+4
   \   00000002   0xDA06             BGE.N    ??emberSerialUnused_0
   \   00000004   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   00000008   0x5C41             LDRB     R1,[R0, R1]
   \   0000000A   0x1E48             SUBS     R0,R1,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR
   \                     ??emberSerialUnused_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x4770             BX       LR               ;; return
   1132          #endif //EMBER_SERIAL_USE_STDIO
   1133          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x08 0x20          DC8      "\b \b"
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     emSerialTxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     emSerialRxError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     halInternalForceWriteUartData

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x08 0x20          DC8 "\010 \010"
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x73 0x65          DC8 "serial.c"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x2E 0x63    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   emberSerialBufferTick
       8   emberSerialFlushRx
         8   -> _disableBasePri
         8   -> _writeBasePri
         0   -> halInternalRestartUart
      24   emberSerialGuaranteedPrintf
        24   -> emPrintfInternal
        24   -> halInternalStartUartTx
        24   -> halInternalStopUartTx
      32   emberSerialInit
        32   -> _disableBasePri
        32   -> _writeBasePri
        32   -> emberSerialUnused
        32   -> halInternalRestartUart
         0   -> halInternalUartInit
       8   emberSerialPrintfVarArg
         8   -> emPrintfInternal
       8   emberSerialReadAvailable
         8   -> halInternalUartRxPump
      32   emberSerialReadByte
        32   -> _disableBasePri
        32   -> _writeBasePri
        32   -> emberSerialUnused
        32   -> halInternalUartRxPump
      24   emberSerialReadData
        24   -> emberSerialReadByte
      40   emberSerialReadDataTimeout
        40   -> emberSerialReadByte
        40   -> halCommonGetInt16uMillisecondTick
      24   emberSerialReadLine
        24   -> emberSerialReadPartialLine
        24   -> halInternalResetWatchDog
      24   emberSerialReadPartialLine
        24   -> emberSerialReadByte
        24   -> emberSerialWriteByte
        24   -> emberSerialWriteString
       0   emberSerialUnused
       8   emberSerialWaitSend
         8   -> halInternalWaitUartTxComplete
       0   emberSerialWriteAvailable
      40   emberSerialWriteData
        40   -> _disableBasePri
        40   -> _writeBasePri
        40   -> getOutputFifoSpace
        40   -> halInternalAssertFailed
        40   -> halInternalStartUartTx
      32   emberSerialWriteString
        32   -> _disableBasePri
        32   -> _writeBasePri
        32   -> getOutputFifoSpace
        32   -> halInternalStartUartTx
       0   getOutputFifoSpace


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
      12  ?Subroutine0
       4  ?_0
      12  ?_1
     136  emSerial0RxQueue
     136  emSerial0TxQueue
     136  emSerial1RxQueue
     136  emSerial1TxQueue
     136  emSerial3RxQueue
     136  emSerial3TxQueue
       4  emSerialBlocking
       4  emSerialPortModes
      12  emSerialRxError
          emSerialRxErrorIndex
       8  emSerialRxQueueSizes
       8  emSerialRxQueueWraps
       8  emSerialTxQueueMasks
       8  emSerialTxQueueSizes
       8  emSerialTxQueueWraps
      32  emSerialTxQueues
          emSerialRxQueues
       2  emberSerialBufferTick
      34  emberSerialFlushRx
      60  emberSerialGuaranteedPrintf
     110  emberSerialInit
      36  emberSerialPrintfVarArg
      22  emberSerialReadAvailable
     148  emberSerialReadByte
      58  emberSerialReadData
      96  emberSerialReadDataTimeout
      40  emberSerialReadLine
     216  emberSerialReadPartialLine
      22  emberSerialUnused
      34  emberSerialWaitSend
      36  emberSerialWriteAvailable
     158  emberSerialWriteData
     136  emberSerialWriteString
      24  getOutputFifoSpace

 
   828 bytes in section .bss
    32 bytes in section .data
    20 bytes in section .rodata
 1 304 bytes in section .text
 
 1 304 bytes of CODE  memory
    20 bytes of CONST memory
   860 bytes of DATA  memory

Errors: none
Warnings: none
