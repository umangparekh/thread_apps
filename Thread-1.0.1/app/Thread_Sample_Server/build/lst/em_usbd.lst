###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  13:29:25
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\usb\em_usbd.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\usb\em_usbd.c -D
#        APP_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D
#        PHY_EM3XX -D "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"em_usbd.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\usb\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\em_usbd.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\em_usbd.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\hal\micro\cortexm3\usb\em_usbd.c
      1          /**************************************************************************//**
      2           * @file hal/micro/cortexm3/usb/em_usbd.c
      3           * @brief USB protocol stack library, device API.
      4           * @author Nathaniel Ting
      5           * @version 3.20.3
      6           * <!-- Copyright 2013 by Silicon Laboratories. All rights reserved.     *80*-->
      7           *****************************************************************************/
      8          #include PLATFORM_HEADER
      9          #include "stack/include/ember.h"
     10          #include "hal/hal.h"
     11          
     12          #if CORTEXM3_EM35X_USB
     13          #include "em_usb.h"
     14          #include "em_usbhal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USBHAL_DisableGlobalInt(void)
   \                     USBHAL_DisableGlobalInt: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0xe000e180
   \   00000004   0xF44F 0x2000      MOV      R0,#+524288
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x4000a888
   \   00000010   0x6041             STR      R1,[R0, #+4]
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp bool USBDHAL_EpIsStalled(struct <unnamed> *)
   \                     USBDHAL_EpIsStalled: (+1)
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable22_2  ;; 0x40011054
   \   00000006   0x6810             LDR      R0,[R2, #+0]
   \   00000008   0x40C8             LSRS     R0,R0,R1
   \   0000000A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000000E   0x4770             BX       LR               ;; return
     15          
     16          #include "em_usbtypes.h"
     17          #include "em_usbd.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void USBD_ArmEp(struct <unnamed> *)
   \                     USBD_ArmEp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x78A0             LDRB     R0,[R4, #+2]
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable22_3  ;; 0x40011008
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable22_4
   \   00000010   0xB998             CBNZ.N   R0,??USBD_ArmEp_0
   \   00000012   0xB3A1             CBZ.N    R1,??USBD_ArmEp_1
   \   00000014   0x6921             LDR      R1,[R4, #+16]
   \   00000016   0x89A6             LDRH     R6,[R4, #+12]
   \   00000018   0x428E             CMP      R6,R1
   \   0000001A   0xBF88             IT       HI 
   \   0000001C   0x460E             MOVHI    R6,R1
   \   0000001E   0x1B88             SUBS     R0,R1,R6
   \   00000020   0x6120             STR      R0,[R4, #+16]
   \   00000022   0xB126             CBZ.N    R6,??USBD_ArmEp_2
   \   00000024   0x68A1             LDR      R1,[R4, #+8]
   \   00000026   0x6818             LDR      R0,[R3, #+0]
   \   00000028   0xB2F2             UXTB     R2,R6
   \   0000002A   0x.... 0x....      BL       halCommonMemMove
   \                     ??USBD_ArmEp_2: (+1)
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x1830             ADDS     R0,R6,R0
   \   00000032   0x60A0             STR      R0,[R4, #+8]
   \   00000034   0x60AE             STR      R6,[R5, #+8]
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE020             B.N      ??USBD_ArmEp_3
   \                     ??USBD_ArmEp_0: (+1)
   \   0000003A   0xB301             CBZ.N    R1,??USBD_ArmEp_1
   \   0000003C   0x6921             LDR      R1,[R4, #+16]
   \   0000003E   0x89A6             LDRH     R6,[R4, #+12]
   \   00000040   0x428E             CMP      R6,R1
   \   00000042   0xBF88             IT       HI 
   \   00000044   0x460E             MOVHI    R6,R1
   \   00000046   0x1B89             SUBS     R1,R1,R6
   \   00000048   0x6121             STR      R1,[R4, #+16]
   \   0000004A   0x6961             LDR      R1,[R4, #+20]
   \   0000004C   0x1871             ADDS     R1,R6,R1
   \   0000004E   0x6161             STR      R1,[R4, #+20]
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xBF1C             ITT      NE 
   \   00000054   0x68A1             LDRNE    R1,[R4, #+8]
   \   00000056   0x2900             CMPNE    R1,#+0
   \   00000058   0xD004             BEQ.N    ??USBD_ArmEp_4
   \   0000005A   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \   0000005E   0xB2F2             UXTB     R2,R6
   \   00000060   0x.... 0x....      BL       halCommonMemMove
   \                     ??USBD_ArmEp_4: (+1)
   \   00000064   0x68A0             LDR      R0,[R4, #+8]
   \   00000066   0x1830             ADDS     R0,R6,R0
   \   00000068   0x60A0             STR      R0,[R4, #+8]
   \   0000006A   0x78A1             LDRB     R1,[R4, #+2]
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable22_5
   \   00000070   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000074   0x6006             STR      R6,[R0, #+0]
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x78A1             LDRB     R1,[R4, #+2]
   \   0000007A   0x4088             LSLS     R0,R0,R1
   \                     ??USBD_ArmEp_3: (+1)
   \   0000007C   0x6028             STR      R0,[R5, #+0]
   \                     ??USBD_ArmEp_1: (+1)
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct <unnamed> *USBD_GetEpFromAddr(uint8_t)
   \                     USBD_GetEpFromAddr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable22_6
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xF000 0x030F      AND      R3,R0,#0xF
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x189B             ADDS     R3,R3,R2
   \   00000010   0x0604             LSLS     R4,R0,#+24
   \   00000012   0xBF4C             ITE      MI 
   \   00000014   0xF893 0x30D4      LDRBMI   R3,[R3, #+212]
   \   00000018   0xF893 0x30E1      LDRBPL   R3,[R3, #+225]
   \   0000001C   0xB12B             CBZ.N    R3,??USBD_GetEpFromAddr_0
   \   0000001E   0x2028             MOVS     R0,#+40
   \   00000020   0xFB00 0x2003      MLA      R0,R0,R3,R2
   \   00000024   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000028   0xE004             B.N      ??USBD_GetEpFromAddr_1
   \                     ??USBD_GetEpFromAddr_0: (+1)
   \   0000002A   0x230F             MOVS     R3,#+15
   \   0000002C   0x4218             TST      R0,R3
   \   0000002E   0xBF08             IT       EQ 
   \   00000030   0xF102 0x0134      ADDEQ    R1,R2,#+52
   \                     ??USBD_GetEpFromAddr_1: (+1)
   \   00000034   0x4608             MOV      R0,R1
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
     18          
     19          #include "app/util/serial/serial.h"
     20          
     21          
     22          
     23          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
     24          

   \                                 In section .bss, align 4
     25          static USBD_Device_TypeDef device;
   \                     device:
   \   00000000                      DS8 240

   \                                 In section .data, align 4
     26          USBD_Device_TypeDef *dev = &device;
   \                     dev:
   \   00000000   0x........         DC32 device
     27          

   \                                 In section .data, align 4
     28          static const char *stateNames[] =
   \                     stateNames:
   \   00000000   0x........         DC32 ?_0, ?_1, ?_2, ?_3, ?_4, 0H, ?_5, ?_6
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x........   
   \              0x........   
     29          {
     30            [ USBD_STATE_NONE       ] = "NONE      ",
     31            [ USBD_STATE_ATTACHED   ] = "ATTACHED  ",
     32            [ USBD_STATE_POWERED    ] = "POWERED   ",
     33            [ USBD_STATE_DEFAULT    ] = "DEFAULT   ",
     34            [ USBD_STATE_ADDRESSED  ] = "ADDRESSED ",
     35            [ USBD_STATE_CONFIGURED ] = "CONFIGURED",
     36            [ USBD_STATE_SUSPENDED  ] = "SUSPENDED ",
     37            [ USBD_STATE_LASTMARKER ] = "UNDEFINED "
     38          };
     39          
     40          /** @endcond */
     41          
     42          
     43          /** @addtogroup USB_DEVICE
     44           * @brief 
     45           *
     46           * See em_usbd.c for source code.
     47           *  @{*/
     48          /***************************************************************************//**
     49           * @brief
     50           *   Abort all pending transfers.
     51           *
     52           * @details
     53           *   Aborts transfers for all endpoints currently in use. Pending
     54           *   transfers on the default endpoint (EP0) are not aborted.
     55           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     56          void USBD_AbortAllTransfers( void )
     57          {
   \                     USBD_AbortAllTransfers: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     58            ATOMIC(
     59            USBDHAL_AbortAllTransfers( USB_STATUS_EP_ABORTED );
     60            )
   \   00000002   0x.... 0x....      BL       _disableBasePri
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0xF06F 0x0005      MVN      R0,#+5
   \   0000000C   0x.... 0x....      BL       USBDHAL_AbortAllTransfers
   \   00000010   0x....             B.N      ?Subroutine1
     61          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0xE8BD 0x4010      POP      {R4,LR}
   \   00000006   0x.... 0x....      B.W      _writeBasePri
     62          
     63          /***************************************************************************//**
     64           * @brief
     65           *   Abort a pending transfer on a specific endpoint.
     66           *
     67           * @param[in] epAddr
     68           *   The address of the endpoint to abort.
     69           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     70          int USBD_AbortTransfer( int epAddr )
     71          {
   \                     USBD_AbortTransfer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
     72            USB_XferCompleteCb_TypeDef callback;
     73            USBD_Ep_TypeDef *ep = USBD_GetEpFromAddr( epAddr );
   \   00000002   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000006   0x0004             MOVS     R4,R0
     74          
     75          
     76          
     77            // nUSBD_AbortTransfer(), Illegal request
     78            assert (ep!=NULL);
   \   00000008   0x.... 0x....      ADR.W    R5,?_7
   \   0000000C   0xD103             BNE.N    ??USBD_AbortTransfer_0
   \   0000000E   0x214E             MOVS     R1,#+78
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       halInternalAssertFailed
     79          
     80            // nUSBD_AbortTransfer(), Illegal endpoint
     81            assert (ep->num!=0);
   \                     ??USBD_AbortTransfer_0: (+1)
   \   00000016   0x78A0             LDRB     R0,[R4, #+2]
   \   00000018   0xB918             CBNZ.N   R0,??USBD_AbortTransfer_1
   \   0000001A   0x2151             MOVS     R1,#+81
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       halInternalAssertFailed
     82          
     83          
     84            DECLARE_INTERRUPT_STATE;
     85            DISABLE_INTERRUPTS();
   \                     ??USBD_AbortTransfer_1: (+1)
   \   00000022   0x.... 0x....      BL       _disableBasePri
   \   00000026   0x4605             MOV      R5,R0
     86            if ( ep->state == D_EP_IDLE )
   \   00000028   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD043             BEQ.N    ??USBD_AbortTransfer_2
     87            {
     88              RESTORE_INTERRUPTS();
     89              return USB_STATUS_OK;
     90            }
     91          
     92            // USBD_AbortEp( ep );
     93          
     94            ep->state = D_EP_IDLE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF884 0x0020      STRB     R0,[R4, #+32]
     95            if ( ep->xferCompleteCb )
   \   00000036   0x6A63             LDR      R3,[R4, #+36]
   \   00000038   0x0018             MOVS     R0,R3
   \   0000003A   0xD03D             BEQ.N    ??USBD_AbortTransfer_2
     96            {
     97              callback = ep->xferCompleteCb;
     98              ep->xferCompleteCb = NULL;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x6260             STR      R0,[R4, #+36]
     99          
    100              if ( ( dev->lastState == USBD_STATE_CONFIGURED ) &&
    101                   ( dev->state     == USBD_STATE_ADDRESSED  )    )
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable22_6
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF890 0x1021      LDRB     R1,[R0, #+33]
   \   0000004A   0x2904             CMP      R1,#+4
   \   0000004C   0xBF04             ITT      EQ 
   \   0000004E   0x7FC0             LDRBEQ   R0,[R0, #+31]
   \   00000050   0x2804             CMPEQ    R0,#+4
   \   00000052   0xD12C             BNE.N    ??USBD_AbortTransfer_3
    102              {
    103                USBDHAL_DeactivateEp( ep );
   \   00000054   0x78A1             LDRB     R1,[R4, #+2]
   \   00000056   0x.... 0x....      LDR.W    R2,??DataTable22_7  ;; 0x4001104c
   \   0000005A   0x7827             LDRB     R7,[R4, #+0]
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xFA00 0xF101      LSL      R1,R0,R1
   \   00000062   0x43CE             MVNS     R6,R1
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable22_8  ;; 0x4000a88c
   \   00000068   0xB18F             CBZ.N    R7,??USBD_AbortTransfer_4
   \   0000006A   0x6817             LDR      R7,[R2, #+0]
   \   0000006C   0x403E             ANDS     R6,R6,R7
   \   0000006E   0x6016             STR      R6,[R2, #+0]
   \   00000070   0xF44F 0x7780      MOV      R7,#+256
   \   00000074   0x6916             LDR      R6,[R2, #+16]
   \   00000076   0xF894 0xC002      LDRB     R12,[R4, #+2]
   \   0000007A   0xFA07 0xF70C      LSL      R7,R7,R12
   \   0000007E   0x43BE             BICS     R6,R6,R7
   \   00000080   0x6116             STR      R6,[R2, #+16]
   \   00000082   0x680A             LDR      R2,[R1, #+0]
   \   00000084   0x78A6             LDRB     R6,[R4, #+2]
   \   00000086   0x40B0             LSLS     R0,R0,R6
   \   00000088   0xEA22 0x0000      BIC      R0,R2,R0
   \   0000008C   0xE00E             B.N      ??USBD_AbortTransfer_5
   \                     ??USBD_AbortTransfer_4: (+1)
   \   0000008E   0x6850             LDR      R0,[R2, #+4]
   \   00000090   0x4030             ANDS     R0,R6,R0
   \   00000092   0x6050             STR      R0,[R2, #+4]
   \   00000094   0xF44F 0x3680      MOV      R6,#+65536
   \   00000098   0x6910             LDR      R0,[R2, #+16]
   \   0000009A   0x78A7             LDRB     R7,[R4, #+2]
   \   0000009C   0x40BE             LSLS     R6,R6,R7
   \   0000009E   0x43B0             BICS     R0,R0,R6
   \   000000A0   0x6110             STR      R0,[R2, #+16]
   \   000000A2   0x2280             MOVS     R2,#+128
   \   000000A4   0x6808             LDR      R0,[R1, #+0]
   \   000000A6   0x78A6             LDRB     R6,[R4, #+2]
   \   000000A8   0x40B2             LSLS     R2,R2,R6
   \   000000AA   0x4390             BICS     R0,R0,R2
   \                     ??USBD_AbortTransfer_5: (+1)
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    104              }
    105          
    106              // DEBUG_TRACE_ABORT( USB_STATUS_EP_ABORTED );
    107              callback( USB_STATUS_EP_ABORTED, ep->xferred, ep->remaining );
   \                     ??USBD_AbortTransfer_3: (+1)
   \   000000AE   0x6922             LDR      R2,[R4, #+16]
   \   000000B0   0x6961             LDR      R1,[R4, #+20]
   \   000000B2   0xF06F 0x0005      MVN      R0,#+5
   \   000000B6   0x4798             BLX      R3
    108            }
    109          
    110            RESTORE_INTERRUPTS();
   \                     ??USBD_AbortTransfer_2: (+1)
   \   000000B8   0x4628             MOV      R0,R5
   \   000000BA   0x.... 0x....      BL       _writeBasePri
    111            return USB_STATUS_OK;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    112          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x460C             MOV      R4,R1
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x461E             MOV      R6,R3
   \                     ??Subroutine2_0: (+1)
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x....             B.N      USBD_GetEpFromAddr
    113          
    114          /***************************************************************************//**
    115           * @brief
    116           *   Start USB device operation.
    117           *
    118           * @details
    119           *   Device operation is started by connecting a pullup resistor on the
    120           *   appropriate USB data line.
    121           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    122          void USBD_Connect( void )
    123          {
   \                     USBD_Connect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    124            ATOMIC(
    125            USBDHAL_Connect();
    126            )
   \   00000002   0x.... 0x....      BL       _disableBasePri
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x.... 0x....      BL       USBDHAL_Connect
   \   0000000C                      REQUIRE ?Subroutine1
   \   0000000C                      ;; // Fall through to label ?Subroutine1
    127          }
    128          
    129          /***************************************************************************//**
    130           * @brief
    131           *   Stop USB device operation.
    132           *
    133           * @details
    134           *   Device operation is stopped by disconnecting the pullup resistor from the
    135           *   appropriate USB data line. Often referred to as a "soft" disconnect.
    136           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    137          void USBD_Disconnect( void )
    138          {
   \                     USBD_Disconnect: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    139            ATOMIC(
    140            USBDHAL_Disconnect();
    141            )
   \   00000002   0x.... 0x....      BL       _disableBasePri
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x.... 0x....      BL       USBDHAL_Disconnect
   \   0000000C   0x....             B.N      ?Subroutine1
    142          }
    143          
    144          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */

   \                                 In section .text, align 2, keep-with-next
    145          void USBD_SetUsbState( USBD_State_TypeDef newState )
    146          {
    147            USBD_State_TypeDef currentState;
    148          
    149            currentState = dev->state;
   \                     USBD_SetUsbState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable22_6
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x7FCA             LDRB     R2,[R1, #+31]
    150            if ( newState == USBD_STATE_SUSPENDED )
   \   00000008   0xF101 0x031F      ADD      R3,R1,#+31
   \   0000000C   0x2806             CMP      R0,#+6
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x705A             STRBEQ   R2,[R3, #+1]
    151            {
    152              dev->savedState = currentState;
    153            }
    154          
    155            dev->lastState = dev->state;
   \   00000012   0x709A             STRB     R2,[R3, #+2]
    156            dev->state = newState;
   \   00000014   0x77C8             STRB     R0,[R1, #+31]
   \   00000016   0x6B09             LDR      R1,[R1, #+48]
   \   00000018   0x684B             LDR      R3,[R1, #+4]
   \   0000001A   0x0019             MOVS     R1,R3
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x4282             CMPNE    R2,R0
   \   00000020   0xD002             BEQ.N    ??USBD_SetUsbState_0
    157          
    158            if ( ( dev->callbacks->usbStateChange ) &&
    159                 ( currentState != newState       )    )
    160            {
    161              dev->callbacks->usbStateChange( currentState, newState );
   \   00000022   0x4601             MOV      R1,R0
   \   00000024   0x4610             MOV      R0,R2
   \   00000026   0x4718             BX       R3
    162            }
    163          }
   \                     ??USBD_SetUsbState_0: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    164          /** @endcond */
    165          
    166          /***************************************************************************//**
    167           * @brief
    168           *   Get current USB device state.
    169           *
    170           * @return
    171           *   Device USB state. See @ref USBD_State_TypeDef.
    172           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    173          USBD_State_TypeDef USBD_GetUsbState( void )
    174          {
    175            return dev->state;
   \                     USBD_GetUsbState: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable22_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7FC0             LDRB     R0,[R0, #+31]
   \   00000008   0x4770             BX       LR               ;; return
    176          }
    177          
    178          /***************************************************************************//**
    179           * @brief
    180           *   Get a string naming a device USB state.
    181           *
    182           * @param[in] state
    183           *   Device USB state. See @ref USBD_State_TypeDef.
    184           *
    185           * @return
    186           *   State name string pointer.
    187           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    188          const char *USBD_GetUsbStateName( USBD_State_TypeDef state )
    189          {
    190            if ( state > USBD_STATE_LASTMARKER )
   \                     USBD_GetUsbStateName: (+1)
   \   00000000   0x2808             CMP      R0,#+8
    191              state = USBD_STATE_LASTMARKER;
    192          
    193            return stateNames[ state ];
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \   00000006   0xBFA8             IT       GE 
   \   00000008   0x2007             MOVGE    R0,#+7
   \   0000000A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000000E   0x4770             BX       LR               ;; return
    194          }
    195          
    196          
    197          /***************************************************************************//**
    198           * @brief
    199           *   Check if an endpoint is busy doing a transfer.
    200           *
    201           * @param[in] epAddr
    202           *   The address of the endpoint to check.
    203           *
    204           * @return
    205           *   True if endpoint is busy, false otherwise.
    206           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    207          bool USBD_EpIsBusy( int epAddr )
    208          {
   \                     USBD_EpIsBusy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    209            USBD_Ep_TypeDef *ep = USBD_GetEpFromAddr( epAddr );
   \   00000002   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0x0004             MOVS     R4,R0
    210          
    211            // USBD_EpIsBusy(), Illegal endpoint
    212            assert (ep!=NULL);
   \   00000008   0xD102             BNE.N    ??CrossCallReturnLabel_8
   \   0000000A   0x21D4             MOVS     R1,#+212
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    213          
    214            if ( ep->state == D_EP_IDLE )
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000010   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000014   0xB100             CBZ.N    R0,??USBD_EpIsBusy_0
    215              return false;
    216          
    217            return true;
   \   00000016   0x2001             MOVS     R0,#+1
   \                     ??USBD_EpIsBusy_0: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    218          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,?_7
   \   00000004   0x.... 0x....      B.W      halInternalAssertFailed
    219          
    220          /***************************************************************************//**
    221           * @brief
    222           *   Set an endpoint in the stalled (halted) state.
    223           *
    224           * @param[in] epAddr
    225           *   The address of the endpoint to stall.
    226           *
    227           * @return
    228           *   @ref USB_STATUS_OK on success, else an appropriate error code.
    229           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    230          int USBD_StallEp( int epAddr )
    231          {
   \                     USBD_StallEp: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    232            USB_Status_TypeDef retVal;
    233            USBD_Ep_TypeDef *ep = USBD_GetEpFromAddr( epAddr );
   \   00000002   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x0004             MOVS     R4,R0
    234          
    235          
    236            #ifdef USB_DEBUG_STALL
    237              DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"Stalling EP%d",ep->num);
    238              if (ep->in)
    239                DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"in\r\n");
    240              else 
    241                DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"out\r\n");
    242            #endif
    243          
    244            // USBD_StallEp(), Illegal request
    245            assert (ep!=NULL);
   \   00000008   0xD102             BNE.N    ??CrossCallReturnLabel_7
   \   0000000A   0x21F5             MOVS     R1,#+245
   \   0000000C   0x.... 0x....      BL       ?Subroutine3
    246          
    247            // USBD_StallEp(), Illegal endpoint
    248            // assert (ep->num!=0);
    249          
    250            ATOMIC(
    251              retVal = USBDHAL_StallEp( ep );
    252            )
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000010   0x.... 0x....      BL       _disableBasePri
   \   00000014   0x78A2             LDRB     R2,[R4, #+2]
   \   00000016   0x7823             LDRB     R3,[R4, #+0]
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x4091             LSLS     R1,R1,R2
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable22_2  ;; 0x40011054
   \   00000020   0xB11B             CBZ.N    R3,??USBD_StallEp_0
   \   00000022   0x6813             LDR      R3,[R2, #+0]
   \   00000024   0x4319             ORRS     R1,R1,R3
   \   00000026   0x6011             STR      R1,[R2, #+0]
   \   00000028   0xE002             B.N      ??USBD_StallEp_1
   \                     ??USBD_StallEp_0: (+1)
   \   0000002A   0x6853             LDR      R3,[R2, #+4]
   \   0000002C   0x4319             ORRS     R1,R1,R3
   \   0000002E   0x6051             STR      R1,[R2, #+4]
   \                     ??USBD_StallEp_1: (+1)
   \   00000030   0x....             B.N      ?Subroutine0
    253          
    254            if ( retVal != USB_STATUS_OK )
    255            {
    256              retVal = USB_STATUS_ILLEGAL;
    257            }
    258          
    259            return retVal;
    260          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       _writeBasePri
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xBD10             POP      {R4,PC}          ;; return
    261          
    262          
    263          /***************************************************************************//**
    264           * @brief
    265           *   Reset stall state on a stalled (halted) endpoint.
    266           *
    267           * @param[in] epAddr
    268           *   The address of the endpoint to un-stall.
    269           *
    270           * @return
    271           *   @ref USB_STATUS_OK on success, else an appropriate error code.
    272           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    273          int USBD_UnStallEp( int epAddr )
    274          {
   \                     USBD_UnStallEp: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    275            USB_Status_TypeDef retVal;
    276            USBD_Ep_TypeDef *ep = USBD_GetEpFromAddr( epAddr );
   \   00000002   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x0004             MOVS     R4,R0
    277          
    278          
    279            #ifdef USB_DEBUG_STALL
    280              DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"Unstalling EP%d",ep->num);
    281              if (ep->in)
    282                DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"in\r\n");
    283              else 
    284                DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"out\r\n");
    285            #endif
    286          
    287          
    288            // USBD_StallEp(), Illegal request
    289            assert (ep!=NULL);
   \   00000008   0xD103             BNE.N    ??CrossCallReturnLabel_6
   \   0000000A   0xF240 0x1121      MOVW     R1,#+289
   \   0000000E   0x.... 0x....      BL       ?Subroutine3
    290            // USBD_StallEp(), Illegal endpoint
    291            // assert (ep->num!=0);
    292          
    293            ATOMIC(
    294              retVal = USBDHAL_UnStallEp( ep );
    295            )
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000012   0x.... 0x....      BL       _disableBasePri
   \   00000016   0x78A2             LDRB     R2,[R4, #+2]
   \   00000018   0x7823             LDRB     R3,[R4, #+0]
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4091             LSLS     R1,R1,R2
   \   0000001E   0x43C9             MVNS     R1,R1
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable22_2  ;; 0x40011054
   \   00000024   0xB11B             CBZ.N    R3,??USBD_UnStallEp_0
   \   00000026   0x6813             LDR      R3,[R2, #+0]
   \   00000028   0x4019             ANDS     R1,R1,R3
   \   0000002A   0x6011             STR      R1,[R2, #+0]
   \   0000002C   0xE002             B.N      ??USBD_UnStallEp_1
   \                     ??USBD_UnStallEp_0: (+1)
   \   0000002E   0x6853             LDR      R3,[R2, #+4]
   \   00000030   0x4019             ANDS     R1,R1,R3
   \   00000032   0x6051             STR      R1,[R2, #+4]
   \                     ??USBD_UnStallEp_1: (+1)
   \   00000034                      REQUIRE ?Subroutine0
   \   00000034                      ;; // Fall through to label ?Subroutine0
    296          
    297            if ( retVal != USB_STATUS_OK )
    298            {
    299              retVal = USB_STATUS_ILLEGAL;
    300            }
    301          
    302            return retVal;
    303          }
    304          
    305          /***************************************************************************//**
    306           * @brief
    307           *   Stop USB device stack operation.
    308           *
    309           * @details
    310           *   The data-line pullup resistor is turned off, USB interrupts are disabled,
    311           *   and finally the USB pins are disabled.
    312           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    313          void USBD_Stop( void )
    314          {
   \                     USBD_Stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    315            USBD_Disconnect();
   \   00000002   0x.... 0x....      BL       USBD_Disconnect
    316            USBHAL_DisableGlobalInt();
   \   00000006   0x.... 0x....      BL       USBHAL_DisableGlobalInt
    317            USBD_SetUsbState( USBD_STATE_NONE );
   \   0000000A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             B.N      USBD_SetUsbState
    318          }
    319          
    320          
    321          /***************************************************************************//**
    322           * @brief
    323           *   Initializes USB device hardware and internal protocol stack data structures,
    324           *   then connects the data-line (D+ or D-) pullup resistor to signal host that
    325           *   enumeration can begin.
    326           *
    327           * @note
    328           *   You may later use @ref USBD_Disconnect() and @ref USBD_Connect() to force
    329           *   reenumeration.
    330           *
    331           * @param[in] p
    332           *   Pointer to device initialization struct. See @ref USBD_Init_TypeDef.
    333           *
    334           * @return
    335           *   @ref USB_STATUS_OK on success, else an appropriate error code.
    336           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    337          int USBD_Init( const USBD_Init_TypeDef *p )
    338          {
   \                     USBD_Init: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
    339            
    340            int numEps;
    341            USBD_Ep_TypeDef *ep;
    342            uint8_t txFifoNum;
    343            uint8_t *conf, *confEnd;
    344            USB_EndpointDescriptor_TypeDef *epd;
    345            uint32_t totalRxFifoSize, totalTxFifoSize, numInEps, numOutEps;
    346            
    347            USBTIMER_Init();
   \   00000006   0x.... 0x....      BL       USBTIMER_Init
    348            
    349            MEMSET( dev, 0, sizeof( USBD_Device_TypeDef ) );
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable22_6
   \   0000000E   0x6828             LDR      R0,[R5, #+0]
   \   00000010   0x22F0             MOVS     R2,#+240
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       halCommonMemSet
    350          
    351            dev->setup                = dev->setupPkt;
   \   00000018   0x6828             LDR      R0,[R5, #+0]
    352            dev->deviceDescriptor     = p->deviceDescriptor;
    353            dev->configDescriptor     = (USB_ConfigurationDescriptor_TypeDef*)
    354                                        p->configDescriptor;
    355            dev->stringDescriptors    = p->stringDescriptors;
    356            dev->numberOfStrings      = p->numberOfStrings;
    357            dev->state                = USBD_STATE_LASTMARKER;
    358            dev->savedState           = USBD_STATE_NONE;
    359            dev->lastState            = USBD_STATE_NONE;
    360            dev->callbacks            = p->callbacks;
    361            #if USB_REMOTEWKUPEN_STATE
    362            dev->remoteWakeupEnabled  = true;
    363            #else
    364            dev->remoteWakeupEnabled  = false;
    365            #endif
    366          
    367          
    368            /* Initialize EP0 */
    369          
    370            ep                 = &dev->ep[ 0 ];
    371            ep->in             = false;
    372            ep->buf            = NULL;
    373            ep->num            = 0;
    374            ep->mask           = 1;
    375            ep->addr           = 0;
    376            ep->type           = USB_EPTYPE_CTRL;
    377            ep->txFifoNum      = 0;
    378            ep->packetSize     = USB_EP0_SIZE;
    379            ep->remaining      = 0;
    380            ep->xferred        = 0;
    381            ep->state          = D_EP_IDLE;
    382            ep->xferCompleteCb = NULL;
    383            ep->fifoSize       = USB_EP0_SIZE / 4;
    384          
    385            totalTxFifoSize = ep->fifoSize * p->bufferingMultiplier[ 0 ];
    386            totalRxFifoSize = (ep->fifoSize + 1) * p->bufferingMultiplier[ 0 ];
    387            
    388            /* Parse configuration decriptor */
    389            numEps = 0;
    390            numInEps  = 0;
    391            numOutEps = 0;
    392            conf = (uint8_t*)dev->configDescriptor;
    393            confEnd = conf + dev->configDescriptor->wTotalLength;
    394          
    395            txFifoNum = 1;
   \   0000001A   0x.... 0x....      ADR.W    R9,?_7
   \   0000001E   0x1D01             ADDS     R1,R0,#+4
   \   00000020   0x6001             STR      R1,[R0, #+0]
   \   00000022   0x2207             MOVS     R2,#+7
   \   00000024   0x9902             LDR      R1,[SP, #+8]
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x6241             STR      R1,[R0, #+36]
   \   0000002A   0xF04F 0x0B01      MOV      R11,#+1
   \   0000002E   0x9902             LDR      R1,[SP, #+8]
   \   00000030   0x6849             LDR      R1,[R1, #+4]
   \   00000032   0x6281             STR      R1,[R0, #+40]
   \   00000034   0x2600             MOVS     R6,#+0
   \   00000036   0x9902             LDR      R1,[SP, #+8]
   \   00000038   0x6889             LDR      R1,[R1, #+8]
   \   0000003A   0x62C1             STR      R1,[R0, #+44]
   \   0000003C   0x46DA             MOV      R10,R11
   \   0000003E   0x9902             LDR      R1,[SP, #+8]
   \   00000040   0x7B09             LDRB     R1,[R1, #+12]
   \   00000042   0x7781             STRB     R1,[R0, #+30]
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0xF100 0x011D      ADD      R1,R0,#+29
   \   0000004A   0x708A             STRB     R2,[R1, #+2]
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x70CA             STRB     R2,[R1, #+3]
   \   00000050   0x710A             STRB     R2,[R1, #+4]
   \   00000052   0x4617             MOV      R7,R2
   \   00000054   0x9902             LDR      R1,[SP, #+8]
   \   00000056   0x6949             LDR      R1,[R1, #+20]
   \   00000058   0x6301             STR      R1,[R0, #+48]
   \   0000005A   0x7742             STRB     R2,[R0, #+29]
   \   0000005C   0xF800 0x2F34      STRB     R2,[R0, #+52]!
   \   00000060   0x6082             STR      R2,[R0, #+8]
   \   00000062   0x7082             STRB     R2,[R0, #+2]
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x81C1             STRH     R1,[R0, #+14]
   \   00000068   0x70C2             STRB     R2,[R0, #+3]
   \   0000006A   0x7102             STRB     R2,[R0, #+4]
   \   0000006C   0x7142             STRB     R2,[R0, #+5]
   \   0000006E   0x2108             MOVS     R1,#+8
   \   00000070   0x8181             STRH     R1,[R0, #+12]
   \   00000072   0x6102             STR      R2,[R0, #+16]
   \   00000074   0x6142             STR      R2,[R0, #+20]
   \   00000076   0xF880 0x2020      STRB     R2,[R0, #+32]
   \   0000007A   0x6242             STR      R2,[R0, #+36]
   \   0000007C   0x2102             MOVS     R1,#+2
   \   0000007E   0x61C1             STR      R1,[R0, #+28]
   \   00000080   0x4690             MOV      R8,R2
   \   00000082   0x6828             LDR      R0,[R5, #+0]
   \   00000084   0x6A84             LDR      R4,[R0, #+40]
   \   00000086   0x8860             LDRH     R0,[R4, #+2]
   \   00000088   0x1900             ADDS     R0,R0,R4
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0xE015             B.N      ??USBD_Init_0
    396          
    397          
    398            #ifdef USB_DEBUG
    399            // DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"ep-->\tin\ttype\tpacketSize\r\n");
    400            #endif
    401            
    402            while ( conf < confEnd )
    403            {
    404              // USBD_Init(), Illegal configuration descriptor
    405              assert (*conf);
    406          
    407              if ( *(conf + 1) == USB_ENDPOINT_DESCRIPTOR )
    408              {
    409                numEps++;
    410                epd = (USB_EndpointDescriptor_TypeDef*)conf;
    411          
    412                
    413                ep                 = &dev->ep[ numEps ];
    414                ep->in             = ( epd->bEndpointAddress & USB_SETUP_DIR_MASK ) != 0;
    415                ep->buf            = NULL;
    416                ep->addr           = epd->bEndpointAddress;
    417                ep->num            = ep->addr & USB_EPNUM_MASK;
    418                ep->mask           = 1 << ep->num;
    419                ep->type           = epd->bmAttributes & CONFIG_DESC_BM_TRANSFERTYPE;
    420                ep->packetSize     = epd->wMaxPacketSize;
    421                ep->remaining      = 0;
    422                ep->xferred        = 0;
    423                ep->state          = D_EP_IDLE;
    424                ep->xferCompleteCb = NULL;
    425          
    426          
    427                if ( ep->in )
    428                {
    429                  numInEps++;
    430                  ep->txFifoNum = txFifoNum++;
    431                  ep->fifoSize = (ep->packetSize/4) * p->bufferingMultiplier[ numEps ];
    432                  dev->inEpAddr2EpIndex[ ep->num ] = numEps;
    433                  totalTxFifoSize += ep->fifoSize;
    434          
    435                  // USBD_Init(), Illegal IN EP address
    436                  assert (ep->num < MAX_NUM_IN_EPS);
    437          
    438                }
    439                else
    440                {
    441                  numOutEps++;
    442                  ep->fifoSize = (ep->packetSize/4 + 1) * p->bufferingMultiplier[ numEps ];
   \                     ??USBD_Init_1: (+1)
   \   0000008E   0x9B02             LDR      R3,[SP, #+8]
   \   00000090   0x691B             LDR      R3,[R3, #+16]
   \   00000092   0x5CF3             LDRB     R3,[R6, R3]
   \   00000094   0x0892             LSRS     R2,R2,#+2
   \   00000096   0x1C52             ADDS     R2,R2,#+1
   \   00000098   0x435A             MULS     R2,R3,R2
   \   0000009A   0x61C2             STR      R2,[R0, #+28]
   \   0000009C   0xF108 0x0801      ADD      R8,R8,#+1
    443                  dev->outEpAddr2EpIndex[ ep->num ] = numEps;
   \   000000A0   0x682A             LDR      R2,[R5, #+0]
   \   000000A2   0x1889             ADDS     R1,R1,R2
   \   000000A4   0xF881 0x60E1      STRB     R6,[R1, #+225]
    444                  totalRxFifoSize += ep->fifoSize;
    445                  
    446                  // USBD_Init(), Illegal OUT EP address
    447                  assert (ep->num < MAX_NUM_OUT_EPS);
   \   000000A8   0x7880             LDRB     R0,[R0, #+2]
   \   000000AA   0x2806             CMP      R0,#+6
   \   000000AC   0xDB03             BLT.N    ??CrossCallReturnLabel_22
   \   000000AE   0xF240 0x11BF      MOVW     R1,#+447
    448                }
   \                     ??USBD_Init_2: (+1)
   \   000000B2   0x.... 0x....      BL       ?Subroutine5
    449              }
    450              conf += *conf;
   \                     ??CrossCallReturnLabel_22: (+1)
   \   000000B6   0x7820             LDRB     R0,[R4, #+0]
   \   000000B8   0x1904             ADDS     R4,R0,R4
   \                     ??USBD_Init_0: (+1)
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   \   000000BC   0x4284             CMP      R4,R0
   \   000000BE   0xD23F             BCS.N    ??USBD_Init_3
   \   000000C0   0x7820             LDRB     R0,[R4, #+0]
   \   000000C2   0xB918             CBNZ.N   R0,??CrossCallReturnLabel_21
   \   000000C4   0xF240 0x1195      MOVW     R1,#+405
   \   000000C8   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_21: (+1)
   \   000000CC   0x7860             LDRB     R0,[R4, #+1]
   \   000000CE   0x2805             CMP      R0,#+5
   \   000000D0   0xD1F1             BNE.N    ??CrossCallReturnLabel_22
   \   000000D2   0x6828             LDR      R0,[R5, #+0]
   \   000000D4   0x1C76             ADDS     R6,R6,#+1
   \   000000D6   0x2128             MOVS     R1,#+40
   \   000000D8   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000000DC   0x78A1             LDRB     R1,[R4, #+2]
   \   000000DE   0x09C9             LSRS     R1,R1,#+7
   \   000000E0   0xF800 0x1F34      STRB     R1,[R0, #+52]!
   \   000000E4   0x2300             MOVS     R3,#+0
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x6081             STR      R1,[R0, #+8]
   \   000000EA   0x78A1             LDRB     R1,[R4, #+2]
   \   000000EC   0x70C1             STRB     R1,[R0, #+3]
   \   000000EE   0xF001 0x010F      AND      R1,R1,#0xF
   \   000000F2   0x7081             STRB     R1,[R0, #+2]
   \   000000F4   0xFA0A 0xF201      LSL      R2,R10,R1
   \   000000F8   0x81C2             STRH     R2,[R0, #+14]
   \   000000FA   0x78E2             LDRB     R2,[R4, #+3]
   \   000000FC   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000100   0x7102             STRB     R2,[R0, #+4]
   \   00000102   0x88A2             LDRH     R2,[R4, #+4]
   \   00000104   0x8182             STRH     R2,[R0, #+12]
   \   00000106   0x6103             STR      R3,[R0, #+16]
   \   00000108   0x6143             STR      R3,[R0, #+20]
   \   0000010A   0xF880 0x3020      STRB     R3,[R0, #+32]
   \   0000010E   0x6243             STR      R3,[R0, #+36]
   \   00000110   0x7803             LDRB     R3,[R0, #+0]
   \   00000112   0x2B00             CMP      R3,#+0
   \   00000114   0xD0BB             BEQ.N    ??USBD_Init_1
   \   00000116   0xF880 0xB005      STRB     R11,[R0, #+5]
   \   0000011A   0x1C7F             ADDS     R7,R7,#+1
   \   0000011C   0x9B02             LDR      R3,[SP, #+8]
   \   0000011E   0x691B             LDR      R3,[R3, #+16]
   \   00000120   0x5CF3             LDRB     R3,[R6, R3]
   \   00000122   0x0892             LSRS     R2,R2,#+2
   \   00000124   0x435A             MULS     R2,R3,R2
   \   00000126   0x61C2             STR      R2,[R0, #+28]
   \   00000128   0xF10B 0x0B01      ADD      R11,R11,#+1
   \   0000012C   0x682A             LDR      R2,[R5, #+0]
   \   0000012E   0x1889             ADDS     R1,R1,R2
   \   00000130   0xF881 0x60D4      STRB     R6,[R1, #+212]
   \   00000134   0x7880             LDRB     R0,[R0, #+2]
   \   00000136   0x2806             CMP      R0,#+6
   \   00000138   0xDBBD             BLT.N    ??CrossCallReturnLabel_22
   \   0000013A   0xF44F 0x71DA      MOV      R1,#+436
   \   0000013E   0xE7B8             B.N      ??USBD_Init_2
    451          
    452            }
    453          
    454            /* Rx-FIFO size: SETUP packets : 4*n + 6    n=#CTRL EP's
    455             *               GOTNAK        : 1
    456             *               Status info   : 2*n        n=#OUT EP's (EP0 included) in HW
    457             */
    458            totalRxFifoSize += 10 + 1 + ( 2 * (MAX_NUM_OUT_EPS + 1) );
    459          
    460            // USBD_Init(), Illegal EP count
    461            assert(numEps == NUM_EP_USED);
   \                     ??USBD_Init_3: (+1)
   \   00000140   0x2E03             CMP      R6,#+3
   \   00000142   0xD003             BEQ.N    ??CrossCallReturnLabel_20
   \   00000144   0xF240 0x11CD      MOVW     R1,#+461
   \   00000148   0x.... 0x....      BL       ?Subroutine5
    462          
    463            // USBD_Init(), Illegal IN EP count
    464            assert (numInEps < MAX_NUM_IN_EPS);
   \                     ??CrossCallReturnLabel_20: (+1)
   \   0000014C   0x2F06             CMP      R7,#+6
   \   0000014E   0xD303             BCC.N    ??CrossCallReturnLabel_19
   \   00000150   0xF44F 0x71E8      MOV      R1,#+464
   \   00000154   0x.... 0x....      BL       ?Subroutine5
    465          
    466            // USBD_Init(), Illegal OUT EP count
    467            assert (numOutEps < MAX_NUM_OUT_EPS);
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000158   0xF1B8 0x0F06      CMP      R8,#+6
   \   0000015C   0xD303             BCC.N    ??CrossCallReturnLabel_18
   \   0000015E   0xF240 0x11D3      MOVW     R1,#+467
   \   00000162   0x.... 0x....      BL       ?Subroutine5
    468          
    469            DECLARE_INTERRUPT_STATE;
    470            DISABLE_INTERRUPTS();
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000166   0x.... 0x....      BL       _disableBasePri
   \   0000016A   0x4604             MOV      R4,R0
    471          
    472            USBHAL_DisableGlobalInt();
   \   0000016C   0x.... 0x....      BL       USBHAL_DisableGlobalInt
    473          
    474            if ( USBDHAL_CoreInit( 1, 1 ) == USB_STATUS_OK )
   \   00000170   0x2101             MOVS     R1,#+1
   \   00000172   0x4608             MOV      R0,R1
   \   00000174   0x.... 0x....      BL       USBDHAL_CoreInit
   \   00000178   0xB968             CBNZ.N   R0,??USBD_Init_4
    475            {
    476              USBDHAL_EnableUsbResetInt();
   \   0000017A   0x....             LDR.N    R1,??DataTable22_1  ;; 0x4000a888
   \   0000017C   0x....             LDR.N    R2,??DataTable22_10  ;; 0xe000e100
   \   0000017E   0x....             LDR.N    R3,??DataTable22_7  ;; 0x4001104c
   \   00000180   0x6048             STR      R0,[R1, #+4]
   \   00000182   0xF04F 0x30FF      MOV      R0,#-1
   \   00000186   0x6008             STR      R0,[R1, #+0]
   \   00000188   0x....             LDR.N    R0,??DataTable22_11  ;; 0xf00081
   \   0000018A   0x6048             STR      R0,[R1, #+4]
    477              USBHAL_EnableGlobalInt();
   \   0000018C   0xF44F 0x2000      MOV      R0,#+524288
   \   00000190   0x6010             STR      R0,[R2, #+0]
    478          
    479              // NVIC_ClearPendingIRQ( USB_IRQn );
    480              // NVIC_EnableIRQ( USB_IRQn );
    481            }
    482            else
    483            {
    484          
    485              RESTORE_INTERRUPTS();
    486            //   USBD_Init(), FIFO setup error
    487              assert(0);
    488              return USB_STATUS_ILLEGAL;
    489            }
    490          
    491            /* Enable EPs */
    492            uint8_t i;
    493            for (i=1;i<=numEps;i++)
   \   00000192   0x2201             MOVS     R2,#+1
   \   00000194   0xE016             B.N      ??USBD_Init_5
   \                     ??USBD_Init_4: (+1)
   \   00000196   0x4620             MOV      R0,R4
   \   00000198   0x.... 0x....      BL       _writeBasePri
   \   0000019C   0xF240 0x11E7      MOVW     R1,#+487
   \   000001A0   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_17: (+1)
   \   000001A4   0xF06F 0x0003      MVN      R0,#+3
   \   000001A8   0xE028             B.N      ??USBD_Init_6
    494            {
    495          
    496              #ifdef USB_DEBUG
    497              // DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"EP%d\t%d\t%d\t%d\r\n",i,ep->in,ep->type,ep->packetSize);
    498              #endif
    499              ep = &dev->ep[ i ];
    500              if (ep->in)
    501              {
    502                USB_ENABLEIN  |= USB_ENABLEINEP0 << ep->num;
    503                INT_USBCFG    |= INT_USBTXACTIVEEP0 << ep->num;
    504              }
    505              else
    506              {
    507                USB_ENABLEOUT |= USB_ENABLEOUTEP0 << ep->num;
   \                     ??USBD_Init_7: (+1)
   \   000001AA   0x685F             LDR      R7,[R3, #+4]
   \   000001AC   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_31: (+1)
   \   000001B0   0x605F             STR      R7,[R3, #+4]
    508                INT_USBCFG    |= INT_USBRXVALIDEP0 << ep->num;
   \   000001B2   0xF04F 0x0C80      MOV      R12,#+128
   \   000001B6   0x684F             LDR      R7,[R1, #+4]
   \   000001B8   0x7880             LDRB     R0,[R0, #+2]
   \   000001BA   0xFA0C 0xF000      LSL      R0,R12,R0
   \                     ??USBD_Init_8: (+1)
   \   000001BE   0x4338             ORRS     R0,R0,R7
   \   000001C0   0x6048             STR      R0,[R1, #+4]
    509              }
   \   000001C2   0x1C52             ADDS     R2,R2,#+1
   \                     ??USBD_Init_5: (+1)
   \   000001C4   0xB2D2             UXTB     R2,R2
   \   000001C6   0x4610             MOV      R0,R2
   \   000001C8   0x4286             CMP      R6,R0
   \   000001CA   0xDB11             BLT.N    ??USBD_Init_9
   \   000001CC   0x682F             LDR      R7,[R5, #+0]
   \   000001CE   0xF04F 0x0C28      MOV      R12,#+40
   \   000001D2   0xFB0C 0x7000      MLA      R0,R12,R0,R7
   \   000001D6   0xF810 0x7F34      LDRB     R7,[R0, #+52]!
   \   000001DA   0x2F00             CMP      R7,#+0
   \   000001DC   0xD0E5             BEQ.N    ??USBD_Init_7
   \   000001DE   0x681F             LDR      R7,[R3, #+0]
   \   000001E0   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_32: (+1)
   \   000001E4   0x601F             STR      R7,[R3, #+0]
   \   000001E6   0x684F             LDR      R7,[R1, #+4]
   \   000001E8   0x7880             LDRB     R0,[R0, #+2]
   \   000001EA   0xFA0A 0xF000      LSL      R0,R10,R0
   \   000001EE   0xE7E6             B.N      ??USBD_Init_8
    510            }
    511          
    512            /* Connect USB */
    513            USBDHAL_Connect();
   \                     ??USBD_Init_9: (+1)
   \   000001F0   0x.... 0x....      BL       USBDHAL_Connect
    514          
    515            RESTORE_INTERRUPTS();
   \   000001F4   0x4620             MOV      R0,R4
   \   000001F6   0x.... 0x....      BL       _writeBasePri
    516            return USB_STATUS_OK;
   \   000001FA   0x2000             MOVS     R0,#+0
   \                     ??USBD_Init_6: (+1)
   \   000001FC   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    517          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0xF890 0xC002      LDRB     R12,[R0, #+2]
   \   00000004   0xFA0A 0xFC0C      LSL      R12,R10,R12
   \   00000008   0xEA4C 0x0707      ORR      R7,R12,R7
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4648             MOV      R0,R9
   \   00000002   0x.... 0x....      B.W      halInternalAssertFailed
    518          
    519          /***************************************************************************//**
    520           * @brief
    521           *   Start a write (IN) transfer on an endpoint.
    522           *
    523           * @param[in] epAddr
    524           *   Endpoint address.
    525           *
    526           * @param[in] data
    527           *   Pointer to transfer data buffer. This buffer must be WORD (4 byte) aligned.
    528           *
    529           * @param[in] byteCount
    530           *   Transfer length.
    531           *
    532           * @param[in] callback
    533           *   Function to be called on transfer completion. Supply NULL if no callback
    534           *   is needed. See @ref USB_XferCompleteCb_TypeDef.
    535           *
    536           * @return
    537           *   @ref USB_STATUS_OK on success, else an appropriate error code.
    538           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    539          int USBD_Write( int epAddr, void *data, int byteCount,
    540                          USB_XferCompleteCb_TypeDef callback )
    541          {
   \                     USBD_Write: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x.... 0x....      BL       ?Subroutine2
    542            #ifdef USB_DEBUG_WRITE
    543            DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "USBD_Write:%d\r\n",byteCount);
    544            #endif
    545          
    546            USBD_Ep_TypeDef *ep = USBD_GetEpFromAddr( epAddr );
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000008   0x0007             MOVS     R7,R0
    547          
    548            if ( ep == NULL )
   \   0000000A   0x.... 0x....      ADR.W    R8,?_7
   \   0000000E   0xD106             BNE.N    ??USBD_Write_0
    549            {
    550              #ifdef USB_DEBUG_WRITE
    551              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "USBD_Write(), Illegal endpoint\r\n");
    552              #endif
    553              // USBD_Write(), Illegal endpoint
    554              assert( 0 );
   \   00000010   0xF240 0x212A      MOVW     R1,#+554
   \   00000014   0x.... 0x....      BL       ?Subroutine6
    555              return USB_STATUS_ILLEGAL;
   \                     ??CrossCallReturnLabel_28: (+1)
   \   00000018   0xF06F 0x0003      MVN      R0,#+3
   \   0000001C   0xE03B             B.N      ??USBD_Write_1
    556            }
    557          
    558            // USBD_Write(), Illegal transfer size
    559            // assert ((byteCount < MAX_XFER_LEN) && ((byteCount / ep->packetSize) < MAX_PACKETS_PR_XFER));
    560          
    561            // USBD_Write(), Misaligned data buffer
    562            if (data!=NULL)
   \                     ??USBD_Write_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xBF18             IT       NE 
   \   00000022   0xF014 0x0003      ANDSNE   R0,R4,#0x3
    563             assert(!((uint32_t)data & 3));
   \   00000026   0xD003             BEQ.N    ??CrossCallReturnLabel_27
   \   00000028   0xF240 0x2133      MOVW     R1,#+563
   \   0000002C   0x.... 0x....      BL       ?Subroutine6
    564          
    565            DECLARE_INTERRUPT_STATE;
    566            DISABLE_INTERRUPTS();
   \                     ??CrossCallReturnLabel_27: (+1)
   \   00000030   0x.... 0x....      BL       _disableBasePri
   \   00000034   0x4681             MOV      R9,R0
    567          
    568            if ( USBDHAL_EpIsStalled( ep ) )
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       USBDHAL_EpIsStalled
   \   0000003C   0xB120             CBZ.N    R0,??USBD_Write_2
    569            {
    570              // INT_Enable();
    571              RESTORE_INTERRUPTS();
   \   0000003E   0x.... 0x....      BL       ?Subroutine4
    572              // USBD_Write(), Endpoint is halted
    573              #ifdef USB_DEBUG_WRITE
    574              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "USBD_Write(), Endpoint is halted\r\n" );
    575              #endif
    576          
    577              return USB_STATUS_EP_STALLED;
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000042   0xF06F 0x0004      MVN      R0,#+4
   \   00000046   0xE026             B.N      ??USBD_Write_1
    578            }
    579          
    580            if ( ep->state != D_EP_IDLE )
   \                     ??USBD_Write_2: (+1)
   \   00000048   0xF897 0x0020      LDRB     R0,[R7, #+32]
   \   0000004C   0xB120             CBZ.N    R0,??USBD_Write_3
    581            {
    582              RESTORE_INTERRUPTS();
   \   0000004E   0x.... 0x....      BL       ?Subroutine4
    583              #ifdef USB_DEBUG_WRITE
    584              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "USBD_Write(), Endpoint is busy\r\n");
    585              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "ep->state = %d\r\n",ep->state);
    586              #endif
    587              return USB_STATUS_EP_BUSY;
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000052   0xF06F 0x0001      MVN      R0,#+1
   \   00000056   0xE01E             B.N      ??USBD_Write_1
    588            }
    589          
    590            if ( ( ep->num > 0 ) && ( USBD_GetUsbState() != USBD_STATE_CONFIGURED ) )
   \                     ??USBD_Write_3: (+1)
   \   00000058   0x78B8             LDRB     R0,[R7, #+2]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xBF1F             ITTTT    NE 
   \   0000005E   0x....             LDRNE.N  R0,??DataTable22_6
   \   00000060   0x6800             LDRNE    R0,[R0, #+0]
   \   00000062   0x7FC0             LDRBNE   R0,[R0, #+31]
   \   00000064   0x2804             CMPNE    R0,#+4
   \   00000066   0xD004             BEQ.N    ??USBD_Write_4
    591            {
    592              #ifdef USB_DEBUG_WRITE
    593              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "USBD_Write(), Device not configured\r\n");
    594              #endif
    595              RESTORE_INTERRUPTS();
   \   00000068   0x.... 0x....      BL       ?Subroutine4
    596              return USB_STATUS_DEVICE_UNCONFIGURED;
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000006C   0xF06F 0x0008      MVN      R0,#+8
   \   00000070   0xE011             B.N      ??USBD_Write_1
    597            }
    598          
    599                
    600            //if data is null, this is a zero length packet
    601            if (data == NULL)
    602            {
    603              ep->buf = NULL;
    604            }
    605            else
    606            {
    607              ep->buf = (uint8_t*)data;
   \                     ??USBD_Write_4: (+1)
   \   00000072   0x.... 0x....      BL       ?Subroutine9
    608            }
    609          
    610            ep->remaining = byteCount;
    611            ep->xferred   = 0;
    612          
    613            
    614            if ( ep->num == 0 )
   \                     ??CrossCallReturnLabel_33: (+1)
   \   00000076   0xB910             CBNZ.N   R0,??USBD_Write_5
    615            {
    616              ep->in = true;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x7038             STRB     R0,[R7, #+0]
   \   0000007C   0xE005             B.N      ??CrossCallReturnLabel_26
    617            }
    618            // USBD_Write(), Illegal EP direction
    619            assert (ep->in == true);
   \                     ??USBD_Write_5: (+1)
   \   0000007E   0x7838             LDRB     R0,[R7, #+0]
   \   00000080   0xB918             CBNZ.N   R0,??CrossCallReturnLabel_26
   \   00000082   0xF240 0x216B      MOVW     R1,#+619
   \   00000086   0x.... 0x....      BL       ?Subroutine6
    620            
    621            ep->state          = D_EP_TRANSMITTING;
   \                     ??CrossCallReturnLabel_26: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      BL       ?Subroutine7
    622            ep->xferCompleteCb = callback;
    623          
    624            // kickoff USB transfer
    625            USBD_ArmEp( ep );
    626            RESTORE_INTERRUPTS();
   \                     ??CrossCallReturnLabel_30: (+1)
   \   00000090   0x.... 0x....      BL       ?Subroutine4
    627            
    628            return USB_STATUS_OK;
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \                     ??USBD_Write_1: (+1)
   \   00000096   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    629            
    630          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x60BC             STR      R4,[R7, #+8]
   \   00000002   0x613D             STR      R5,[R7, #+16]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6178             STR      R0,[R7, #+20]
   \   00000008   0x78B8             LDRB     R0,[R7, #+2]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF887 0x0020      STRB     R0,[R7, #+32]
   \   00000004   0x627E             STR      R6,[R7, #+36]
   \   00000006   0x4638             MOV      R0,R7
   \   00000008   0x....             B.N      USBD_ArmEp

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x4640             MOV      R0,R8
   \   00000002   0x.... 0x....      B.W      halInternalAssertFailed

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x4648             MOV      R0,R9
   \   00000002   0x.... 0x....      B.W      _writeBasePri
    631          
    632          /***************************************************************************//**
    633           * @brief
    634           *   Start a read (OUT) transfer on an endpoint.
    635           *
    636           * @note
    637           *   The transfer buffer length must be a multiple of 4 bytes in length and
    638           *   WORD (4 byte) aligned. When allocating the buffer, round buffer length up.
    639           *   If it is possible that the host will send more data than your device
    640           *   expects, round buffer size up to the next multiple of maxpacket size.
    641           *
    642           * @param[in] epAddr
    643           *   Endpoint address.
    644           *
    645           * @param[in] data
    646           *   Pointer to transfer data buffer.
    647           *
    648           * @param[in] byteCount
    649           *   Transfer length.
    650           *
    651           * @param[in] callback
    652           *   Function to be called on transfer completion. Supply NULL if no callback
    653           *   is needed. See @ref USB_XferCompleteCb_TypeDef.
    654           *
    655           * @return
    656           *   @ref USB_STATUS_OK on success, else an appropriate error code.
    657           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    658          int USBD_Read( int epAddr, void *data, int byteCount,
    659                         USB_XferCompleteCb_TypeDef callback )
    660          {
   \                     USBD_Read: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x.... 0x....      BL       ?Subroutine2
    661          
    662            USBD_Ep_TypeDef *ep = USBD_GetEpFromAddr( epAddr );
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000008   0x0007             MOVS     R7,R0
    663          
    664            #ifdef USB_DEBUG_READ
    665            DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "USBD_Read:%X - %d\r\nep->in=%d\r\n", epAddr, ep->num, ep->in);
    666            #endif
    667          
    668            assert (ep!=NULL);
   \   0000000A   0x.... 0x....      ADR.W    R8,?_7
   \   0000000E   0xD103             BNE.N    ??CrossCallReturnLabel_25
   \   00000010   0xF44F 0x7127      MOV      R1,#+668
   \   00000014   0x.... 0x....      BL       ?Subroutine6
    669          
    670          
    671            // assert ((byteCount < MAX_XFER_LEN) && ((byteCount/ep->packetSize) < MAX_PACKETS_PR_XFER));
    672          
    673          
    674            if (data!=NULL)
   \                     ??CrossCallReturnLabel_25: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0xF014 0x0003      ANDSNE   R0,R4,#0x3
    675              assert (!((uint32_t)data & 3));
   \   00000020   0xD003             BEQ.N    ??CrossCallReturnLabel_24
   \   00000022   0xF240 0x21A3      MOVW     R1,#+675
   \   00000026   0x.... 0x....      BL       ?Subroutine6
    676          
    677          
    678            DECLARE_INTERRUPT_STATE;
    679            DISABLE_INTERRUPTS();
   \                     ??CrossCallReturnLabel_24: (+1)
   \   0000002A   0x.... 0x....      BL       _disableBasePri
   \   0000002E   0x4681             MOV      R9,R0
    680          
    681            if ( USBDHAL_EpIsStalled( ep ) )
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x.... 0x....      BL       USBDHAL_EpIsStalled
   \   00000036   0xB120             CBZ.N    R0,??USBD_Read_0
    682            {
    683              RESTORE_INTERRUPTS();
   \   00000038   0x.... 0x....      BL       ?Subroutine4
    684              #ifdef USB_DEBUG_READ
    685              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "USBD_Read(), Endpoint is halted\r\n" );
    686              #endif
    687              return USB_STATUS_EP_STALLED;
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000003C   0xF06F 0x0004      MVN      R0,#+4
   \   00000040   0xE026             B.N      ??USBD_Read_1
    688            }
    689          
    690            if ( ep->state == D_EP_TRANSMITTING )
   \                     ??USBD_Read_0: (+1)
   \   00000042   0xF897 0x0020      LDRB     R0,[R7, #+32]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD104             BNE.N    ??USBD_Read_2
    691            {
    692              RESTORE_INTERRUPTS();
   \   0000004A   0x.... 0x....      BL       ?Subroutine4
    693              #ifdef USB_DEBUG_READ
    694              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "USBD_Read(), Endpoint is busy\r\n" );
    695              #endif
    696              return USB_STATUS_EP_BUSY;
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000004E   0xF06F 0x0001      MVN      R0,#+1
   \   00000052   0xE01D             B.N      ??USBD_Read_1
    697            }
    698          
    699            if ( ( ep->num > 0 ) && ( USBD_GetUsbState() != USBD_STATE_CONFIGURED ) )
   \                     ??USBD_Read_2: (+1)
   \   00000054   0x78B8             LDRB     R0,[R7, #+2]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xBF1F             ITTTT    NE 
   \   0000005A   0x....             LDRNE.N  R0,??DataTable22_6
   \   0000005C   0x6800             LDRNE    R0,[R0, #+0]
   \   0000005E   0x7FC0             LDRBNE   R0,[R0, #+31]
   \   00000060   0x2804             CMPNE    R0,#+4
   \   00000062   0xD004             BEQ.N    ??USBD_Read_3
    700            {
    701              RESTORE_INTERRUPTS();
   \   00000064   0x.... 0x....      BL       ?Subroutine4
    702              #ifdef USB_DEBUG_READ
    703              DEBUG_BUFFER += sprintf(DEBUG_BUFFER, "\nUSBD_Read(), Device not configured" );
    704              #endif
    705              return USB_STATUS_DEVICE_UNCONFIGURED;
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000068   0xF06F 0x0008      MVN      R0,#+8
   \   0000006C   0xE010             B.N      ??USBD_Read_1
    706            }
    707          
    708            ep->buf       = (uint8_t*)data;
   \                     ??USBD_Read_3: (+1)
   \   0000006E   0x.... 0x....      BL       ?Subroutine9
    709            ep->remaining = byteCount;
    710            ep->xferred   = 0;
    711          
    712          
    713            if ( ep->num == 0 )
   \                     ??CrossCallReturnLabel_34: (+1)
   \   00000072   0xB908             CBNZ.N   R0,??USBD_Read_4
    714            {
    715              ep->in = false;
   \   00000074   0x7038             STRB     R0,[R7, #+0]
   \   00000076   0xE005             B.N      ??CrossCallReturnLabel_23
    716            }
    717          
    718            // USBD_Read(), Illegal EP direction
    719            assert(ep->in == false);
   \                     ??USBD_Read_4: (+1)
   \   00000078   0x7838             LDRB     R0,[R7, #+0]
   \   0000007A   0xB118             CBZ.N    R0,??CrossCallReturnLabel_23
   \   0000007C   0xF240 0x21CF      MOVW     R1,#+719
   \   00000080   0x.... 0x....      BL       ?Subroutine6
    720          
    721            ep->state          = D_EP_RECEIVING;
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x.... 0x....      BL       ?Subroutine7
    722            ep->xferCompleteCb = callback;
    723          
    724            // kickoff USB transfer
    725            USBD_ArmEp( ep );
    726            RESTORE_INTERRUPTS();
   \                     ??CrossCallReturnLabel_29: (+1)
   \   0000008A   0x.... 0x....      BL       ?Subroutine4
    727            return USB_STATUS_OK;
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??USBD_Read_1: (+1)
   \   00000090   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    728          }
    729          
    730          
    731          
    732          /***************************************************************************//**
    733           * @brief
    734           *   USB suspend delayed service routine
    735           *
    736           * @details
    737           *   This function keeps the device in a low power state in order to meet USB
    738           *   specification during USB suspend state.
    739           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    740          void usbSuspendDsr(void)
    741          {
   \                     usbSuspendDsr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    742            if(dev->state == USBD_STATE_SUSPENDED) {
   \   00000002   0x....             LDR.N    R0,??DataTable22_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7FC0             LDRB     R0,[R0, #+31]
   \   00000008   0x2806             CMP      R0,#+6
   \   0000000A   0xD10D             BNE.N    ??usbSuspendDsr_0
    743              
    744              #ifndef EMBER_NO_STACK
    745              emberStackPowerDown();
   \   0000000C   0x.... 0x....      BL       emberStackPowerDown
    746              #endif // EMBER_NO_STACK
    747              // halPowerDown();
    748              halSuspendCallback();
   \   00000010   0x.... 0x....      BL       halSuspendCallback
    749              //Turn idle sleep into USB sleep which divides down all the chip clocks,
    750              //by 4, except system timer.
    751              CPU_CLKSEL |= USBSUSP_CLKSEL_FIELD;
   \   00000014   0x....             LDR.N    R0,??DataTable22_12  ;; 0x40004020
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    752              halSleep(SLEEPMODE_IDLE);
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE8BD 0x4002      POP      {R1,LR}
   \   00000024   0x.... 0x....      B.W      halSleep
    753            }
    754          }
   \                     ??usbSuspendDsr_0: (+1)
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    755          
    756          
    757          
    758          /***************************************************************************//**
    759           * @brief
    760           *   Perform a remote wakeup signalling sequence.
    761           *
    762           * @note
    763           *   It is the responsibility of the application to ensure that remote wakeup
    764           *   is not attempted before the device has been suspended for at least 5
    765           *   miliseconds. This function should not be called from within an interrupt
    766           *   handler.
    767           *
    768           * @return
    769           *   @ref USB_STATUS_OK on success, else an appropriate error code.
    770           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    771          int USBD_RemoteWakeup( void )
    772          {
   \                     USBD_RemoteWakeup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    773            #ifdef USB_DEBUG_SUSPEND
    774              DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"RemoteWakeup...");
    775            #endif
    776          
    777            if ( ( dev->state != USBD_STATE_SUSPENDED ) ||
    778                 ( dev->remoteWakeupEnabled == false  ) )
   \   00000002   0x....             LDR.N    R4,??DataTable22_6
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x7FC1             LDRB     R1,[R0, #+31]
   \   00000008   0x2906             CMP      R1,#+6
   \   0000000A   0xD101             BNE.N    ??USBD_RemoteWakeup_0
   \   0000000C   0x7F40             LDRB     R0,[R0, #+29]
   \   0000000E   0xB910             CBNZ.N   R0,??USBD_RemoteWakeup_1
    779            {
    780              // Not suspend or remote wakeup not enabled
    781              #ifdef USB_DEBUG_SUSPEND
    782                DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"illegal\r\n");
    783              #endif
    784              return USB_STATUS_ILLEGAL;
   \                     ??USBD_RemoteWakeup_0: (+1)
   \   00000010   0xF06F 0x0003      MVN      R0,#+3
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}
    785            }
    786          
    787            USBDHAL_SetRemoteWakeup();
   \                     ??USBD_RemoteWakeup_1: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable22_13  ;; 0x40011068
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    788            uint16_t timeout = 4; // Set for 4 ms. Host should take over within 1 ms
    789            //store start time, compare difference with current time with timeout period
    790            uint16_t startTime = halCommonGetInt16uMillisecondTick();
   \   0000001C   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000020   0x4605             MOV      R5,R0
    791            uint16_t curTime = halCommonGetInt16uMillisecondTick();
    792            while ((elapsedTimeInt16u(startTime, curTime) <= timeout)
    793                   && (dev->state == USBD_STATE_SUSPENDED)) { //exit if USB resumes
    794              curTime = halCommonGetInt16uMillisecondTick();
   \                     ??USBD_RemoteWakeup_2: (+1)
   \   00000022   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x7FC9             LDRB     R1,[R1, #+31]
   \   0000002A   0x1B40             SUBS     R0,R0,R5
   \   0000002C   0xB280             UXTH     R0,R0
   \   0000002E   0x2805             CMP      R0,#+5
   \   00000030   0xDA01             BGE.N    ??USBD_RemoteWakeup_3
   \   00000032   0x2906             CMP      R1,#+6
   \   00000034   0xD0F5             BEQ.N    ??USBD_RemoteWakeup_2
    795            }
    796          
    797            if (dev->state == USBD_STATE_SUSPENDED) { //record failure if USB fails to resume
   \                     ??USBD_RemoteWakeup_3: (+1)
   \   00000036   0x2906             CMP      R1,#+6
   \   00000038   0xD102             BNE.N    ??USBD_RemoteWakeup_4
    798              #ifdef USB_DEBUG_SUSPEND
    799                DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"timed out\r\n");
    800              #endif
    801              return USB_STATUS_TIMEOUT;
   \   0000003A   0xF06F 0x000B      MVN      R0,#+11
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}
    802            }
    803            #ifdef USB_DEBUG_SUSPEND
    804              DEBUG_BUFFER += sprintf(DEBUG_BUFFER,"succeeded\r\n");
    805            #endif
    806          
    807            return USB_STATUS_OK;
   \                     ??USBD_RemoteWakeup_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    808          }
    809          
    810          
    811          // DEBUG buffer with printout function, note buffer has no overflow protection
    812          #ifdef USB_DEBUG
    813          static char debugbuffer[4000];
    814          char *DEBUG_BUFFER = debugbuffer;
    815          
    816          void USBD_PrintDebug(void)
    817          {
    818            debugbuffer[3999] = '\0';
    819            emberSerialGuaranteedPrintf(SER232,debugbuffer);
    820            MEMSET(debugbuffer, 0, 4000);
    821            DEBUG_BUFFER = debugbuffer;
    822          }
    823          #endif
    824          
    825          #if EM_SERIAL3_ENABLED
    826          // interface with serial/uart queues. Enables emberserialprintf

   \                                 In section .text, align 2, keep-with-next
    827          uint8_t dequeueTxIntoBuffer(uint8_t *data)
    828          {
   \                     dequeueTxIntoBuffer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    829            EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[3];
   \   00000002   0x....             LDR.N    R1,??DataTable22_14
    830            uint8_t txSize=0;
   \   00000004   0x....             LDR.N    R3,??DataTable22_15
   \   00000006   0x68CA             LDR      R2,[R1, #+12]
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xE010             B.N      ??dequeueTxIntoBuffer_0
    831            
    832            //If there are bytes in the Q and txSize hasn't maxed out, pull more
    833            //bytes off the Q into the DMA buffer
    834            while((q->used > 0) && (txSize < EP5_SIZE)) {
    835              *data = FIFO_DEQUEUE(q, emSerialTxQueueWraps[3]);
   \                     ??dequeueTxIntoBuffer_1: (+1)
   \   0000000C   0x8854             LDRH     R4,[R2, #+2]
   \   0000000E   0x18A4             ADDS     R4,R4,R2
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \   00000012   0x79A4             LDRB     R4,[R4, #+6]
   \   00000014   0xF800 0x4B01      STRB     R4,[R0], #+1
   \   00000018   0x8854             LDRH     R4,[R2, #+2]
   \   0000001A   0x88DD             LDRH     R5,[R3, #+6]
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \   0000001E   0xFB94 0xF6F5      SDIV     R6,R4,R5
   \   00000022   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   00000026   0x8054             STRH     R4,[R2, #+2]
   \   00000028   0x8894             LDRH     R4,[R2, #+4]
   \   0000002A   0x1E64             SUBS     R4,R4,#+1
   \   0000002C   0x8094             STRH     R4,[R2, #+4]
    836              data++;
    837              txSize++;
    838            }
   \                     ??dequeueTxIntoBuffer_0: (+1)
   \   0000002E   0x8894             LDRH     R4,[R2, #+4]
   \   00000030   0xB114             CBZ.N    R4,??dequeueTxIntoBuffer_2
   \   00000032   0xB2C9             UXTB     R1,R1
   \   00000034   0x2940             CMP      R1,#+64
   \   00000036   0xDBE9             BLT.N    ??dequeueTxIntoBuffer_1
    839            
    840            return txSize;
   \                     ??dequeueTxIntoBuffer_2: (+1)
   \   00000038   0xB2C8             UXTB     R0,R1
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    841          }
    842          
    843          // interface with serial/uart queues. Enables emberSerialPrintf. 
    844          // EP_IN must be defined. Assumes EP1 size, 8 bytes, which may be larger
    845          // depending on endpoint.

   \                                 In section .text, align 2, keep-with-next
    846          void usbTxData ()
    847          {
   \                     usbTxData: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
    848            if (!USBD_EpIsBusy(EP_IN))
   \   00000004   0x2085             MOVS     R0,#+133
   \   00000006   0x.... 0x....      BL       USBD_EpIsBusy
   \   0000000A   0xB948             CBNZ.N   R0,??usbTxData_0
    849            {
    850              uint8_t data[EP5_SIZE];
    851              uint8_t txSize = dequeueTxIntoBuffer(data);
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       dequeueTxIntoBuffer
    852              if (txSize>0)
   \   00000012   0xB128             CBZ.N    R0,??usbTxData_0
    853              {
    854                USBD_Write( EP_IN, data, txSize, NULL );
   \   00000014   0x4602             MOV      R2,R0
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0xA900             ADD      R1,SP,#+0
   \   0000001A   0x2085             MOVS     R0,#+133
   \   0000001C   0x.... 0x....      BL       USBD_Write
    855              }
    856            }
    857          }
   \                     ??usbTxData_0: (+1)
   \   00000020   0xB011             ADD      SP,SP,#+68
   \   00000022   0xBD00             POP      {PC}             ;; return
    858          
    859          // interface with serial/uart library. Enables emberSerialGuaranteedPrintf

   \                                 In section .text, align 2, keep-with-next
    860          void usbForceTxData (uint8_t *data, uint8_t length)
    861          {
   \                     usbForceTxData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    862            while (USBD_EpIsBusy(EP_IN)) {}
   \                     ??usbForceTxData_0: (+1)
   \   00000006   0x2085             MOVS     R0,#+133
   \   00000008   0x.... 0x....      BL       USBD_EpIsBusy
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD1FA             BNE.N    ??usbForceTxData_0
    863            USBD_Write( EP_IN, data, length, NULL );
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x462A             MOV      R2,R5
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x2085             MOVS     R0,#+133
   \   00000018   0x.... 0x....      BL       USBD_Write
    864            while (USBD_EpIsBusy(EP_IN)) {}
   \                     ??usbForceTxData_1: (+1)
   \   0000001C   0x2085             MOVS     R0,#+133
   \   0000001E   0x.... 0x....      BL       USBD_EpIsBusy
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1FA             BNE.N    ??usbForceTxData_1
    865          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x4000A888         DC32     0x4000a888

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x40011054         DC32     0x40011054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x40011008         DC32     0x40011008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x........         DC32     EPINBUF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x........         DC32     EPINBUFSIZE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x........         DC32     dev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0x4001104C         DC32     0x4001104c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0x4000A88C         DC32     0x4000a88c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0x........         DC32     stateNames

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \   00000000   0x00F00081         DC32     0xf00081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \   00000000   0x40004020         DC32     0x40004020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \   00000000   0x40011068         DC32     0x40011068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \   00000000   0x........         DC32     emSerialTxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_15:
   \   00000000   0x........         DC32     emSerialTxQueueWraps

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x4E 0x4F          DC8 "NONE      "
   \              0x4E 0x45    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x41 0x54          DC8 "ATTACHED  "
   \              0x54 0x41    
   \              0x43 0x48    
   \              0x45 0x44    
   \              0x20 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x50 0x4F          DC8 "POWERED   "
   \              0x57 0x45    
   \              0x52 0x45    
   \              0x44 0x20    
   \              0x20 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x44 0x45          DC8 "DEFAULT   "
   \              0x46 0x41    
   \              0x55 0x4C    
   \              0x54 0x20    
   \              0x20 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x43 0x4F          DC8 "CONFIGURED"
   \              0x4E 0x46    
   \              0x49 0x47    
   \              0x55 0x52    
   \              0x45 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x53 0x55          DC8 "SUSPENDED "
   \              0x53 0x50    
   \              0x45 0x4E    
   \              0x44 0x45    
   \              0x44 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x55 0x4E          DC8 "UNDEFINED "
   \              0x44 0x45    
   \              0x46 0x49    
   \              0x4E 0x45    
   \              0x44 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x65 0x6D          DC8 "em_usbd.c"
   \              0x5F 0x75    
   \              0x73 0x62    
   \              0x64 0x2E    
   \              0x63 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0
    866          
    867          #endif //EM_SERIAL3_ENABLED
    868          
    869          /** @} (end addtogroup USB_DEVICE) */
    870          
    871          /******** THE REST OF THE FILE IS DOCUMENTATION ONLY !**********************//**
    872           * @addtogroup usb @{
    873          
    874            The source files for the USB device stack resides in the usb directory
    875            and follows the naming convention: em_usbd<em>nnn</em>.c/h.
    876          
    877            @li @ref usb_device_intro
    878            @li @ref usb_device_api
    879            @li @ref usb_device_conf
    880          
    881          @n @section usb_device_intro Introduction
    882          
    883            The USB device protocol stack provides an API which makes it possible to
    884            create USB devices with a minimum of effort. The device stack supports control,
    885            bulk and interrupt transfers.
    886          
    887            The stack is highly configurable to suit various needs, it does also contain
    888            useful debugging features together with several demonstration projects to
    889            get you started fast.
    890          
    891            We recommend that you read through this documentation, then proceed to build
    892            and test a few example projects before you start designing your own device.
    893          
    894          @n @section usb_device_api The device stack API
    895          
    896            This section contains brief descriptions of the functions in the API. You will
    897            find detailed information on input and output parameters and return values by
    898            clicking on the hyperlinked function names. It is also a good idea to study
    899            the code in the USB demonstration projects.
    900          
    901            Your application code must include one header file: @em em_usb.h.
    902          
    903            All functions defined in the API can be called from within interrupt handlers.
    904          
    905            <b>Pitfalls:</b>@n
    906              The USB peripheral will fill your receive buffers in quantities of WORD's
    907              (4 bytes). Transmit and receive buffers must be WORD aligned, in
    908              addition when allocating storage for receive buffers, round size up to
    909              next WORD boundary. If it is possible that the host will send more data
    910              than your device expects, round buffer size up to the next multiple of
    911              maxpacket size for the relevant endpoint to avoid data corruption.
    912          
    913              Transmit buffers passed to @htmlonly USBD_Write() @endhtmlonly must be
    914              statically allocated because @htmlonly USBD_Write() @endhtmlonly only
    915              initiates the transfer. When the host decide to actually perform the
    916              transfer, your data must be available.
    917          
    918            @n @ref USBD_Init() @n
    919              This function is called to register your device and all its properties with
    920              the device stack. The application must fill in a @ref USBD_Init_TypeDef
    921              structure prior to calling. Refer to @ref DeviceInitCallbacks for the
    922              optional callback functions defined within this structure. When this
    923              function has been called your device is ready to be enumerated by the USB
    924              host.
    925          
    926            @ref USBD_Read(), @ref USBD_Write() @n
    927              These functions initiate data transfers.
    928              @n @htmlonly USBD_Read() @endhtmlonly initiate a transfer of data @em
    929              from host @em to device (an @em OUT transfer in USB terminology).
    930              @n @htmlonly USBD_Write() @endhtmlonly initiate a transfer of data @em from
    931              device @em to host (an @em IN transfer).
    932          
    933              When the USB host actually performs the transfer, your application will be
    934              notified by means of a callback function which you provide (optionally).
    935              Refer to @ref TransferCallback for details of the callback functionality.
    936          
    937            @ref USBD_AbortTransfer(), @ref USBD_AbortAllTransfers() @n
    938              These functions terminate transfers that are initiated, but has not yet
    939              taken place. If a transfer is initiated with @htmlonly USBD_Read()
    940              or USBD_Write(), @endhtmlonly but the USB host never actually peform
    941              the transfers, these functions will deactivate the transfer setup to make
    942              the USB device endpoint hardware ready for new (and potentially) different
    943              transfers.
    944          
    945            @ref USBD_Connect(), @ref USBD_Disconnect() @n
    946              These functions turns the data-line (D+ or D-) pullup on or off. They can be
    947              used to force reenumeration. It's good practice to delay at least one second
    948              between @htmlonly USBD_Disconnect() and USBD_Connect() @endhtmlonly
    949              to allow the USB host to unload the currently active device driver.
    950          
    951            @ref USBD_EpIsBusy() @n
    952              Check if an endpoint is busy.
    953          
    954            @ref USBD_StallEp(), @ref USBD_UnStallEp() @n
    955              These functions stalls or un-stalls an endpoint. This functionality may not
    956              be needed by your application, but the USB device stack use them in response
    957              to standard setup commands SET_FEATURE and CLEAR_FEATURE. They may be useful
    958              when implementing some USB classes, e.g. a mass storage device use them
    959              extensively.
    960          
    961            @ref USBD_RemoteWakeup() @n
    962              Used in SUSPENDED state (see @ref USB_Status_TypeDef) to signal resume to
    963              host. It's the applications responsibility to adhere to the USB standard
    964              which states that a device can not signal resume before it has been
    965              SUSPENDED for at least 5 ms. The function will also check the configuration
    966              descriptor defined by the application to see if it is legal for the device
    967              to signal resume.
    968          
    969            @ref USBD_GetUsbState() @n
    970              Returns the device USB state (see @ref USBD_State_TypeDef). Refer to
    971              Figure 9-1. "Device State Diagram" in the USB revision 2.0 specification.
    972          
    973            @ref USBD_GetUsbStateName() @n
    974              Returns a text string naming a given USB device state.
    975          
    976            @n @anchor TransferCallback <b>The transfer complete callback function:</b> @n
    977              @n USB_XferCompleteCb_TypeDef() is called when a transfer completes. It is
    978              called with three parameters, the status of the transfer, the number of
    979              bytes transferred and the number of bytes remaining. It may not always be
    980              needed to have a callback on transfer completion, but you should keep in
    981              mind that a transfer may be aborted when you least expect it. A transfer
    982              will be aborted if host stalls the endpoint, if host resets your device, if
    983              host unconfigures your device or if you unplug your device cable and the
    984              device is selfpowered.
    985              @htmlonly USB_XferCompleteCb_TypeDef() @endhtmlonly is also called if your
    986              application use @htmlonly USBD_AbortTransfer() or USBD_AbortAllTransfers()
    987              @endhtmlonly calls.
    988              @note This callback is called from within an interrupt handler with
    989                    interrupts disabled.
    990          
    991            @n @anchor DeviceInitCallbacks <b>Optional callbacks passed to the stack via
    992              the @ref USBD_Init() function:</b> @n
    993              @n These callbacks are all optional, and it is up to the application
    994              programmer to decide if the application needs the functionality they
    995              provide.
    996              @note These callbacks are all called from within an interrupt handler
    997                    with interrupts disabled.
    998          
    999            USBD_UsbResetCb_TypeDef() is called each time reset signalling is sensed on
   1000              the USB wire.
   1001          
   1002            @n USBD_SofIntCb_TypeDef() is called with framenumber as a parameter on
   1003              each SOF interrupt.
   1004          
   1005            @n USBD_DeviceStateChangeCb_TypeDef() is called whenever the device state
   1006              change. Useful for detecting e.g. SUSPENDED state change in order to reduce
   1007              current consumption of buspowered devices. The USB HID keyboard example
   1008              project has a good example on how to use this callback.
   1009          
   1010            @n USBD_IsSelfPoweredCb_TypeDef() is called by the device stack when host
   1011              queries the device with a standard setup GET_STATUS command to check if the
   1012              device is currently selfpowered or buspowered. This feature is only
   1013              applicable on selfpowered devices which also works when only buspower is
   1014              available.
   1015          
   1016            @n USBD_SetupCmdCb_TypeDef() is called each time a setup command is
   1017              received from host. Use this callback to override or extend the default
   1018              handling of standard setup commands, and to implement class or vendor
   1019              specific setup commands. The USB HID keyboard example project has a good
   1020              example on how to use this callback.
   1021          
   1022          @n @section usb_device_conf Configuring the device stack
   1023          
   1024            Your application must provide a header file named @em usbconfig.h. This file
   1025            must contain the following \#define:@n @n
   1026            @verbatim
   1027          #define NUM_EP_USED n    // Your application use 'n' endpoints in
   1028                                   // addition to endpoint 0. @endverbatim
   1029          
   1030           * @}**************************************************************************/
   1031          
   1032          #endif //CORTEXM3_EM35X_USB
   1033          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USBDHAL_EpIsStalled
       8   USBD_AbortAllTransfers
         8   -> USBDHAL_AbortAllTransfers
         8   -> _disableBasePri
         0   -> _writeBasePri
      24   USBD_AbortTransfer
        24   -- Indirect call
        24   -> USBD_GetEpFromAddr
        24   -> _disableBasePri
        24   -> _writeBasePri
        24   -> halInternalAssertFailed
      16   USBD_ArmEp
        16   -> halCommonMemMove
       8   USBD_Connect
         8   -> USBDHAL_Connect
         8   -> _disableBasePri
         0   -> _writeBasePri
       8   USBD_Disconnect
         8   -> USBDHAL_Disconnect
         8   -> _disableBasePri
         0   -> _writeBasePri
       8   USBD_EpIsBusy
         8   -> USBD_GetEpFromAddr
         8   -> halInternalAssertFailed
       8   USBD_GetEpFromAddr
       0   USBD_GetUsbState
       0   USBD_GetUsbStateName
      48   USBD_Init
        48   -> USBDHAL_Connect
        48   -> USBDHAL_CoreInit
        48   -> USBHAL_DisableGlobalInt
        48   -> USBTIMER_Init
        48   -> _disableBasePri
        48   -> _writeBasePri
        48   -> halCommonMemSet
        48   -> halInternalAssertFailed
      32   USBD_Read
        32   -> USBDHAL_EpIsStalled
        32   -> USBD_ArmEp
        32   -> USBD_GetEpFromAddr
        32   -> _disableBasePri
        32   -> _writeBasePri
        32   -> halInternalAssertFailed
      16   USBD_RemoteWakeup
        16   -> halCommonGetInt16uMillisecondTick
       0   USBD_SetUsbState
         0   -- Indirect call
       8   USBD_StallEp
         8   -> USBD_GetEpFromAddr
         8   -> _disableBasePri
         8   -> _writeBasePri
         8   -> halInternalAssertFailed
       8   USBD_Stop
         8   -> USBD_Disconnect
         0   -> USBD_SetUsbState
         8   -> USBHAL_DisableGlobalInt
       8   USBD_UnStallEp
         8   -> USBD_GetEpFromAddr
         8   -> _disableBasePri
         8   -> _writeBasePri
         8   -> halInternalAssertFailed
      32   USBD_Write
        32   -> USBDHAL_EpIsStalled
        32   -> USBD_ArmEp
        32   -> USBD_GetEpFromAddr
        32   -> _disableBasePri
        32   -> _writeBasePri
        32   -> halInternalAssertFailed
       0   USBHAL_DisableGlobalInt
      16   dequeueTxIntoBuffer
      16   usbForceTxData
        16   -> USBD_EpIsBusy
        16   -> USBD_Write
       8   usbSuspendDsr
         8   -> emberStackPowerDown
         0   -> halSleep
         8   -> halSuspendCallback
      72   usbTxData
        72   -> USBD_EpIsBusy
        72   -> USBD_Write
        72   -> dequeueTxIntoBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       8  ?Subroutine0
      10  ?Subroutine1
      10  ?Subroutine2
       8  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
      10  ?Subroutine7
      14  ?Subroutine8
      12  ?Subroutine9
      12  ?_0
      12  ?_1
      12  ?_2
      12  ?_3
      12  ?_4
      12  ?_5
      12  ?_6
      12  ?_7
      16  USBDHAL_EpIsStalled
      18  USBD_AbortAllTransfers
     194  USBD_AbortTransfer
     128  USBD_ArmEp
      12  USBD_Connect
      14  USBD_Disconnect
      26  USBD_EpIsBusy
      56  USBD_GetEpFromAddr
      10  USBD_GetUsbState
      16  USBD_GetUsbStateName
     512  USBD_Init
     148  USBD_Read
      68  USBD_RemoteWakeup
      42  USBD_SetUsbState
      50  USBD_StallEp
      18  USBD_Stop
      52  USBD_UnStallEp
     154  USBD_Write
      26  USBHAL_DisableGlobalInt
      60  dequeueTxIntoBuffer
       4  dev
     240  device
      32  stateNames
      40  usbForceTxData
      42  usbSuspendDsr
      36  usbTxData

 
   240 bytes in section .bss
    36 bytes in section .data
    84 bytes in section .rodata
 1 904 bytes in section .text
 
 1 904 bytes of CODE  memory
    84 bytes of CONST memory
   276 bytes of DATA  memory

Errors: none
Warnings: none
