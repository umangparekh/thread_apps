###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  13:29:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\command-interpreter2.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\command-interpreter2.c -D
#        APP_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D
#        PHY_EM3XX -D "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"command-interpreter2.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\app\util\serial\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\command-interpreter2.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\command-interpreter2.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\app\util\serial\command-interpreter2.c
      1          /**
      2           * File: command-interpreter2.c
      3           * Description: processes commands incoming over the serial port.
      4           *
      5           * Culprit(s): Richard Kelsey, Matteo Paris
      6           *
      7           * Copyright 2008 by Ember Corporation.  All rights reserved.               *80*
      8           */
      9          
     10          #include PLATFORM_HEADER
     11          
     12          #ifdef EZSP_HOST
     13            // Includes needed for ember related functions for the EZSP host
     14            #include "stack/include/error.h"
     15            #include "stack/include/ember-types.h"
     16            #include "app/util/ezsp/ezsp-protocol.h"
     17            #include "app/util/ezsp/ezsp.h"
     18            #include "app/util/ezsp/serial-interface.h"
     19            extern uint8_t emberEndpointCount;
     20          #else
     21            #include "stack/include/ember.h"
     22          #endif
     23          
     24          #include "hal/hal.h"
     25          #include "app/util/serial/serial.h"
     26          #include "app/util/serial/command-interpreter2.h"
     27          #include "app/util/serial/command-interpreter2-util.h"
     28          
     29          #if defined(EMBER_REQUIRE_FULL_COMMAND_NAME) \
     30            || defined(EMBER_REQUIRE_EXACT_COMMAND_NAME)
     31            #undef EMBER_REQUIRE_EXACT_COMMAND_NAME
     32            #define EMBER_REQUIRE_EXACT_COMMAND_NAME true
     33          #else
     34            #define EMBER_REQUIRE_EXACT_COMMAND_NAME false
     35          #endif
     36          
     37          // forward declarations
     38          static void callCommandAction(void);
     39          static uint8_t charDowncase(uint8_t c);
     40          
     41          // This byte is used to toggle certain internal features on or off.
     42          // By default all are off.

   \                                 In section .bss, align 1
     43          uint8_t emberCommandInterpreter2Configuration = 0x00;
   \                     emberCommandInterpreter2Configuration:
   \   00000000                      DS8 1
     44          
     45          //----------------------------------------------------------------
     46          
     47          // Some users of command-interpreter2 need the command buffer to be set to 0
     48          // so the command arg is NULL terminated when a pointer is returned.
     49          // It might be better to always zero out the buffer when we reset 
     50          // commandState.state to CMD_AWAITING_ARGUMENT, but I don't want to break any
     51          // other existing apps, so I'm letting the app decide if it wants to zero out
     52          // the buffer.

   \                                 In section .text, align 2, keep-with-next
     53          void emberCommandClearBuffer(void)
     54          {
     55            MEMSET(emCommandState.buffer, 0, EMBER_COMMAND_BUFFER_LENGTH);
   \                     emberCommandClearBuffer: (+1)
   \   00000000   0x2264             MOVS     R2,#+100
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable3
   \   00000006   0x.... 0x....      B.W      halCommonMemSet
     56          }
     57          
     58          //----------------------------------------------------------------
     59          // This is a state machine for parsing commands.  If 'input' is NULL
     60          // 'sizeOrPort' is treated as a port and characters are read from there.
     61          //
     62          // Goto's are used where one parse state naturally falls into another,
     63          // and to save flash.
     64          

   \                                 In section .text, align 2, keep-with-next
     65          bool emberProcessCommandString(const uint8_t *input, uint16_t sizeOrPort)
     66          {
   \                     emberProcessCommandString: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460D             MOV      R5,R1
     67            bool isEol = false;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x....             LDR.N    R7,??DataTable3_1
   \   0000000C   0xE001             B.N      ??emberProcessCommandString_0
     68            bool isSpace, isQuote;
     69          
     70            while (true) {
     71              uint8_t next;
     72          
     73              if (input == NULL) {
     74                switch (emberSerialReadByte(sizeOrPort, &next)) {
     75                case EMBER_SUCCESS:
     76                  break;
     77                case EMBER_SERIAL_RX_EMPTY:
     78                  return isEol;
     79                default:
     80                  emCommandState.error = EMBER_CMD_ERR_PORT_PROBLEM;
     81                  goto READING_TO_EOL;
     82                }
     83              } else if (sizeOrPort == 0) {
     84                return isEol;
     85              } else {
     86                next = *input;
     87                input += 1;
     88                sizeOrPort -= 1;
     89              }
     90          
     91              if (emCommandState.previousCharacter == '\r' && next == '\n') {
     92                emCommandState.previousCharacter = next;
   \                     ??emberProcessCommandString_1: (+1)
   \   0000000E   0xF887 0x007B      STRB     R0,[R7, #+123]
     93                continue;
     94              }
   \                     ??emberProcessCommandString_0: (+1)
   \   00000012   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000016   0xD109             BNE.N    ??emberProcessCommandString_2
   \   00000018   0xA900             ADD      R1,SP,#+0
   \   0000001A   0xB2E8             UXTB     R0,R5
   \   0000001C   0x.... 0x....      BL       emberSerialReadByte
   \   00000020   0xB170             CBZ.N    R0,??emberProcessCommandString_3
   \   00000022   0x2826             CMP      R0,#+38
   \   00000024   0xBF18             IT       NE 
   \   00000026   0x2001             MOVNE    R0,#+1
   \   00000028   0xD176             BNE.N    ??emberProcessCommandString_4
   \   0000002A   0xE001             B.N      ??emberProcessCommandString_5
   \                     ??emberProcessCommandString_2: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5
   \   0000002E   0xB915             CBNZ.N   R5,??emberProcessCommandString_6
   \                     ??emberProcessCommandString_5: (+1)
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??emberProcessCommandString_6: (+1)
   \   00000036   0xF818 0x0B01      LDRB     R0,[R8], #+1
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003E   0x1E6D             SUBS     R5,R5,#+1
   \                     ??emberProcessCommandString_3: (+1)
   \   00000040   0xF897 0x107B      LDRB     R1,[R7, #+123]
   \   00000044   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000048   0x290D             CMP      R1,#+13
   \   0000004A   0xBF08             IT       EQ 
   \   0000004C   0x280A             CMPEQ    R0,#+10
   \   0000004E   0xD0DE             BEQ.N    ??emberProcessCommandString_1
     95              emCommandState.previousCharacter = next;
     96              isEol = ((next == '\r') || (next == '\n'));
   \   00000050   0x280D             CMP      R0,#+13
   \   00000052   0xF887 0x007B      STRB     R0,[R7, #+123]
   \   00000056   0xD105             BNE.N    ??emberProcessCommandString_7
   \                     ??emberProcessCommandString_8: (+1)
   \   00000058   0x2601             MOVS     R6,#+1
   \                     ??emberProcessCommandString_9: (+1)
   \   0000005A   0x2400             MOVS     R4,#+0
     97              isSpace = (next == ' ');
     98              isQuote = (next == '"');
   \   0000005C   0x2822             CMP      R0,#+34
   \   0000005E   0xD107             BNE.N    ??emberProcessCommandString_10
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0xE006             B.N      ??emberProcessCommandString_11
   \                     ??emberProcessCommandString_7: (+1)
   \   00000064   0x280A             CMP      R0,#+10
   \   00000066   0xD0F7             BEQ.N    ??emberProcessCommandString_8
   \   00000068   0x2600             MOVS     R6,#+0
   \   0000006A   0x2820             CMP      R0,#+32
   \   0000006C   0xD1F5             BNE.N    ??emberProcessCommandString_9
   \   0000006E   0x2401             MOVS     R4,#+1
   \                     ??emberProcessCommandString_10: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
     99          
    100              // fprintf(stderr, "[processing '%c' (%s)]\n", next, stateNames[emCommandState.state]);
    101          
    102              switch (emCommandState.state) {
   \                     ??emberProcessCommandString_11: (+1)
   \   00000072   0x783A             LDRB     R2,[R7, #+0]
   \   00000074   0xB132             CBZ.N    R2,??emberProcessCommandString_12
   \   00000076   0x2A02             CMP      R2,#+2
   \   00000078   0xD01F             BEQ.N    ??emberProcessCommandString_13
   \   0000007A   0xD315             BCC.N    ??emberProcessCommandString_14
   \   0000007C   0x2A04             CMP      R2,#+4
   \   0000007E   0xD05F             BEQ.N    ??emberProcessCommandString_15
   \   00000080   0xD322             BCC.N    ??emberProcessCommandString_16
   \   00000082   0xE7C6             B.N      ??emberProcessCommandString_0
    103          
    104              case CMD_AWAITING_ARGUMENT:
    105                if (isEol) {
   \                     ??emberProcessCommandString_12: (+1)
   \   00000084   0x2E00             CMP      R6,#+0
   \   00000086   0xD157             BNE.N    ??emberProcessCommandString_17
    106                  goto CALL_COMMAND_ACTION;
    107                } else if (! isSpace) {
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD1C2             BNE.N    ??emberProcessCommandString_0
    108                  if (isQuote) {
   \   0000008C   0xB139             CBZ.N    R1,??emberProcessCommandString_18
    109                    emCommandState.state = CMD_READING_STRING;
   \   0000008E   0x2002             MOVS     R0,#+2
   \                     ??emberProcessCommandString_19: (+1)
   \   00000090   0x7038             STRB     R0,[R7, #+0]
    110                  } else if (next == '{') {
    111                    emCommandState.state = CMD_READING_HEX_STRING;
    112                  } else {
    113                    emCommandState.state = CMD_READING_ARGUMENT;
    114                  }
    115                  goto WRITE_TO_BUFFER;
    116                }
    117                break;
    118          
    119              case CMD_READING_ARGUMENT:
    120                if (isEol || isSpace) {
    121                  goto END_ARGUMENT;
    122                } else {
    123                  goto WRITE_TO_BUFFER;
    124                }
    125          
    126              case CMD_READING_STRING:
    127                if (isQuote) {
    128                  next = 0;
    129                } else if (isEol) {
    130                  emCommandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    131                  goto READING_TO_EOL;
    132                }
    133                goto WRITE_TO_BUFFER;
    134          
    135              case CMD_READING_HEX_STRING: {
    136                bool waitingForLowNibble = (emCommandState.hexHighNibble != 0xFF);
    137                if (next == '}') {
    138                  if (waitingForLowNibble) {
    139                    emCommandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    140                    goto READING_TO_EOL;
    141                  }
    142                  goto END_ARGUMENT;
    143                } else {
    144                  uint8_t value = emberHexToInt(next);
    145                  if (value < 16) {
    146                    if (waitingForLowNibble) {
    147                      next = (emCommandState.hexHighNibble << 4) + value;
    148                      emCommandState.hexHighNibble = 0xFF;
    149                      goto WRITE_TO_BUFFER;
    150                    } else {
    151                      emCommandState.hexHighNibble = value;
    152                    }
    153                  } else if (! isSpace) {
    154                    emCommandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    155                    goto READING_TO_EOL;
    156                  }
    157                }
    158                break;
    159              }
    160          
    161              CALL_COMMAND_ACTION:
    162                callCommandAction();
    163                // fall through to READING_TO_EOL for error chack and reinitialization
    164          
    165              READING_TO_EOL:
    166                emCommandState.state = CMD_READING_TO_EOL;
    167          
    168              case CMD_READING_TO_EOL:
    169                if (isEol) {
    170                  if (emCommandState.error != EMBER_CMD_SUCCESS) {
    171                    ERROR_HANDLER(emCommandState.error, NULL);
    172                  }
    173                  emCommandReaderReinit();
    174                  emCommandState.previousCharacter = next;
    175                }
    176                break;
    177          
    178              END_ARGUMENT:
    179                if (emCommandState.tokenCount == MAX_TOKEN_COUNT) {
    180                  emCommandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    181                  
    182                  goto READING_TO_EOL;
    183                }
    184                emCommandState.tokenCount += 1;
    185                emCommandState.tokenIndices[emCommandState.tokenCount] = emCommandState.index;
    186                emCommandState.state = CMD_AWAITING_ARGUMENT;
    187                if (isEol) {
    188                  goto CALL_COMMAND_ACTION;
    189                }
    190                break;
    191          
    192              WRITE_TO_BUFFER:
    193                if (emCommandState.index == EMBER_COMMAND_BUFFER_LENGTH) {
   \                     ??emberProcessCommandString_20: (+1)
   \   00000092   0xF8B7 0x4076      LDRH     R4,[R7, #+118]
   \   00000096   0x2C64             CMP      R4,#+100
   \   00000098   0xD15F             BNE.N    ??emberProcessCommandString_21
    194                  emCommandState.error = EMBER_CMD_ERR_STRING_TOO_LONG;
   \   0000009A   0x2006             MOVS     R0,#+6
   \   0000009C   0xE03C             B.N      ??emberProcessCommandString_4
    195                  goto READING_TO_EOL;
    196                }
   \                     ??emberProcessCommandString_18: (+1)
   \   0000009E   0x287B             CMP      R0,#+123
   \   000000A0   0xBF14             ITE      NE 
   \   000000A2   0x2001             MOVNE    R0,#+1
   \   000000A4   0x2003             MOVEQ    R0,#+3
   \   000000A6   0xE7F3             B.N      ??emberProcessCommandString_19
   \                     ??emberProcessCommandString_14: (+1)
   \   000000A8   0xEA54 0x0006      ORRS     R0,R4,R6
   \   000000AC   0xD0F1             BEQ.N    ??emberProcessCommandString_20
   \                     ??emberProcessCommandString_22: (+1)
   \   000000AE   0xF897 0x0075      LDRB     R0,[R7, #+117]
   \   000000B2   0x280F             CMP      R0,#+15
   \   000000B4   0xD133             BNE.N    ??emberProcessCommandString_23
   \   000000B6   0x2003             MOVS     R0,#+3
   \   000000B8   0xE02E             B.N      ??emberProcessCommandString_4
   \                     ??emberProcessCommandString_13: (+1)
   \   000000BA   0xB119             CBZ.N    R1,??emberProcessCommandString_24
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000C2   0xE7E6             B.N      ??emberProcessCommandString_20
   \                     ??emberProcessCommandString_24: (+1)
   \   000000C4   0xBB3E             CBNZ.N   R6,??emberProcessCommandString_25
   \   000000C6   0xE7E4             B.N      ??emberProcessCommandString_20
   \                     ??emberProcessCommandString_16: (+1)
   \   000000C8   0xF897 0x1079      LDRB     R1,[R7, #+121]
   \   000000CC   0x29FF             CMP      R1,#+255
   \   000000CE   0xBF14             ITE      NE 
   \   000000D0   0xF04F 0x0901      MOVNE    R9,#+1
   \   000000D4   0xF04F 0x0900      MOVEQ    R9,#+0
   \   000000D8   0x287D             CMP      R0,#+125
   \   000000DA   0xD103             BNE.N    ??emberProcessCommandString_26
   \   000000DC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000E0   0xD119             BNE.N    ??emberProcessCommandString_25
   \   000000E2   0xE7E4             B.N      ??emberProcessCommandString_22
   \                     ??emberProcessCommandString_26: (+1)
   \   000000E4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E8   0x.... 0x....      BL       emberHexToInt
   \   000000EC   0x4601             MOV      R1,R0
   \   000000EE   0x2910             CMP      R1,#+16
   \   000000F0   0xDA0F             BGE.N    ??emberProcessCommandString_27
   \   000000F2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F6   0xD009             BEQ.N    ??emberProcessCommandString_28
   \   000000F8   0xF897 0x0079      LDRB     R0,[R7, #+121]
   \   000000FC   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000100   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000104   0x20FF             MOVS     R0,#+255
   \   00000106   0xF887 0x0079      STRB     R0,[R7, #+121]
   \   0000010A   0xE7C2             B.N      ??emberProcessCommandString_20
   \                     ??emberProcessCommandString_28: (+1)
   \   0000010C   0xF887 0x0079      STRB     R0,[R7, #+121]
   \                     ??emberProcessCommandString_29: (+1)
   \   00000110   0xE77F             B.N      ??emberProcessCommandString_0
   \                     ??emberProcessCommandString_27: (+1)
   \   00000112   0x2C00             CMP      R4,#+0
   \   00000114   0xD1FC             BNE.N    ??emberProcessCommandString_29
   \                     ??emberProcessCommandString_25: (+1)
   \   00000116   0x2005             MOVS     R0,#+5
   \                     ??emberProcessCommandString_4: (+1)
   \   00000118   0xF887 0x0078      STRB     R0,[R7, #+120]
   \   0000011C   0xE00E             B.N      ??emberProcessCommandString_30
   \                     ??emberProcessCommandString_23: (+1)
   \   0000011E   0x1C40             ADDS     R0,R0,#+1
   \   00000120   0xF887 0x0075      STRB     R0,[R7, #+117]
   \   00000124   0xB2C0             UXTB     R0,R0
   \   00000126   0xF8B7 0x1076      LDRH     R1,[R7, #+118]
   \   0000012A   0x19C0             ADDS     R0,R0,R7
   \   0000012C   0xF880 0x1065      STRB     R1,[R0, #+101]
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x2E00             CMP      R6,#+0
   \   00000134   0x7038             STRB     R0,[R7, #+0]
   \   00000136   0xD0EB             BEQ.N    ??emberProcessCommandString_29
   \                     ??emberProcessCommandString_17: (+1)
   \   00000138   0x.... 0x....      BL       callCommandAction
   \                     ??emberProcessCommandString_30: (+1)
   \   0000013C   0x2004             MOVS     R0,#+4
   \   0000013E   0x7038             STRB     R0,[R7, #+0]
   \                     ??emberProcessCommandString_15: (+1)
   \   00000140   0x2E00             CMP      R6,#+0
   \   00000142   0xD0E5             BEQ.N    ??emberProcessCommandString_29
   \   00000144   0xF897 0x0078      LDRB     R0,[R7, #+120]
   \   00000148   0xB110             CBZ.N    R0,??emberProcessCommandString_31
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0x.... 0x....      BL       emberCommandErrorHandler
   \                     ??emberProcessCommandString_31: (+1)
   \   00000150   0x.... 0x....      BL       emCommandReaderReinit
   \   00000154   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000158   0xE759             B.N      ??emberProcessCommandString_1
    197                if (emCommandState.state == CMD_READING_ARGUMENT) {
   \                     ??emberProcessCommandString_21: (+1)
   \   0000015A   0x7838             LDRB     R0,[R7, #+0]
   \   0000015C   0x2801             CMP      R0,#+1
   \   0000015E   0xD105             BNE.N    ??emberProcessCommandString_32
    198                  next = charDowncase(next);
   \   00000160   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000164   0x.... 0x....      BL       charDowncase
   \   00000168   0xF88D 0x0000      STRB     R0,[SP, #+0]
    199                }
    200                emCommandState.buffer[emCommandState.index] = next;
   \                     ??emberProcessCommandString_32: (+1)
   \   0000016C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000170   0x19E1             ADDS     R1,R4,R7
   \   00000172   0x7048             STRB     R0,[R1, #+1]
    201                emCommandState.index += 1;
   \   00000174   0xF8B7 0x0076      LDRH     R0,[R7, #+118]
   \   00000178   0x1C40             ADDS     R0,R0,#+1
   \   0000017A   0xF8A7 0x0076      STRH     R0,[R7, #+118]
    202                if (emCommandState.state == CMD_READING_STRING && next == 0) {
   \   0000017E   0x7838             LDRB     R0,[R7, #+0]
   \   00000180   0x2802             CMP      R0,#+2
   \   00000182   0xBF04             ITT      EQ 
   \   00000184   0xF89D 0x0000      LDRBEQ   R0,[SP, #+0]
   \   00000188   0x2800             CMPEQ    R0,#+0
   \   0000018A   0xD1C1             BNE.N    ??emberProcessCommandString_29
   \   0000018C   0xE78F             B.N      ??emberProcessCommandString_22
    203                  goto END_ARGUMENT;
    204                }
    205                break;
    206          
    207              default: {
    208              }
    209              } //close switch.
    210            }
    211          }
    212          

   \                                 In section .text, align 2, keep-with-next
    213          static uint8_t charDowncase(uint8_t c)
    214          {
    215            if ('A' <= c && c <= 'Z') {
   \                     charDowncase: (+1)
   \   00000000   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000004   0x291A             CMP      R1,#+26
   \   00000006   0xBF3C             ITT      CC 
   \   00000008   0x3020             ADDCC    R0,R0,#+32
   \   0000000A   0xB2C0             UXTBCC   R0,R0
    216              return c + 'a' - 'A';
    217            } else {
    218              return c;
   \   0000000C   0x4770             BX       LR               ;; return
    219            }
    220          }
    221          
    222          // To support existing lazy-typer functionality in the app framework,
    223          // we allow the user to shorten the entered command so long as the
    224          // substring matches no more than one command in the table.
    225          //
    226          // To allow CONST savings by storing abbreviated command names, we also
    227          // allow matching if the input command is longer than the stored command.
    228          // To reduce complexity, we do not handle multiple inexact matches.
    229          // For example, if there are commands 'A' and 'AB', and the user enters
    230          // 'ABC', nothing will match.
    231          
    232          static EmberCommandEntry *commandLookup(EmberCommandEntry *commandFinger,
    233                                                  uint8_t tokenNum)
    234          {
    235            EmberCommandEntry *inexactMatch = NULL;
    236            uint8_t *inputCommand = emTokenPointer(tokenNum);
    237            uint8_t inputLength = emTokenLength(tokenNum);
    238            bool multipleMatches = false;
    239          
    240            for (; commandFinger->name != NULL; commandFinger++) {
    241              PGM_P entryFinger = commandFinger->name;
    242              uint8_t *inputFinger = inputCommand;
    243              for (;; entryFinger++, inputFinger++) {
    244                bool endInput = (inputFinger - inputCommand == inputLength);
    245                bool endEntry = (*entryFinger == 0);
    246                if (endInput && endEntry) {
    247                  return commandFinger;  // Exact match.
    248                } else if (endInput || endEntry) {
    249                  if (inexactMatch != NULL) {
    250                    multipleMatches = true;  // Multiple matches.
    251                    break;
    252                  } else {
    253                    inexactMatch = commandFinger;
    254                    break;
    255                  }
    256                } else if (charDowncase(*inputFinger) != charDowncase(*entryFinger)) {
    257                  break;
    258                }
    259              }
    260            }
    261            return ((multipleMatches || EMBER_REQUIRE_EXACT_COMMAND_NAME)
    262                    ? NULL
    263                    : inexactMatch);
    264          }
    265          

   \                                 In section .text, align 2, keep-with-next
    266          static void callCommandAction(void)
    267          {
   \                     callCommandAction: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
    268            EmberCommandEntry *commandFinger = COMMAND_TABLE;
   \   00000006   0x....             LDR.N    R0,??DataTable3_2
   \   00000008   0x9001             STR      R0,[SP, #+4]
    269            uint8_t tokenNum = 0;
   \   0000000A   0xF04F 0x0800      MOV      R8,#+0
   \   0000000E   0x....             LDR.N    R0,??DataTable3_1
   \   00000010   0xF890 0x0075      LDRB     R0,[R0, #+117]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD140             BNE.N    ??callCommandAction_0
    270            // We need a separate argTypeNum index because of the '*' arg type.
    271            uint8_t argTypeNum, argNum;
    272          
    273            if (emCommandState.tokenCount == 0) {
    274              return;
   \   00000018   0xE0A4             B.N      ??callCommandAction_1
    275            }
    276          
    277            // Lookup the command.
    278            while (true) {
   \                     ??callCommandAction_2: (+1)
   \   0000001A   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   0000001E   0x.... 0x....      BL       charDowncase
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0xF816 0x0B01      LDRB     R0,[R6], #+1
   \   00000028   0x.... 0x....      BL       charDowncase
   \   0000002C   0x9900             LDR      R1,[SP, #+0]
   \   0000002E   0xB2C9             UXTB     R1,R1
   \   00000030   0x4281             CMP      R1,R0
   \   00000032   0xD003             BEQ.N    ??callCommandAction_3
   \                     ??callCommandAction_4: (+1)
   \   00000034   0x3710             ADDS     R7,R7,#+16
   \                     ??callCommandAction_5: (+1)
   \   00000036   0x683E             LDR      R6,[R7, #+0]
   \   00000038   0xB1AE             CBZ.N    R6,??callCommandAction_6
   \   0000003A   0x4625             MOV      R5,R4
   \                     ??callCommandAction_3: (+1)
   \   0000003C   0x1B28             SUBS     R0,R5,R4
   \   0000003E   0x4558             CMP      R0,R11
   \   00000040   0x7830             LDRB     R0,[R6, #+0]
   \   00000042   0xBF0C             ITE      EQ 
   \   00000044   0x2101             MOVEQ    R1,#+1
   \   00000046   0x2100             MOVNE    R1,#+0
   \   00000048   0x1E42             SUBS     R2,R0,#+1
   \   0000004A   0x4192             SBCS     R2,R2,R2
   \   0000004C   0xEA11 0x7FD2      TST      R1,R2, LSR #+31
   \   00000050   0xD10E             BNE.N    ??callCommandAction_7
   \   00000052   0xEA51 0x70D2      ORRS     R0,R1,R2, LSR #+31
   \   00000056   0xD0E0             BEQ.N    ??callCommandAction_2
   \   00000058   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000005C   0xBF0C             ITE      EQ 
   \   0000005E   0x46B9             MOVEQ    R9,R7
   \   00000060   0xF04F 0x0A01      MOVNE    R10,#+1
   \   00000064   0xE7E6             B.N      ??callCommandAction_4
   \                     ??callCommandAction_6: (+1)
   \   00000066   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000006A   0xBF14             ITE      NE 
   \   0000006C   0x2700             MOVNE    R7,#+0
   \   0000006E   0x464F             MOVEQ    R7,R9
    279              commandFinger = commandLookup(commandFinger, tokenNum);
   \                     ??callCommandAction_7: (+1)
   \   00000070   0x9701             STR      R7,[SP, #+4]
    280              if (commandFinger == NULL) {
   \   00000072   0x....             LDR.N    R5,??DataTable3_3
   \   00000074   0xB90F             CBNZ.N   R7,??callCommandAction_8
    281                emCommandState.error = EMBER_CMD_ERR_NO_SUCH_COMMAND;
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0xE06D             B.N      ??callCommandAction_9
    282                goto kickout;
    283              } else {
    284                emCommandState.currentCommand = commandFinger;
    285                tokenNum += 1;
    286                emCommandState.argOffset += 1;
   \                     ??callCommandAction_8: (+1)
   \   0000007A   0x7968             LDRB     R0,[R5, #+5]
   \   0000007C   0x....             LDR.N    R1,??DataTable3_1
   \   0000007E   0xF8C1 0x7080      STR      R7,[R1, #+128]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x7168             STRB     R0,[R5, #+5]
   \   00000086   0xF108 0x0801      ADD      R8,R8,#+1
    287          
    288                if (emberGetNestedCommand(commandFinger, &commandFinger)) {
   \   0000008A   0x9801             LDR      R0,[SP, #+4]
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0x.... 0x....      BL       emberGetNestedCommand
   \   00000092   0xB180             CBZ.N    R0,??callCommandAction_10
    289                  if (tokenNum >= emCommandState.tokenCount) {
   \   00000094   0x.... 0x....      BL       ?Subroutine0
    290                    emCommandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    291                    goto kickout;
    292                  }
    293                } else {
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000098   0xD25C             BCS.N    ??callCommandAction_11
   \                     ??callCommandAction_0: (+1)
   \   0000009A   0x9F01             LDR      R7,[SP, #+4]
   \   0000009C   0xF04F 0x0900      MOV      R9,#+0
   \   000000A0   0xFA4F 0xF088      SXTB     R0,R8
   \   000000A4   0x.... 0x....      BL       emTokenPointer
   \   000000A8   0x4604             MOV      R4,R0
   \   000000AA   0x4640             MOV      R0,R8
   \   000000AC   0x.... 0x....      BL       emTokenLength
   \   000000B0   0x4683             MOV      R11,R0
   \   000000B2   0x46CA             MOV      R10,R9
   \   000000B4   0xE7BF             B.N      ??callCommandAction_5
    294                  break;
    295                }
    296              }
    297            }
    298          
    299            // If you put '?' as the first character
    300            // of the argument format string, then you effectivelly
    301            // prevent the argument validation, and the command gets executed.
    302            // At that point it is down to the command to deal with whatever
    303            // arguments it got.
    304            if ( commandFinger->argumentTypes[0] == '?' ) {
   \                     ??callCommandAction_10: (+1)
   \   000000B6   0x9801             LDR      R0,[SP, #+4]
   \   000000B8   0x6880             LDR      R0,[R0, #+8]
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x283F             CMP      R0,#+63
   \   000000BE   0xD04C             BEQ.N    ??callCommandAction_12
    305              goto kickout;
    306            }
    307          
    308            // Validate the arguments.
    309            for(argTypeNum = 0, argNum = 0;
   \   000000C0   0x2600             MOVS     R6,#+0
   \   000000C2   0x2700             MOVS     R7,#+0
   \   000000C4   0xE00F             B.N      ??callCommandAction_13
    310                tokenNum < emCommandState.tokenCount;
    311                tokenNum++, argNum++) {
    312              uint8_t type = commandFinger->argumentTypes[argTypeNum];
    313              uint8_t firstChar = emFirstByteOfArg(argNum);
    314              switch(type) {
    315          
    316              // Integers
    317              case 'u':
    318              case 'v':
    319              case 'w':
    320              case 's': {
    321                uint32_t limit = (type == 'u' ? 0xFF
    322                                : (type == 'v' ? 0xFFFF
    323                                   : (type =='s' ? 0x7F : 0xFFFFFFFFUL)));
    324                if (emStringToUnsignedInt(argNum, true) > limit) {
    325                  emCommandState.error = EMBER_CMD_ERR_ARGUMENT_OUT_OF_RANGE;
    326                }
    327                break;
    328              }
    329          
    330              // String
    331              case 'b':
    332                if (firstChar != '"' && firstChar != '{') {
    333                  emCommandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    334                }
    335                break;
    336          
    337              case 0:
    338                emCommandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    339                break;
    340          
    341              default:
    342                emCommandState.error = EMBER_CMD_ERR_INVALID_ARGUMENT_TYPE;
   \                     ??callCommandAction_14: (+1)
   \   000000C6   0x2007             MOVS     R0,#+7
   \                     ??callCommandAction_15: (+1)
   \   000000C8   0x70E8             STRB     R0,[R5, #+3]
    343                break;
    344              }
    345          
    346              if (commandFinger->argumentTypes[argTypeNum + 1] != '*') {
   \                     ??callCommandAction_16: (+1)
   \   000000CA   0x9801             LDR      R0,[SP, #+4]
   \   000000CC   0x6880             LDR      R0,[R0, #+8]
   \   000000CE   0x1830             ADDS     R0,R6,R0
   \   000000D0   0x7840             LDRB     R0,[R0, #+1]
   \   000000D2   0x282A             CMP      R0,#+42
    347                argTypeNum += 1;
    348              }
    349          
    350              if (emCommandState.error != EMBER_CMD_SUCCESS) {
   \   000000D4   0x78E8             LDRB     R0,[R5, #+3]
   \   000000D6   0xBF1C             ITT      NE 
   \   000000D8   0x1C76             ADDNE    R6,R6,#+1
   \   000000DA   0xB2F6             UXTBNE   R6,R6
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD13C             BNE.N    ??callCommandAction_12
   \   000000E0   0xF108 0x0801      ADD      R8,R8,#+1
   \   000000E4   0x1C7F             ADDS     R7,R7,#+1
   \                     ??callCommandAction_13: (+1)
   \   000000E6   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000EA   0x9801             LDR      R0,[SP, #+4]
   \   000000EC   0x6880             LDR      R0,[R0, #+8]
   \   000000EE   0xD22A             BCS.N    ??callCommandAction_17
   \   000000F0   0x5C34             LDRB     R4,[R6, R0]
   \   000000F2   0xB2F8             UXTB     R0,R7
   \   000000F4   0x.... 0x....      BL       emFirstByteOfArg
   \   000000F8   0xB31C             CBZ.N    R4,??callCommandAction_18
   \   000000FA   0xF1B4 0x0162      SUBS     R1,R4,#+98
   \   000000FE   0xD01A             BEQ.N    ??callCommandAction_19
   \   00000100   0x3911             SUBS     R1,R1,#+17
   \   00000102   0xD002             BEQ.N    ??callCommandAction_20
   \   00000104   0x1E89             SUBS     R1,R1,#+2
   \   00000106   0x2902             CMP      R1,#+2
   \   00000108   0xD8DD             BHI.N    ??callCommandAction_14
   \                     ??callCommandAction_20: (+1)
   \   0000010A   0x2C75             CMP      R4,#+117
   \   0000010C   0xBF08             IT       EQ 
   \   0000010E   0x24FF             MOVEQ    R4,#+255
   \   00000110   0xD009             BEQ.N    ??callCommandAction_21
   \   00000112   0x2C76             CMP      R4,#+118
   \   00000114   0xBF08             IT       EQ 
   \   00000116   0xF64F 0x74FF      MOVWEQ   R4,#+65535
   \   0000011A   0xD004             BEQ.N    ??callCommandAction_21
   \   0000011C   0x2C73             CMP      R4,#+115
   \   0000011E   0xBF0C             ITE      EQ 
   \   00000120   0x247F             MOVEQ    R4,#+127
   \   00000122   0xF04F 0x34FF      MOVNE    R4,#-1
   \                     ??callCommandAction_21: (+1)
   \   00000126   0x2101             MOVS     R1,#+1
   \   00000128   0xB2F8             UXTB     R0,R7
   \   0000012A   0x.... 0x....      BL       emStringToUnsignedInt
   \   0000012E   0x4284             CMP      R4,R0
   \   00000130   0xD2CB             BCS.N    ??callCommandAction_16
   \   00000132   0x2004             MOVS     R0,#+4
   \   00000134   0xE7C8             B.N      ??callCommandAction_15
   \                     ??callCommandAction_19: (+1)
   \   00000136   0x2822             CMP      R0,#+34
   \   00000138   0xBF18             IT       NE 
   \   0000013A   0x287B             CMPNE    R0,#+123
   \   0000013C   0xD0C5             BEQ.N    ??callCommandAction_16
   \   0000013E   0x2005             MOVS     R0,#+5
   \   00000140   0xE7C2             B.N      ??callCommandAction_15
   \                     ??callCommandAction_18: (+1)
   \   00000142   0x2003             MOVS     R0,#+3
   \   00000144   0xE7C0             B.N      ??callCommandAction_15
    351                goto kickout;
    352              }
    353            }
    354          
    355            if (! (commandFinger->argumentTypes[argTypeNum] == 0
    356                   || commandFinger->argumentTypes[argTypeNum + 1] == '*')) {
   \                     ??callCommandAction_17: (+1)
   \   00000146   0x5C31             LDRB     R1,[R6, R0]
   \   00000148   0x2900             CMP      R1,#+0
   \   0000014A   0xBF1E             ITTT     NE 
   \   0000014C   0x1830             ADDNE    R0,R6,R0
   \   0000014E   0x7840             LDRBNE   R0,[R0, #+1]
   \   00000150   0x282A             CMPNE    R0,#+42
   \   00000152   0xD002             BEQ.N    ??callCommandAction_12
    357              emCommandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
   \                     ??callCommandAction_11: (+1)
   \   00000154   0x2003             MOVS     R0,#+3
   \                     ??callCommandAction_9: (+1)
   \   00000156   0x70E8             STRB     R0,[R5, #+3]
   \   00000158   0xE004             B.N      ??callCommandAction_1
    358            }
    359          
    360           kickout:
    361          
    362            if (emCommandState.error == EMBER_CMD_SUCCESS) {
   \                     ??callCommandAction_12: (+1)
   \   0000015A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000015C   0xB910             CBNZ.N   R0,??callCommandAction_1
    363              (commandFinger->action)();
   \   0000015E   0x9801             LDR      R0,[SP, #+4]
   \   00000160   0x6840             LDR      R0,[R0, #+4]
   \   00000162   0x4780             BLX      R0
    364            }
    365          }
   \                     ??callCommandAction_1: (+1)
   \   00000164   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3_1
   \   00000002   0xF890 0x0075      LDRB     R0,[R0, #+117]
   \   00000006   0xFA5F 0xF888      UXTB     R8,R8
   \   0000000A   0x4580             CMP      R8,R0
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     emCommandState+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     emCommandState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     emberCommandTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     emCommandState+0x75

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   callCommandAction
        48   -- Indirect call
        48   -> charDowncase
        48   -> emFirstByteOfArg
        48   -> emStringToUnsignedInt
        48   -> emTokenLength
        48   -> emTokenPointer
        48   -> emberGetNestedCommand
       0   charDowncase
       0   emberCommandClearBuffer
         0   -> halCommonMemSet
      32   emberProcessCommandString
        32   -> callCommandAction
        32   -> charDowncase
        32   -> emCommandReaderReinit
        32   -> emberCommandErrorHandler
        32   -> emberHexToInt
        32   -> emberSerialReadByte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      14  ?Subroutine0
     360  callCommandAction
      14  charDowncase
      10  emberCommandClearBuffer
       1  emberCommandInterpreter2Configuration
     398  emberProcessCommandString

 
   1 byte  in section .bss
 812 bytes in section .text
 
 812 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
