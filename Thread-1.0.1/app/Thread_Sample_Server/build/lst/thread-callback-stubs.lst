###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        28/Sep/2015  13:29:35
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\thread-callback-stubs.c
#    Command line =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\thread-callback-stubs.c
#        -D APP_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM3588 -D
#        PHY_EM3XX -D "BOARD_HEADER=\"thread-board.h\"" -D
#        "CONFIGURATION_HEADER=\"thread-configuration.h\"" -D
#        "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "__SOURCEFILE__=\"thread-callback-stubs.c\"" -D BOARD_DEV0680ETM -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        EMBER_STACK_IP -D EMBER_RIP_STACK -D HAVE_TLS_JPAKE -D
#        DEBUG_LEVEL=FULL_DEBUG -D
#        "APPLICATION_TOKEN_HEADER=\"thread-token.h\"" -lC
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\
#        --debug --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\app\util\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\stack\
#        -I C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\ -I
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\lst\thread-callback-stubs.lst
#    Object file  =  
#        C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\build\obj\thread-callback-stubs.o
#
###############################################################################

C:\SiliconLabs\Thread-1.0.1\app\Thread_Sample_Server\thread-callback-stubs.c
      1          // This file is generated by Ember Desktop.  Please do not edit manually.
      2          //
      3          //
      4          
      5          #include PLATFORM_HEADER
      6          #include CONFIGURATION_HEADER
      7          #include EMBER_AF_API_EMBER_TYPES
      8          #include EMBER_AF_API_HAL
      9          #include EMBER_AF_API_SIM_EEPROM
     10          #include EMBER_AF_API_STACK
     11          #include EMBER_AF_API_TFTP_BOOTLOADER
     12          
     13          
     14          
     15          /** @brief A callback called in interrupt context whenever a button
     16           * changes its state.
     17           *
     18           * @appusage Must be implemented by the application.  This function should
     19           * contain the functionality to be executed in response to changes of state
     20           * in each of the buttons, or callbacks to the appropriate functionality.
     21           *
     22           * @param button  The button which has changed state, either BUTTON0 or BUTTON1
     23           * as defined in the appropriate BOARD_HEADER.
     24           *
     25           * @param state   The new state of the button referenced by the button parameter,
     26           * either ::BUTTON_PRESSED if the button has been pressed or ::BUTTON_RELEASED if
     27           * the button has been released.
     28           */

   \                                 In section .text, align 2, keep-with-next
     29          void halButtonIsr(uint8_t button, uint8_t state)
     30          {
     31          }
   \                     halButtonIsr: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     32          
     33          
     34          
     35          /** @brief Ok To Sleep
     36           *
     37           * This function is called by the Idle/Sleep plugin before sleeping.  It is
     38           * called with interrupts disabled.  The application should return true if the
     39           * device may sleep or false otherwise.
     40           *
     41           * @param durationMs The maximum duration in milliseconds that the device will
     42           * sleep.
     43           */

   \                                 In section .text, align 2, keep-with-next
     44          bool emberAfPluginIdleSleepOkToSleepCallback(uint32_t durationMs)
     45          {
     46            return true;
   \                     emberAfPluginIdleSleepOkToSleepCallback: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
     47          }
     48          
     49          
     50          /** @brief Wake Up
     51           *
     52           * This function is called by the Idle/Sleep plugin after sleeping.
     53           *
     54           * @param durationMs The duration in milliseconds that the device slept.
     55           */

   \                                 In section .text, align 2, keep-with-next
     56          void emberAfPluginIdleSleepWakeUpCallback(uint32_t durationMs)
     57          {
     58          }
   \                     emberAfPluginIdleSleepWakeUpCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     59          
     60          
     61          /** @brief Ok To Idle
     62           *
     63           * This function is called by the Idle/Sleep plugin before idling.  It is called
     64           * with interrupts disabled.  The application should return true if the device
     65           * may idle or false otherwise.
     66           *
     67           * @param durationMs The maximum duration in milliseconds that the device will
     68           * idle.
     69           */

   \                                 In section .text, align 2, keep-with-next
     70          bool emberAfPluginIdleSleepOkToIdleCallback(uint32_t durationMs)
     71          {
     72            return true;
   \                     emberAfPluginIdleSleepOkToIdleCallback: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
     73          }
     74          
     75          
     76          /** @brief Active
     77           *
     78           * This function is called by the Idle/Sleep plugin after idling.
     79           *
     80           * @param durationMs The duration in milliseconds that the device idled.
     81           */

   \                                 In section .text, align 2, keep-with-next
     82          void emberAfPluginIdleSleepActiveCallback(uint32_t durationMs)
     83          {
     84          }
   \                     emberAfPluginIdleSleepActiveCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     85          
     86          
     87          
     88          /** @brief Main
     89           *
     90           * This function is called immediately after the application starts executing
     91           * and can be used to perform initialization that should occur before any other
     92           * components are initialized.
     93           */

   \                                 In section .text, align 2, keep-with-next
     94          void emberAfMainCallback(MAIN_FUNCTION_PARAMETERS)
     95          {
     96          }
   \                     emberAfMainCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     97          
     98          
     99          /** @brief Tick
    100           *
    101           * This function is called in each iteration of the main application loop and
    102           * can be used to perform periodic functions.  The frequency with which this
    103           * function is called depends on how quickly the main loop runs.  If the
    104           * application blocks at any time during the main loop, this function will not
    105           * be called until execution resumes.  On SoC platforms, sleeping and idling
    106           * will block.  On Unix hosts, process yielding (e.g., via select) will block.
    107           */

   \                                 In section .text, align 2, keep-with-next
    108          void emberAfTickCallback(void)
    109          {
    110          }
   \                     emberAfTickCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    111          
    112          
    113          /** @brief Mark Application Buffers
    114           *
    115           * This function is called when the application must mark its buffers.  Buffers
    116           * that are not marked will be reclaimed by the stack.
    117           */

   \                                 In section .text, align 2, keep-with-next
    118          void emberAfMarkApplicationBuffersCallback(void)
    119          {
    120          }
   \                     emberAfMarkApplicationBuffersCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    121          
    122          
    123          
    124          /** @brief The Simulated EEPROM callback function, implemented by the
    125           * application.
    126           *
    127           * @param status  An ::EmberStatus error code indicating one of the conditions
    128           * described below.
    129           *
    130           * This callback will report an EmberStatus of
    131           * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN whenever a token is set and a page needs
    132           * to be erased.  If the main application loop does not periodically
    133           * call halSimEepromErasePage(), it is best to then erase a page in
    134           * response to ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN.
    135           *
    136           * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_ERASE_PAGE_RED
    137           * when the pages <i>must</i> be erased to prevent data loss.
    138           * halSimEepromErasePage() needs to be called until it returns 0 to indicate
    139           * there are no more pages that need to be erased.  Ignoring
    140           * this indication and not erasing the pages will cause dropping the new data
    141           * trying to be written.
    142           *
    143           * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_FULL when
    144           * the new data cannot be written due to unerased pages.  <b>Not erasing
    145           * pages regularly, not erasing in response to
    146           * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN, or not erasing in response to
    147           * ::EMBER_SIM_EEPROM_ERASE_PAGE_RED will cause
    148           * ::EMBER_SIM_EEPROM_FULL and the new data will be lost!.</b>  Any future
    149           * write attempts will be lost as well.
    150           *
    151           * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_REPAIRING
    152           * when the Simulated EEPROM needs to repair itself.  While there's nothing
    153           * for an app to do when the SimEE is going to repair itself (SimEE has to
    154           * be fully functional for the rest of the system to work), alert the
    155           * application to the fact that repairing is occuring.  There are debugging
    156           * scenarios where an app might want to know that repairing is happening;
    157           * such as monitoring frequency.
    158           * @note  Common situations will trigger an expected repair, such as using
    159           *        a new chip or changing token definitions.
    160           *
    161           * If the callback ever reports the status ::EMBER_ERR_FLASH_WRITE_INHIBITED or
    162           * ::EMBER_ERR_FLASH_VERIFY_FAILED, this indicates a catastrophic failure in
    163           * flash writing, meaning either the address being written is not empty or the
    164           * write itself has failed.  If ::EMBER_ERR_FLASH_WRITE_INHIBITED is
    165           * encountered, the function ::halInternalSimEeRepair(false) should be called
    166           * and the chip should then be reset to allow proper initialization to recover.
    167           * If ::EMBER_ERR_FLASH_VERIFY_FAILED is encountered the Simulated EEPROM (and
    168           * tokens) on the specific chip with this error should not be trusted anymore.
    169           *
    170           */

   \                                 In section .text, align 2, keep-with-next
    171          void halSimEepromCallback(EmberStatus status)
    172          {
   \                     halSimEepromCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    173            switch (status) {
   \   00000004   0x3843             SUBS     R0,R0,#+67
   \   00000006   0x.... 0x....      ADR.W    R5,?_0
   \   0000000A   0xD008             BEQ.N    ??halSimEepromCallback_0
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD909             BLS.N    ??halSimEepromCallback_1
   \   00000012   0x1E80             SUBS     R0,R0,#+2
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD90E             BLS.N    ??halSimEepromCallback_2
   \   00000018   0x1FC0             SUBS     R0,R0,#+7
   \   0000001A   0xD031             BEQ.N    ??halSimEepromCallback_3
   \   0000001C   0xE029             B.N      ??halSimEepromCallback_4
    174            case EMBER_SIM_EEPROM_ERASE_PAGE_GREEN:
    175              //SimEE is asking for one page to be erased.
    176          #ifdef EMBER_STACK_COBRA
    177              HalUARTRestrain();
    178          #endif
    179              halSimEepromErasePage();
   \                     ??halSimEepromCallback_0: (+1)
   \   0000001E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000022   0x.... 0x....      B.W      halSimEepromErasePage
    180              break;
    181            case EMBER_SIM_EEPROM_ERASE_PAGE_RED:
    182            case EMBER_SIM_EEPROM_FULL:
    183            { //SimEE says we're out of room!  Erase all pages now or data
    184              //currently being written will be dropped.
    185              bool erasedSome = false;
   \                     ??halSimEepromCallback_1: (+1)
   \   00000026   0x2600             MOVS     R6,#+0
   \   00000028   0xE000             B.N      ??halSimEepromCallback_5
    186          #ifdef EMBER_STACK_COBRA
    187              HalUARTRestrain();
    188          #endif
    189              while(halSimEepromErasePage()) { erasedSome = true; }
   \                     ??halSimEepromCallback_6: (+1)
   \   0000002A   0x2601             MOVS     R6,#+1
   \                     ??halSimEepromCallback_5: (+1)
   \   0000002C   0x.... 0x....      BL       halSimEepromErasePage
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD1FA             BNE.N    ??halSimEepromCallback_6
    190              if(erasedSome) {
   \   00000034   0xBB26             CBNZ.N   R6,??halSimEepromCallback_3
    191                break;
    192              }
    193              //If nothing got erased, then we have a situation where page
    194              //rotation is stuck because live tokens still exist in the
    195              //page we want to erase.  In this case we must do a repair to
    196              //get all live tokens into one virtual page. [BugzId:14392]
    197              //Fall into...
    198            }
    199            case EMBER_ERR_FLASH_WRITE_INHIBITED:
    200            case EMBER_ERR_FLASH_VERIFY_FAILED:
    201            { //Something went wrong while writing a token.  There is stale data and the
    202              //token the app expected to write did not get written.  Also there may
    203              //now be "stray" data written in the flash that could inhibit future token
    204              //writes.  To deal with stray/stale data, we must repair the Simulated
    205              //EEPROM.  Because the expected token write failed and will not be retried,
    206              //it is best to reset the chip and let normal boot sequences take over.
    207              //Since halInternalSimEeRepair() could potentially result in another write
    208              //failure, we use a simple semaphore to prevent recursion.
    209              static bool repairActive = false;
    210              if(!repairActive) {
   \                     ??halSimEepromCallback_2: (+1)
   \   00000036   0x....             LDR.N    R6,??DataTable1
   \   00000038   0x7830             LDRB     R0,[R6, #+0]
   \   0000003A   0xBB08             CBNZ.N   R0,??halSimEepromCallback_3
    211                repairActive = true;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x7030             STRB     R0,[R6, #+0]
    212                halInternalSimEeRepair(false);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       halInternalSimEeStartup
    213                switch (status) {
   \   00000046   0x2C45             CMP      R4,#+69
   \   00000048   0xD010             BEQ.N    ??halSimEepromCallback_7
   \   0000004A   0xD30B             BCC.N    ??halSimEepromCallback_8
   \   0000004C   0x2C47             CMP      R4,#+71
   \   0000004E   0xD001             BEQ.N    ??halSimEepromCallback_9
   \   00000050   0xD303             BCC.N    ??halSimEepromCallback_10
   \   00000052   0xE007             B.N      ??halSimEepromCallback_8
    214                case EMBER_SIM_EEPROM_FULL:
    215                  //Don't reboot - return to let SimEE code retry the token write
    216                  //[BugzId:14392]
    217                  break;
    218                case EMBER_ERR_FLASH_VERIFY_FAILED:
    219                  //[[WBB350FIXME -It would be nice to have a unified, ]]
    220                  //[[             platform independant reboot machanism]]
    221                  #if defined (XAP2B)
    222                    halInternalSysReset(CE_REBOOT_F_VERIFY);
    223                  #elif defined (CORTEXM3)
    224                    halInternalSysReset(RESET_FLASH_VERIFY);
   \                     ??halSimEepromCallback_9: (+1)
   \   00000054   0xF640 0x0001      MOVW     R0,#+2049
   \   00000058   0xE001             B.N      ??halSimEepromCallback_11
    225                  #else
    226                    assert(0);
    227                  #endif
    228                  break;
    229                case EMBER_ERR_FLASH_WRITE_INHIBITED:
    230                  #if defined (XAP2B)
    231                    halInternalSysReset(CE_REBOOT_F_INHIBIT);
    232                  #elif defined (CORTEXM3)
    233                    halInternalSysReset(RESET_FLASH_INHIBIT);
   \                     ??halSimEepromCallback_10: (+1)
   \   0000005A   0xF640 0x0002      MOVW     R0,#+2050
   \                     ??halSimEepromCallback_11: (+1)
   \   0000005E   0x.... 0x....      BL       halInternalSysReset
    234                  #else
    235                    assert(0);
    236                  #endif
    237                  break;
   \   00000062   0xE003             B.N      ??halSimEepromCallback_7
    238                default:
    239                  assert(0);
   \                     ??halSimEepromCallback_8: (+1)
   \   00000064   0x21EF             MOVS     R1,#+239
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       halInternalAssertFailed
    240                  break;
    241                }
    242                repairActive = false;
   \                     ??halSimEepromCallback_7: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7030             STRB     R0,[R6, #+0]
   \   00000070   0xBD70             POP      {R4-R6,PC}
    243              }
    244              break;
    245            }
    246            case EMBER_SIM_EEPROM_REPAIRING:
    247              // While there's nothing for an app to do when the SimEE is going to
    248              // repair itself (SimEE has to be fully functional for the rest of the
    249              // system to work), alert the application to the fact that repairing
    250              // is occuring.  There are debugging scenarios where an app might want
    251              // to know that repairing is happening; such as monitoring frequency.
    252              // NOTE:  Common situations will trigger an expected repair, such as
    253              //        using an erased chip or changing token definitions.
    254              break;
    255            default:
    256              // this condition indicates an unexpected problem.
    257              assert(0);
   \                     ??halSimEepromCallback_4: (+1)
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000078   0xF240 0x1101      MOVW     R1,#+257
   \   0000007C   0x.... 0x....      B.W      halInternalAssertFailed
    258              break;
    259            }
    260          }
   \                     ??halSimEepromCallback_3: (+1)
   \   00000080   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 1
   \                     ??repairActive:
   \   00000000                      DS8 1
    261          
    262          
    263          
    264          /** @brief A callback that allows the application to send a message in
    265            * response to a poll from a child.
    266            *
    267            * This function is called when a child polls,
    268            * provided that the pending message flag is set for that child
    269            * (see ::emberSetMessageFlag(). The message should be sent to the child
    270            * using ::emberSendUnicast() with the ::EMBER_APS_OPTION_POLL_RESPONSE option.
    271            *
    272            * If the application includes ::emberPollHanlder(), it must
    273            * define EMBER_APPLICATION_HAS_POLL_HANDLER in its CONFIGURATION_HEADER.
    274            *
    275            * @param childId           The ID of the child that is requesting data.
    276            *
    277            * @param transmitExpected  true if the child is expecting an application-
    278            *     supplied data message.  false otherwise.
    279            *
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          void emberPollHandler(EmberNodeId childId, bool transmitExpected)
    282          {
    283          }
   \                     emberPollHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    284          
    285          
    286          

   \                                 In section .text, align 2, keep-with-next
    287          void emberIpIncomingBeaconHandler(PacketHeader header)
    288          {
    289          }
   \                     emberIpIncomingBeaconHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    290          
    291          
    292          /** @brief Provices the result of a call to emberChangeNodeType():
    293           * either EMBER_SUCCESS, or EMBER_INVALID_CALL.
    294           */

   \                                 In section .text, align 2, keep-with-next
    295          void emberChangeNodeTypeReturn(EmberStatus status)
    296          {
    297          }
   \                     emberChangeNodeTypeReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    298          
    299          
    300          /**
    301           * @brief Provides the result of a call to emberCommissionNetwork.
    302           *
    303           * Returns EMBER_SUCCESS if successful
    304           *         EMBER_BAD_ARGUMENT if any of the options are wrong
    305           *         EMBER_INVALID_CALL if the node is already on a network
    306           *
    307           * @param status Whether the call to emberCommissionNetwork was successful
    308           */

   \                                 In section .text, align 2, keep-with-next
    309          void emberCommissionNetworkReturn(EmberStatus status)
    310          {
    311          }
   \                     emberCommissionNetworkReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    312          
    313          
    314          /** @brief Provides the result of a call to ::emberConfigureGateway */

   \                                 In section .text, align 2, keep-with-next
    315          void emberConfigureGatewayReturn(EmberStatus status)
    316          {
    317          }
   \                     emberConfigureGatewayReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    318          
    319          
    320          /** @brief A callback invoked to inform the application of the
    321           * occurrence of an event defined by EmberCounterType, for example,
    322           * transmissions and receptions at different layers of the stack.
    323           *
    324           * The application must define EMBER_APPLICATION_HAS_COUNTER_HANDLER
    325           * in its CONFIGURATION_HEADER to use this.
    326           * This function may be called in ISR context, so processing should
    327           * be kept to a minimum.
    328           *
    329           * @param type       The type of the event.
    330           * @param increment  Specify the increase in the counter's tally.
    331           *
    332           */

   \                                 In section .text, align 2, keep-with-next
    333          void emberCounterHandler(EmberCounterType type, uint16_t increment)
    334          {
    335          }
   \                     emberCounterHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    336          
    337          
    338          /** @brief NCP handler called to process a custom message from the Host.
    339           *
    340           * @param message message received
    341           * @param messageLength length of message
    342           */

   \                                 In section .text, align 2, keep-with-next
    343          void emberCustomHostToNcpMessageHandler(const uint8_t *message,
    344                                                  uint8_t messageLength)
    345          {
    346          }
   \                     emberCustomHostToNcpMessageHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    347          
    348          
    349          /** @brief Host handler called to process a custom message from the NCP.
    350           *
    351           * @param message message received
    352           * @param messageLength length of message
    353           */

   \                                 In section .text, align 2, keep-with-next
    354          void emberCustomNcpToHostMessageHandler(const uint8_t *message,
    355                                                  uint8_t messageLength)
    356          {
    357          }
   \                     emberCustomNcpToHostMessageHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    358          
    359          
    360          /** @brief For a sleepy end device, report how long the chip went to deep sleep.
    361           * In a NCP + host setup, the stack reports this to the host app.
    362           */

   \                                 In section .text, align 2, keep-with-next
    363          void emberDeepSleepCallback(uint16_t sleepDuration)
    364          {
    365          }
   \                     emberDeepSleepCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    366          
    367          
    368          /** @brief Provides the result of a call to emberDeepSleep(). */

   \                                 In section .text, align 2, keep-with-next
    369          void emberDeepSleepReturn(EmberStatus status)
    370          {
    371          }
   \                     emberDeepSleepReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    372          
    373          
    374          /** @brief This method is called any time an event is scheduled from within an
    375           * ISR context. It can be used to determine when to stop a long running sleep
    376           * to see what application or stack events now need to be processed.
    377           * @param event The event that was scheduled by the ISR.
    378           */

   \                                 In section .text, align 2, keep-with-next
    379          void emberEventDelayUpdatedFromIsrHandler(Event *event)
    380          {
    381          }
   \                     emberEventDelayUpdatedFromIsrHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    382          
    383          
    384          /** @brief
    385           * This is called when the stack knows about a border router that has
    386           * an external route to a prefix.
    387           *
    388           * @param prefix            external route prefix
    389           * @param prefixLength      length of the prefix
    390           * @param available         whether this external route is available.
    391           */

   \                                 In section .text, align 2, keep-with-next
    392          void emberExternalRouteChange(const uint8_t *prefix,
    393                                        uint8_t prefixLength,
    394                                        bool available)
    395          {
    396          }
   \                     emberExternalRouteChange: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    397          
    398          
    399          /** @brief Provides the result of a call to emberGetCcaThreshold(). */

   \                                 In section .text, align 2, keep-with-next
    400          void emberGetCcaThresholdReturn(int8_t threshold)
    401          {
    402          }
   \                     emberGetCcaThresholdReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    403          
    404          
    405          /** @brief
    406           * Gets the token information for tokenId = EMBER_CHANNEL_CAL_DATA_TOKEN
    407           *
    408           * @param lna          [msb: cal needed? | bit 0-5: lna tune value]
    409           * @param tempAtLna    [the temp (degC) when the LNA was calibrated]
    410           * #param modDac       [msb: cal needed? | bit 0-5: modulation DAC tune value]
    411           * @param tempAtModDac [the temp (degC) when the mod DAC was calibrated]
    412           */

   \                                 In section .text, align 2, keep-with-next
    413          void emberGetChannelCalDataTokenReturn(uint8_t lna,
    414                                                 int8_t tempAtLna,
    415                                                 uint8_t modDac,
    416                                                 int8_t tempAtModDac)
    417          {
    418          }
   \                     emberGetChannelCalDataTokenReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    419          
    420          
    421          /** @brief Provides the result of a call to emberGetCounter(). */

   \                                 In section .text, align 2, keep-with-next
    422          void emberGetCounterReturn(EmberCounterType type, uint16_t value)
    423          {
    424          }
   \                     emberGetCounterReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    425          
    426          
    427          /** @brief Provides the result of a call to ::emberGetDhcpClients */

   \                                 In section .text, align 2, keep-with-next
    428          void emberGetDhcpClientReturn(const EmberIpv6Address *address)
    429          {
    430          }
   \                     emberGetDhcpClientReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    431          
    432          
    433          /** @brief Provides the result of a call to emberGetNetworkDataTlv().
    434           *
    435           * @param type the type of TLV returned. This is the same value as
    436           * the value specified in the emberGetNetworkDataTlv() call.
    437           * @param index the instance number of the TLV. This is the same value as
    438           * the value specified in the emberGetNetworkDataTlv() call.
    439           * @param versionNumber the network data version
    440           * @param tlv the TLV corresponding to type or NULL.
    441           * @param tlvLength length of tlv
    442           */

   \                                 In section .text, align 2, keep-with-next
    443          void emberGetNetworkDataTlvReturn(uint8_t typeByte,
    444                                            uint8_t index,
    445                                            uint8_t versionNumber,
    446                                            const uint8_t *tlv,
    447                                            uint8_t tlvLength)
    448          {
    449          }
   \                     emberGetNetworkDataTlvReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    450          
    451          
    452          /** @brief Provides the result of a call to emberGetRadioPower() on the host. */

   \                                 In section .text, align 2, keep-with-next
    453          void emberGetRadioPowerReturn(int8_t power)
    454          {
    455          }
   \                     emberGetRadioPowerReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    456          
    457          
    458          /** @brief Provides the result of a call to emberGetRipEntry(). */

   \                                 In section .text, align 2, keep-with-next
    459          void emberGetRipEntryReturn(uint8_t index, const EmberRipEntry *entry)
    460          {
    461          }
   \                     emberGetRipEntryReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    462          
    463          
    464          /** @brief Provides the result of a call to ::emberGetRoutingLocator
    465           *
    466           * @param rloc The Routing Locator as a full IPv6 address.
    467           */

   \                                 In section .text, align 2, keep-with-next
    468          void emberGetRoutingLocatorReturn(const EmberIpv6Address *rloc)
    469          {
    470          }
   \                     emberGetRoutingLocatorReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    471          
    472          
    473          /** @brief Provides the result of a call to emberGetTxPowerMode() on the host.
    474           * @return the current tx power mode.
    475           */

   \                                 In section .text, align 2, keep-with-next
    476          void emberGetTxPowerModeReturn(uint16_t txPowerMode)
    477          {
    478          }
   \                     emberGetTxPowerModeReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    479          
    480          
    481          /** @brief Application handler to define "passthrough" packets.
    482           */

   \                                 In section .text, align 2, keep-with-next
    483          bool emberMacPassthroughFilterHandler(uint8_t *macHeader)
    484          {
    485            return false;
   \                     emberMacPassthroughFilterHandler: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    486          }
    487          
    488          
    489          /** @brief Application handler to intercept "passthrough" packets and
    490           * handle them at the application.
    491           */

   \                                 In section .text, align 2, keep-with-next
    492          void emberMacPassthroughMessageHandler(PacketHeader header)
    493          {
    494          }
   \                     emberMacPassthroughMessageHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    495          
    496          
    497          /** @brief A callback invoked when the leader data changes.
    498           *
    499           * @param leaderData the leader data
    500           */

   \                                 In section .text, align 2, keep-with-next
    501          void emberLeaderDataHandler(const uint8_t *leaderData)
    502          {
    503          }
   \                     emberLeaderDataHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    504          
    505          
    506          /** @brief  If implementing event-driven sleep on an NCP host, this method will
    507           * return the bitmask indicating the stack's current tasks. (see enum above)
    508           *
    509           *  The mask ::EMBER_HIGH_PRIORITY_TASKS defines which tasks are high
    510           *  priority.  Devices should not sleep if any high priority tasks are active.
    511           *  Active tasks that are not high priority are waiting for
    512           *  messages to arrive from other devices.  If there are active tasks,
    513           *  but no high priority ones, the device may sleep but should periodically
    514           *  wake up and call ::emberPollForData() in order to receive messages.  Parents
    515           *  will hold messages for ::EMBER_INDIRECT_TRANSMISSION_TIMEOUT milliseconds
    516           *  before discarding them.
    517           *
    518           * @return A bitmask of the stack's active tasks.
    519           */

   \                                 In section .text, align 2, keep-with-next
    520          void emberOkToNapReturn(uint8_t stateMask)
    521          {
    522          }
   \                     emberOkToNapReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    523          
    524          
    525          /** @brief Provides the result of a call to emberPollForData().
    526           * @param An EmberStatus value:
    527           * - ::EMBER_SUCCESS      - The poll message has been submitted for transmission
    528           * - ::EMBER_INVALID_CALL - The node is not a sleepy end device.
    529           * - ::EMBER_NOT_JOINED   - The node is not part of a network.
    530           *
    531           * @param Data pending flag: If true, it means the parent is about to send more
    532           *                           data, so the application should take note and poll
    533           *                           more frequently in case of a fragment or indirect
    534           *                           timeout.
    535           */

   \                                 In section .text, align 2, keep-with-next
    536          void emberPollForDataReturn(EmberStatus status, bool dataPending)
    537          {
    538          }
   \                     emberPollForDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    539          
    540          
    541          /** @brief  Notifies the application of a reset on the Ember chip
    542           * due to the indicated cause.
    543           */

   \                                 In section .text, align 2, keep-with-next
    544          void emberResetMicroHandler(EmberResetCause cause)
    545          {
    546          }
   \                     emberResetMicroHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    547          
    548          
    549          /** @brief
    550           * Provides the result of a call to emberResignGlobalAddress().
    551           */

   \                                 In section .text, align 2, keep-with-next
    552          void emberResignGlobalAddressReturn(EmberStatus status)
    553          {
    554          }
   \                     emberResignGlobalAddressReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    555          
    556          
    557          /** @brief Provides the result of a call to emberSetCcaThreshold(). */

   \                                 In section .text, align 2, keep-with-next
    558          void emberSetCcaThresholdReturn(EmberStatus status)
    559          {
    560          }
   \                     emberSetCcaThresholdReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    561          
    562          
    563          /** @brief Provides the result of a call to emberSetRadioPower() on the host. */

   \                                 In section .text, align 2, keep-with-next
    564          void emberSetRadioPowerReturn(EmberStatus status)
    565          {
    566          }
   \                     emberSetRadioPowerReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    567          
    568          
    569          /** @brief Provides the result of a call to emberSetTxPowerMode() on the host. */

   \                                 In section .text, align 2, keep-with-next
    570          void emberSetTxPowerModeReturn(EmberStatus status)
    571          {
    572          }
   \                     emberSetTxPowerModeReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    573          
    574          
    575          /** @brief Provides the result of a call to emberStackPollForData(). */

   \                                 In section .text, align 2, keep-with-next
    576          void emberStackPollForDataReturn(EmberStatus status)
    577          {
    578          }
   \                     emberStackPollForDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    579          
    580          
    581          /** @brief Callback to tell the host to start security commissioning
    582           *
    583           * @param address parent IP address, 16 bytes
    584           */

   \                                 In section .text, align 2, keep-with-next
    585          void emberStartHostJoinClientHandler(const uint8_t *parentAddress)
    586          {
    587          }
   \                     emberStartHostJoinClientHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    588          
    589          
    590          /** @brief
    591           * This can be stubbed out on the SoC and host app.  It is used by the
    592           * NCP to update security on the driver when it is instructed to switch
    593           * the network key by an over the air update.
    594           *
    595           */

   \                                 In section .text, align 2, keep-with-next
    596          void emberSwitchToNextNetworkKeyHandler(EmberStatus status)
    597          {
    598          }
   \                     emberSwitchToNextNetworkKeyHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    599          
    600          
    601          /** @brief Provides the result of a call to emberSwitchToNextNetworkKey(). */

   \                                 In section .text, align 2, keep-with-next
    602          void emberSwitchToNextNetworkKeyReturn(EmberStatus status)
    603          {
    604          }
   \                     emberSwitchToNextNetworkKeyReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    605          
    606          
    607          /**
    608           * @brief Provides the result of a call to emberState() on the host.
    609           *
    610           * @param parameters Current network parameters
    611           * @param localEui64 The EUI64 of the Ember chip
    612           * @param networkStatus The current status of the network
    613           */

   \                                 In section .text, align 2, keep-with-next
    614          void emberStateReturn(const EmberNetworkParameters *parameters,
    615                                const EmberEui64 *localEui64,
    616                                EmberNetworkStatus networkStatus)
    617          {
    618          }
   \                     emberStateReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    619          
    620          
    621          
    622          /** @brief The radio calibration callback function.
    623           *
    624           * The Voltage Controlled Oscillator (VCO) can drift with
    625           * temperature changes.  During every call to ::emberTick(), the stack will
    626           * check to see if the VCO has drifted.  If the VCO has drifted, the stack
    627           * will call ::emberRadioNeedsCalibratingHandler() to inform the application
    628           * that it should perform calibration of the current channel as soon as
    629           * possible.  Calibration can take up to 150ms.  The default callback function
    630           * implementation provided here performs calibration immediately.  If the
    631           * application wishes, it can define its own callback by defining
    632           * ::EMBER_APPLICATION_HAS_CUSTOM_RADIO_CALIBRATION_CALLBACK in its
    633           * CONFIGURATION_HEADER.  It can then failsafe any critical processes or
    634           * peripherals before calling ::emberCalibrateCurrentChannel().  The
    635           * application must call ::emberCalibrateCurrentChannel() in
    636           * response to this callback to maintain expected radio performance.
    637           */

   \                                 In section .text, align 2, keep-with-next
    638          void emberRadioNeedsCalibratingHandler(void)
    639          {
    640          }
   \                     emberRadioNeedsCalibratingHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    641          
    642          
    643          
    644          // Called when a connection is opened to serverPort.

   \                                 In section .text, align 2, keep-with-next
    645          void emberTcpAcceptHandler(uint16_t serverPort, uint8_t fd)
    646          {
    647          }
   \                     emberTcpAcceptHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    648          
    649          

   \                                 In section .text, align 2, keep-with-next
    650          void emberTcpReadHandler(uint8_t fd, uint8_t *buffer, uint16_t count)
    651          {
    652          }
   \                     emberTcpReadHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    653          
    654          

   \                                 In section .text, align 2, keep-with-next
    655          void emberTcpStatusHandler(uint8_t fd, uint8_t status)
    656          {
    657          }
   \                     emberTcpStatusHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    658          
    659          

   \                                 In section .text, align 2, keep-with-next
    660          void emberAddAddressDataReturn(uint16_t shortId)
    661          {
    662          }
   \                     emberAddAddressDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    663          
    664          

   \                                 In section .text, align 2, keep-with-next
    665          void emberAssertInfoReturn(const uint8_t *fileName, uint32_t lineNumber)
    666          {
    667          }
   \                     emberAssertInfoReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    668          
    669          

   \                                 In section .text, align 2, keep-with-next
    670          void emberClearAddressCacheReturn(void)
    671          {
    672          }
   \                     emberClearAddressCacheReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    673          
    674          

   \                                 In section .text, align 2, keep-with-next
    675          void emberConfigUartReturn(void)
    676          {
    677          }
   \                     emberConfigUartReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    678          
    679          

   \                                 In section .text, align 2, keep-with-next
    680          void emberEchoReturn(const uint8_t *data, uint8_t length)
    681          {
    682          }
   \                     emberEchoReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    683          
    684          

   \                                 In section .text, align 2, keep-with-next
    685          void emberGetMulticastEntryReturn(uint8_t lastSequence,
    686                                            uint8_t windowBitmask,
    687                                            uint8_t dwellQs,
    688                                            const uint8_t *seed)
    689          {
    690          }
   \                     emberGetMulticastEntryReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    691          
    692          

   \                                 In section .text, align 2, keep-with-next
    693          void emberGetNetworkKeyInfoReturn(EmberStatus status,
    694                                            uint32_t sequence,
    695                                            uint8_t state)
    696          {
    697          }
   \                     emberGetNetworkKeyInfoReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    698          
    699          

   \                                 In section .text, align 2, keep-with-next
    700          void emberGetNodeStatusReturn(EmberStatus status,
    701                                        uint8_t ripId,
    702                                        EmberNodeId nodeId,
    703                                        uint8_t parentRipId,
    704                                        EmberNodeId parentId,
    705                                        const uint8_t *networkFragmentIdentifier,
    706                                        uint32_t networkFrameCounter)
    707          {
    708          }
   \                     emberGetNodeStatusReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    709          
    710          

   \                                 In section .text, align 2, keep-with-next
    711          void emberLookupAddressDataReturn(uint16_t shortId)
    712          {
    713          }
   \                     emberLookupAddressDataReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    714          
    715          

   \                                 In section .text, align 2, keep-with-next
    716          void emberNcpUdpStormCompleteHandler(void)
    717          {
    718          }
   \                     emberNcpUdpStormCompleteHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    719          
    720          

   \                                 In section .text, align 2, keep-with-next
    721          void emberNcpUdpStormReturn(EmberStatus status)
    722          {
    723          }
   \                     emberNcpUdpStormReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    724          
    725          

   \                                 In section .text, align 2, keep-with-next
    726          void emberResetNcpAshReturn(void)
    727          {
    728          }
   \                     emberResetNcpAshReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    729          
    730          

   \                                 In section .text, align 2, keep-with-next
    731          void emberSendDoneReturn(void)
    732          {
    733          }
   \                     emberSendDoneReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    734          
    735          

   \                                 In section .text, align 2, keep-with-next
    736          void emberSetWakeupSequenceNumberReturn(void)
    737          {
    738          }
   \                     emberSetWakeupSequenceNumberReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    739          
    740          

   \                                 In section .text, align 2, keep-with-next
    741          void emberUartSpeedTestReturn(uint32_t totalBytesSent,
    742                                        uint32_t payloadBytesSent,
    743                                        uint32_t timeout)
    744          {
    745          }
   \                     emberUartSpeedTestReturn: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    746          
    747          
    748          
    749          /** @brief Receive a multicast */

   \                                 In section .text, align 2, keep-with-next
    750          void emberUdpMulticastHandler(const uint8_t *destinationIpv6Address,
    751                                        const uint8_t *sourceIpv6Address,
    752                                        uint16_t localPort,
    753                                        uint16_t remotePort,
    754                                        uint8_t flags,
    755                                        const uint8_t *packet,
    756                                        uint16_t length)
    757          {
    758          }
   \                     emberUdpMulticastHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     ??repairActive

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x74 0x68          DC8 "thread-callback-stubs.c"
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x2D 0x63    
   \              0x61 0x6C    
   \              0x6C 0x62    
   \              0x61 0x63    
   \              0x6B 0x2D    
   \              0x73 0x74    
   \              0x75 0x62    
   \              0x73 0x2E    
   \              0x63 0x00    
    759          
    760          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   emberAddAddressDataReturn
       0   emberAfMainCallback
       0   emberAfMarkApplicationBuffersCallback
       0   emberAfPluginIdleSleepActiveCallback
       0   emberAfPluginIdleSleepOkToIdleCallback
       0   emberAfPluginIdleSleepOkToSleepCallback
       0   emberAfPluginIdleSleepWakeUpCallback
       0   emberAfTickCallback
       0   emberAssertInfoReturn
       0   emberChangeNodeTypeReturn
       0   emberClearAddressCacheReturn
       0   emberCommissionNetworkReturn
       0   emberConfigUartReturn
       0   emberConfigureGatewayReturn
       0   emberCounterHandler
       0   emberCustomHostToNcpMessageHandler
       0   emberCustomNcpToHostMessageHandler
       0   emberDeepSleepCallback
       0   emberDeepSleepReturn
       0   emberEchoReturn
       0   emberEventDelayUpdatedFromIsrHandler
       0   emberExternalRouteChange
       0   emberGetCcaThresholdReturn
       0   emberGetChannelCalDataTokenReturn
       0   emberGetCounterReturn
       0   emberGetDhcpClientReturn
       0   emberGetMulticastEntryReturn
       0   emberGetNetworkDataTlvReturn
       0   emberGetNetworkKeyInfoReturn
       0   emberGetNodeStatusReturn
       0   emberGetRadioPowerReturn
       0   emberGetRipEntryReturn
       0   emberGetRoutingLocatorReturn
       0   emberGetTxPowerModeReturn
       0   emberIpIncomingBeaconHandler
       0   emberLeaderDataHandler
       0   emberLookupAddressDataReturn
       0   emberMacPassthroughFilterHandler
       0   emberMacPassthroughMessageHandler
       0   emberNcpUdpStormCompleteHandler
       0   emberNcpUdpStormReturn
       0   emberOkToNapReturn
       0   emberPollForDataReturn
       0   emberPollHandler
       0   emberRadioNeedsCalibratingHandler
       0   emberResetMicroHandler
       0   emberResetNcpAshReturn
       0   emberResignGlobalAddressReturn
       0   emberSendDoneReturn
       0   emberSetCcaThresholdReturn
       0   emberSetRadioPowerReturn
       0   emberSetTxPowerModeReturn
       0   emberSetWakeupSequenceNumberReturn
       0   emberStackPollForDataReturn
       0   emberStartHostJoinClientHandler
       0   emberStateReturn
       0   emberSwitchToNextNetworkKeyHandler
       0   emberSwitchToNextNetworkKeyReturn
       0   emberTcpAcceptHandler
       0   emberTcpReadHandler
       0   emberTcpStatusHandler
       0   emberUartSpeedTestReturn
       0   emberUdpMulticastHandler
       0   halButtonIsr
      16   halSimEepromCallback
         0   -> halInternalAssertFailed
        16   -> halInternalAssertFailed
        16   -> halInternalSimEeStartup
        16   -> halInternalSysReset
         0   -> halSimEepromErasePage
        16   -> halSimEepromErasePage


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      24  ?_0
       2  emberAddAddressDataReturn
       2  emberAfMainCallback
       2  emberAfMarkApplicationBuffersCallback
       2  emberAfPluginIdleSleepActiveCallback
       4  emberAfPluginIdleSleepOkToIdleCallback
       4  emberAfPluginIdleSleepOkToSleepCallback
       2  emberAfPluginIdleSleepWakeUpCallback
       2  emberAfTickCallback
       2  emberAssertInfoReturn
       2  emberChangeNodeTypeReturn
       2  emberClearAddressCacheReturn
       2  emberCommissionNetworkReturn
       2  emberConfigUartReturn
       2  emberConfigureGatewayReturn
       2  emberCounterHandler
       2  emberCustomHostToNcpMessageHandler
       2  emberCustomNcpToHostMessageHandler
       2  emberDeepSleepCallback
       2  emberDeepSleepReturn
       2  emberEchoReturn
       2  emberEventDelayUpdatedFromIsrHandler
       2  emberExternalRouteChange
       2  emberGetCcaThresholdReturn
       2  emberGetChannelCalDataTokenReturn
       2  emberGetCounterReturn
       2  emberGetDhcpClientReturn
       2  emberGetMulticastEntryReturn
       2  emberGetNetworkDataTlvReturn
       2  emberGetNetworkKeyInfoReturn
       2  emberGetNodeStatusReturn
       2  emberGetRadioPowerReturn
       2  emberGetRipEntryReturn
       2  emberGetRoutingLocatorReturn
       2  emberGetTxPowerModeReturn
       2  emberIpIncomingBeaconHandler
       2  emberLeaderDataHandler
       2  emberLookupAddressDataReturn
       4  emberMacPassthroughFilterHandler
       2  emberMacPassthroughMessageHandler
       2  emberNcpUdpStormCompleteHandler
       2  emberNcpUdpStormReturn
       2  emberOkToNapReturn
       2  emberPollForDataReturn
       2  emberPollHandler
       2  emberRadioNeedsCalibratingHandler
       2  emberResetMicroHandler
       2  emberResetNcpAshReturn
       2  emberResignGlobalAddressReturn
       2  emberSendDoneReturn
       2  emberSetCcaThresholdReturn
       2  emberSetRadioPowerReturn
       2  emberSetTxPowerModeReturn
       2  emberSetWakeupSequenceNumberReturn
       2  emberStackPollForDataReturn
       2  emberStartHostJoinClientHandler
       2  emberStateReturn
       2  emberSwitchToNextNetworkKeyHandler
       2  emberSwitchToNextNetworkKeyReturn
       2  emberTcpAcceptHandler
       2  emberTcpReadHandler
       2  emberTcpStatusHandler
       2  emberUartSpeedTestReturn
       2  emberUdpMulticastHandler
       2  halButtonIsr
     130  halSimEepromCallback
       1  repairActive

 
   1 byte  in section .bss
 292 bytes in section .text
 
 292 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
